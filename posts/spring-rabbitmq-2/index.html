<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring with RabbitMQ(2)" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Spring with RabbitMQ RabbitMQ에서 사용하는 AMQP 0-9-1 모델과 RabbitMQ의 컨셉을 정리하기 위해 작성하였다. Spring과의 자세한 매핑은 이후 글에서 작성할 예정 AMQP 0-9-1 Model High-level Overview of AMQP 0-9-1 and the AMQP Model What is AMQP 0-9-1? AMQP 0-9-1(Advanced Message Queueing Protocol)은 클라이언트 어플리케이션들이 미들웨어 메시지 브로커를 통해 통신할 수 있도록 하는 메시지 프로토콜을 의미한다. Brokers and Their Role 브로커(Broker)는 Publisher(생산자, 메시지를 브로커에게 전송하는 어플리케이션, Producer라고도 불리운다)에게 메시지를 수신하며, 이를 Consumer(소비자, 메시지를 브로커로부터 수신하여 처리하는 어플리케이션)에게 전달한다. AMQP-0-9-1은 메시지 프로토콜이기 때문에, Publisher, Broker, Consumer는 서로 다른 장비에서 동작할 수 있다. AMQP 0-9-1 Model in Brief AMQP-0-9-1 Model에는 위에서 설명한 Producer, Broker, Consumer 말고도 몇가지 개념이 더 존재한다. Enchange: Producer로부터 메시지를 수신하여 정해진 규칙(Binding)에 따라 Queue에 전달(복사)한다. Binding: Exchange와 Queue를 연결하는 규칙 Queue: 메시지를 소비하기 전 대기하는 논리적인 장소 메시지가 전달되는 과정은 아래와 같다. Producer는 Exchange에 메시지를 전달한다. Exchange는 메시지의 속성과 일치하는 Binding을 찾는다. 찾은 Binding에 연결된 Queue에 메시지를 복사한다. Consumer는 Pull 혹은 Push 방식으로 Queue에서 메시지를 수신/소비한다. Network는 완전히 신뢰할 수 없고 Consumer가 메시지를 처리하는 도중 Exception이 발생하여 메시지가 유실될 수 있기 때문에 AMQP Model은 Message Acknowledgement라는 개념이 존재한다. Broker는 메시지를 Consumer에게 전달했더라도 즉시 Queue에서 메시지를 삭제하지 않고, Consumer로부터 Acknowledge를 수신한 이후에 메시지를 삭제하게 된다. 즉, Consumer가 메시지를 처리하는 도중 Exception이 발생하여 Connection이 끊어지는 경우, 메시지는 유실되지 않고 다른 Consumer에 의해 처리될 수 있다. Acknowlege는 설정에 따라 Consumer로 메시지 수신 시 자동으로 Acknowledge를 Broker에게 전달 Consumer에서 수동으로(Programmitically) Acknowledge 처리 를 할 수 있다. AMQP’s Entities Exchange Exchange는 메시지를 전달하는 AMQP의 개체이다. Exchange는 메시지를 수신하여 이를 0개 이상의 Queue에 전달하는 역할을 담당한다. 메시지를 Routing하는 방식은 Exchange의 종류와 Binding이라고 불리는 Rule에 의해 결정된다. 아래는 AMQP 0-9-1의 Exchange 종류이다. Name Default pre-declared names Direct exchange (Empty string) and amq.direct Fanout exchange amq.fanout Topic exchange amq.topic Headers exchange amq.match (and amq.headers in RabbitMQ) 이와 별개로 Exchange는 몇가지 특성들을 포함하고 있다. Name: Exchange의 이름을 의미한다. Durability: Broker가 재시작해도 Exchange를 유지할지에 대한 Flag. Auto-delete: 모든 Queue가 Unbind 되었을 때 Exchange를 유지할지에 대한 Flag. Direct Exchange Direct Exchange는 메시지의 Routing Key를 이용해 Queue에게 메시지를 전달한다. Direct Exchange는 Unicast 방식으로 메시지를 전달할 때 유용하다.(물론 활용에 따라 Multicast 방식도 가능하다) Queue는 Routing Key ‘K’를 이용하여 Exchange에 Binding한다. 메시지가 Routing Key ‘R’과 함께 Exchange에 수신되었을 때, ‘K’와 ‘R’이 일치한다면 Exchange는 메시지를 해당 Queue에 전달한다. Direct Exchange는 여러 개의 Worker에게 작업을 분산할 때 주로 사용된다. 하나의 Exchange에 서로 다른 Routing Key를 가진 Queue 여러 개가 Binding 될 수 있다. Direct Exchange에 동일한 Routing Key를 가진 서로 다른 Queue가 Binding 된다면, 동일한 Routing Key를 가진 Queue 들에게는 Fanout 방식으로 메시지가 전달된다. Fanout Exchange Fanout Exchange는 Exchange에 Binding 된 모든 Queue에게 같은 메시지를 전달한다(Ignore Routing Key). 만일 N개의 Queue가 Exchange에 Binding 되어 있는 경우, 새 메시지가 Exchange에 발생한 경우 N개의 Queue에 새로운 메시지가 복사된다. Fanout Exchange는 메시지를 Broadcasting 할 때 유용하게 사용된다. Topic Exchange와 Header Exchange의 경우 현재 사용할 예정이 없기에 정리하지 않음. Queue AMQP 0-9-1 Model의 Queue는 다른 Queueing System에서의 Queue 개념과 거의 유사하다. Queue는 Consumer가 소비할 메시지들을 저장하고 있는 장소이다. Queue는 몇몇 Property를 Exchange와 공유한다. Name: Queue의 이름이다. Durable: Broker 재시작 후에도 Queue를 유지할지에 대한 Flag. Exclusive: Queue가 1개의 Connection만 허용하고, 해당 Connection이 끊긴다면 Queue를 유지할지에 대한 Flag. Auto-delete: Queue를 바라보던 Consumer 들이 모두 제거된 후 Queue를 유지할지에 대한 Flag. Queue Name 어플리케이션은 자신이 사용할 Queue 이름을 선택한 후 Broker에게 생성을 요청한다. Queue 이름은 255byte(UTF-8)까지 허용된다. 빈 문자열을 이용해 Queue 이름을 선언하여 생성을 요청하는 경우, Broker가 임의의 Unique한 Queue 이름을 생성한 뒤 Application에게 반환해준다. amq. Prefix를 가지는 Queue는 Broker 내부에서 사용되는 Queue 이름이기 때문에 생성 요청 시 403 코드를 포함한 오류가 발생하게 된다. Queue Durability Durable Queue는 Disk에 유지되며, Broker가 재시작 되어도 유지된다. Durable하지 않는 Queue는 Transient라고 불린다. 단, Queue가 Durable하다고 해서 그 안에 저장된 메시지까지 유지되는 것은 아니다. 브로커가 재시작된 이후에도 메시지를 유지하고 싶다면 메시지를 Persistent 타입으로 지정해야 한다. Binding Binding은 Exchange가 메시지를 Queue에게 전달하기 위한 규칙이다. 만일 메시지에 일치하는 Binding이 존재하지 않는 경우 메시지는 유실되거나 Publisher에게 반환된다. Consumer Consumer는 Queue에 저장된 메시지를 소비하는 어플리케이션이며, Push와 Pull 방식으로 동작할 수 있다. Push 방식: 메시지가 도착하면 Consumer에게 전달된다. Pull 방식: Consumer가 필요할 때 메시지를 가져간다. 작성중…" /><meta property="og:description" content="Spring with RabbitMQ RabbitMQ에서 사용하는 AMQP 0-9-1 모델과 RabbitMQ의 컨셉을 정리하기 위해 작성하였다. Spring과의 자세한 매핑은 이후 글에서 작성할 예정 AMQP 0-9-1 Model High-level Overview of AMQP 0-9-1 and the AMQP Model What is AMQP 0-9-1? AMQP 0-9-1(Advanced Message Queueing Protocol)은 클라이언트 어플리케이션들이 미들웨어 메시지 브로커를 통해 통신할 수 있도록 하는 메시지 프로토콜을 의미한다. Brokers and Their Role 브로커(Broker)는 Publisher(생산자, 메시지를 브로커에게 전송하는 어플리케이션, Producer라고도 불리운다)에게 메시지를 수신하며, 이를 Consumer(소비자, 메시지를 브로커로부터 수신하여 처리하는 어플리케이션)에게 전달한다. AMQP-0-9-1은 메시지 프로토콜이기 때문에, Publisher, Broker, Consumer는 서로 다른 장비에서 동작할 수 있다. AMQP 0-9-1 Model in Brief AMQP-0-9-1 Model에는 위에서 설명한 Producer, Broker, Consumer 말고도 몇가지 개념이 더 존재한다. Enchange: Producer로부터 메시지를 수신하여 정해진 규칙(Binding)에 따라 Queue에 전달(복사)한다. Binding: Exchange와 Queue를 연결하는 규칙 Queue: 메시지를 소비하기 전 대기하는 논리적인 장소 메시지가 전달되는 과정은 아래와 같다. Producer는 Exchange에 메시지를 전달한다. Exchange는 메시지의 속성과 일치하는 Binding을 찾는다. 찾은 Binding에 연결된 Queue에 메시지를 복사한다. Consumer는 Pull 혹은 Push 방식으로 Queue에서 메시지를 수신/소비한다. Network는 완전히 신뢰할 수 없고 Consumer가 메시지를 처리하는 도중 Exception이 발생하여 메시지가 유실될 수 있기 때문에 AMQP Model은 Message Acknowledgement라는 개념이 존재한다. Broker는 메시지를 Consumer에게 전달했더라도 즉시 Queue에서 메시지를 삭제하지 않고, Consumer로부터 Acknowledge를 수신한 이후에 메시지를 삭제하게 된다. 즉, Consumer가 메시지를 처리하는 도중 Exception이 발생하여 Connection이 끊어지는 경우, 메시지는 유실되지 않고 다른 Consumer에 의해 처리될 수 있다. Acknowlege는 설정에 따라 Consumer로 메시지 수신 시 자동으로 Acknowledge를 Broker에게 전달 Consumer에서 수동으로(Programmitically) Acknowledge 처리 를 할 수 있다. AMQP’s Entities Exchange Exchange는 메시지를 전달하는 AMQP의 개체이다. Exchange는 메시지를 수신하여 이를 0개 이상의 Queue에 전달하는 역할을 담당한다. 메시지를 Routing하는 방식은 Exchange의 종류와 Binding이라고 불리는 Rule에 의해 결정된다. 아래는 AMQP 0-9-1의 Exchange 종류이다. Name Default pre-declared names Direct exchange (Empty string) and amq.direct Fanout exchange amq.fanout Topic exchange amq.topic Headers exchange amq.match (and amq.headers in RabbitMQ) 이와 별개로 Exchange는 몇가지 특성들을 포함하고 있다. Name: Exchange의 이름을 의미한다. Durability: Broker가 재시작해도 Exchange를 유지할지에 대한 Flag. Auto-delete: 모든 Queue가 Unbind 되었을 때 Exchange를 유지할지에 대한 Flag. Direct Exchange Direct Exchange는 메시지의 Routing Key를 이용해 Queue에게 메시지를 전달한다. Direct Exchange는 Unicast 방식으로 메시지를 전달할 때 유용하다.(물론 활용에 따라 Multicast 방식도 가능하다) Queue는 Routing Key ‘K’를 이용하여 Exchange에 Binding한다. 메시지가 Routing Key ‘R’과 함께 Exchange에 수신되었을 때, ‘K’와 ‘R’이 일치한다면 Exchange는 메시지를 해당 Queue에 전달한다. Direct Exchange는 여러 개의 Worker에게 작업을 분산할 때 주로 사용된다. 하나의 Exchange에 서로 다른 Routing Key를 가진 Queue 여러 개가 Binding 될 수 있다. Direct Exchange에 동일한 Routing Key를 가진 서로 다른 Queue가 Binding 된다면, 동일한 Routing Key를 가진 Queue 들에게는 Fanout 방식으로 메시지가 전달된다. Fanout Exchange Fanout Exchange는 Exchange에 Binding 된 모든 Queue에게 같은 메시지를 전달한다(Ignore Routing Key). 만일 N개의 Queue가 Exchange에 Binding 되어 있는 경우, 새 메시지가 Exchange에 발생한 경우 N개의 Queue에 새로운 메시지가 복사된다. Fanout Exchange는 메시지를 Broadcasting 할 때 유용하게 사용된다. Topic Exchange와 Header Exchange의 경우 현재 사용할 예정이 없기에 정리하지 않음. Queue AMQP 0-9-1 Model의 Queue는 다른 Queueing System에서의 Queue 개념과 거의 유사하다. Queue는 Consumer가 소비할 메시지들을 저장하고 있는 장소이다. Queue는 몇몇 Property를 Exchange와 공유한다. Name: Queue의 이름이다. Durable: Broker 재시작 후에도 Queue를 유지할지에 대한 Flag. Exclusive: Queue가 1개의 Connection만 허용하고, 해당 Connection이 끊긴다면 Queue를 유지할지에 대한 Flag. Auto-delete: Queue를 바라보던 Consumer 들이 모두 제거된 후 Queue를 유지할지에 대한 Flag. Queue Name 어플리케이션은 자신이 사용할 Queue 이름을 선택한 후 Broker에게 생성을 요청한다. Queue 이름은 255byte(UTF-8)까지 허용된다. 빈 문자열을 이용해 Queue 이름을 선언하여 생성을 요청하는 경우, Broker가 임의의 Unique한 Queue 이름을 생성한 뒤 Application에게 반환해준다. amq. Prefix를 가지는 Queue는 Broker 내부에서 사용되는 Queue 이름이기 때문에 생성 요청 시 403 코드를 포함한 오류가 발생하게 된다. Queue Durability Durable Queue는 Disk에 유지되며, Broker가 재시작 되어도 유지된다. Durable하지 않는 Queue는 Transient라고 불린다. 단, Queue가 Durable하다고 해서 그 안에 저장된 메시지까지 유지되는 것은 아니다. 브로커가 재시작된 이후에도 메시지를 유지하고 싶다면 메시지를 Persistent 타입으로 지정해야 한다. Binding Binding은 Exchange가 메시지를 Queue에게 전달하기 위한 규칙이다. 만일 메시지에 일치하는 Binding이 존재하지 않는 경우 메시지는 유실되거나 Publisher에게 반환된다. Consumer Consumer는 Queue에 저장된 메시지를 소비하는 어플리케이션이며, Push와 Pull 방식으로 동작할 수 있다. Push 방식: 메시지가 도착하면 Consumer에게 전달된다. Pull 방식: Consumer가 필요할 때 메시지를 가져간다. 작성중…" /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-rabbitmq-2/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-rabbitmq-2/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-12-30T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring with RabbitMQ(2)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Spring with RabbitMQ RabbitMQ에서 사용하는 AMQP 0-9-1 모델과 RabbitMQ의 컨셉을 정리하기 위해 작성하였다. Spring과의 자세한 매핑은 이후 글에서 작성할 예정 AMQP 0-9-1 Model High-level Overview of AMQP 0-9-1 and the AMQP Model What is AMQP 0-9-1? AMQP 0-9-1(Advanced Message Queueing Protocol)은 클라이언트 어플리케이션들이 미들웨어 메시지 브로커를 통해 통신할 수 있도록 하는 메시지 프로토콜을 의미한다. Brokers and Their Role 브로커(Broker)는 Publisher(생산자, 메시지를 브로커에게 전송하는 어플리케이션, Producer라고도 불리운다)에게 메시지를 수신하며, 이를 Consumer(소비자, 메시지를 브로커로부터 수신하여 처리하는 어플리케이션)에게 전달한다. AMQP-0-9-1은 메시지 프로토콜이기 때문에, Publisher, Broker, Consumer는 서로 다른 장비에서 동작할 수 있다. AMQP 0-9-1 Model in Brief AMQP-0-9-1 Model에는 위에서 설명한 Producer, Broker, Consumer 말고도 몇가지 개념이 더 존재한다. Enchange: Producer로부터 메시지를 수신하여 정해진 규칙(Binding)에 따라 Queue에 전달(복사)한다. Binding: Exchange와 Queue를 연결하는 규칙 Queue: 메시지를 소비하기 전 대기하는 논리적인 장소 메시지가 전달되는 과정은 아래와 같다. Producer는 Exchange에 메시지를 전달한다. Exchange는 메시지의 속성과 일치하는 Binding을 찾는다. 찾은 Binding에 연결된 Queue에 메시지를 복사한다. Consumer는 Pull 혹은 Push 방식으로 Queue에서 메시지를 수신/소비한다. Network는 완전히 신뢰할 수 없고 Consumer가 메시지를 처리하는 도중 Exception이 발생하여 메시지가 유실될 수 있기 때문에 AMQP Model은 Message Acknowledgement라는 개념이 존재한다. Broker는 메시지를 Consumer에게 전달했더라도 즉시 Queue에서 메시지를 삭제하지 않고, Consumer로부터 Acknowledge를 수신한 이후에 메시지를 삭제하게 된다. 즉, Consumer가 메시지를 처리하는 도중 Exception이 발생하여 Connection이 끊어지는 경우, 메시지는 유실되지 않고 다른 Consumer에 의해 처리될 수 있다. Acknowlege는 설정에 따라 Consumer로 메시지 수신 시 자동으로 Acknowledge를 Broker에게 전달 Consumer에서 수동으로(Programmitically) Acknowledge 처리 를 할 수 있다. AMQP’s Entities Exchange Exchange는 메시지를 전달하는 AMQP의 개체이다. Exchange는 메시지를 수신하여 이를 0개 이상의 Queue에 전달하는 역할을 담당한다. 메시지를 Routing하는 방식은 Exchange의 종류와 Binding이라고 불리는 Rule에 의해 결정된다. 아래는 AMQP 0-9-1의 Exchange 종류이다. Name Default pre-declared names Direct exchange (Empty string) and amq.direct Fanout exchange amq.fanout Topic exchange amq.topic Headers exchange amq.match (and amq.headers in RabbitMQ) 이와 별개로 Exchange는 몇가지 특성들을 포함하고 있다. Name: Exchange의 이름을 의미한다. Durability: Broker가 재시작해도 Exchange를 유지할지에 대한 Flag. Auto-delete: 모든 Queue가 Unbind 되었을 때 Exchange를 유지할지에 대한 Flag. Direct Exchange Direct Exchange는 메시지의 Routing Key를 이용해 Queue에게 메시지를 전달한다. Direct Exchange는 Unicast 방식으로 메시지를 전달할 때 유용하다.(물론 활용에 따라 Multicast 방식도 가능하다) Queue는 Routing Key ‘K’를 이용하여 Exchange에 Binding한다. 메시지가 Routing Key ‘R’과 함께 Exchange에 수신되었을 때, ‘K’와 ‘R’이 일치한다면 Exchange는 메시지를 해당 Queue에 전달한다. Direct Exchange는 여러 개의 Worker에게 작업을 분산할 때 주로 사용된다. 하나의 Exchange에 서로 다른 Routing Key를 가진 Queue 여러 개가 Binding 될 수 있다. Direct Exchange에 동일한 Routing Key를 가진 서로 다른 Queue가 Binding 된다면, 동일한 Routing Key를 가진 Queue 들에게는 Fanout 방식으로 메시지가 전달된다. Fanout Exchange Fanout Exchange는 Exchange에 Binding 된 모든 Queue에게 같은 메시지를 전달한다(Ignore Routing Key). 만일 N개의 Queue가 Exchange에 Binding 되어 있는 경우, 새 메시지가 Exchange에 발생한 경우 N개의 Queue에 새로운 메시지가 복사된다. Fanout Exchange는 메시지를 Broadcasting 할 때 유용하게 사용된다. Topic Exchange와 Header Exchange의 경우 현재 사용할 예정이 없기에 정리하지 않음. Queue AMQP 0-9-1 Model의 Queue는 다른 Queueing System에서의 Queue 개념과 거의 유사하다. Queue는 Consumer가 소비할 메시지들을 저장하고 있는 장소이다. Queue는 몇몇 Property를 Exchange와 공유한다. Name: Queue의 이름이다. Durable: Broker 재시작 후에도 Queue를 유지할지에 대한 Flag. Exclusive: Queue가 1개의 Connection만 허용하고, 해당 Connection이 끊긴다면 Queue를 유지할지에 대한 Flag. Auto-delete: Queue를 바라보던 Consumer 들이 모두 제거된 후 Queue를 유지할지에 대한 Flag. Queue Name 어플리케이션은 자신이 사용할 Queue 이름을 선택한 후 Broker에게 생성을 요청한다. Queue 이름은 255byte(UTF-8)까지 허용된다. 빈 문자열을 이용해 Queue 이름을 선언하여 생성을 요청하는 경우, Broker가 임의의 Unique한 Queue 이름을 생성한 뒤 Application에게 반환해준다. amq. Prefix를 가지는 Queue는 Broker 내부에서 사용되는 Queue 이름이기 때문에 생성 요청 시 403 코드를 포함한 오류가 발생하게 된다. Queue Durability Durable Queue는 Disk에 유지되며, Broker가 재시작 되어도 유지된다. Durable하지 않는 Queue는 Transient라고 불린다. 단, Queue가 Durable하다고 해서 그 안에 저장된 메시지까지 유지되는 것은 아니다. 브로커가 재시작된 이후에도 메시지를 유지하고 싶다면 메시지를 Persistent 타입으로 지정해야 한다. Binding Binding은 Exchange가 메시지를 Queue에게 전달하기 위한 규칙이다. 만일 메시지에 일치하는 Binding이 존재하지 않는 경우 메시지는 유실되거나 Publisher에게 반환된다. Consumer Consumer는 Queue에 저장된 메시지를 소비하는 어플리케이션이며, Push와 Pull 방식으로 동작할 수 있다. Push 방식: 메시지가 도착하면 Consumer에게 전달된다. Pull 방식: Consumer가 필요할 때 메시지를 가져간다. 작성중…","url":"https://leeyh0216.github.io/posts/spring-rabbitmq-2/","@type":"BlogPosting","headline":"Spring with RabbitMQ(2)","dateModified":"2018-12-30T10:00:00+09:00","datePublished":"2018-12-30T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-rabbitmq-2/"},"@context":"https://schema.org"}</script><title>Spring with RabbitMQ(2) | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring with RabbitMQ(2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring with RabbitMQ(2)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Dec 30, 2018, 10:00 AM +0900" prep="on" > Dec 30, 2018 <i class="unloaded">2018-12-30T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1707 words">9 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="spring-with-rabbitmq">Spring with RabbitMQ</h1><blockquote><p>RabbitMQ에서 사용하는 <code class="language-plaintext highlighter-rouge">AMQP 0-9-1</code> 모델과 RabbitMQ의 컨셉을 정리하기 위해 작성하였다. Spring과의 자세한 매핑은 이후 글에서 작성할 예정</p></blockquote><h2 id="amqp-0-9-1-model">AMQP 0-9-1 Model</h2><h3 id="high-level-overview-of-amqp-0-9-1-and-the-amqp-model">High-level Overview of AMQP 0-9-1 and the AMQP Model</h3><h4 id="what-is-amqp-0-9-1">What is AMQP 0-9-1?</h4><p>AMQP 0-9-1(Advanced Message Queueing Protocol)은 클라이언트 어플리케이션들이 미들웨어 메시지 브로커를 통해 통신할 수 있도록 하는 메시지 프로토콜을 의미한다.</p><h4 id="brokers-and-their-role">Brokers and Their Role</h4><p>브로커(Broker)는 Publisher(생산자, 메시지를 브로커에게 전송하는 어플리케이션, Producer라고도 불리운다)에게 메시지를 수신하며, 이를 Consumer(소비자, 메시지를 브로커로부터 수신하여 처리하는 어플리케이션)에게 전달한다.</p><p>AMQP-0-9-1은 메시지 프로토콜이기 때문에, Publisher, Broker, Consumer는 서로 다른 장비에서 동작할 수 있다.</p><h4 id="amqp-0-9-1-model-in-brief">AMQP 0-9-1 Model in Brief</h4><p>AMQP-0-9-1 Model에는 위에서 설명한 Producer, Broker, Consumer 말고도 몇가지 개념이 더 존재한다.</p><ul><li>Enchange: Producer로부터 메시지를 수신하여 정해진 규칙(Binding)에 따라 Queue에 전달(복사)한다.<li>Binding: Exchange와 Queue를 연결하는 규칙<li>Queue: 메시지를 소비하기 전 대기하는 논리적인 장소</ul><p>메시지가 전달되는 과정은 아래와 같다.</p><ol><li>Producer는 Exchange에 메시지를 전달한다.<li>Exchange는 메시지의 속성과 일치하는 Binding을 찾는다.<li>찾은 Binding에 연결된 Queue에 메시지를 복사한다.<li>Consumer는 Pull 혹은 Push 방식으로 Queue에서 메시지를 수신/소비한다.</ol><p>Network는 완전히 신뢰할 수 없고 Consumer가 메시지를 처리하는 도중 Exception이 발생하여 메시지가 유실될 수 있기 때문에 AMQP Model은 Message Acknowledgement라는 개념이 존재한다.</p><p>Broker는 메시지를 Consumer에게 전달했더라도 즉시 Queue에서 메시지를 삭제하지 않고, Consumer로부터 Acknowledge를 수신한 이후에 메시지를 삭제하게 된다.</p><p>즉, Consumer가 메시지를 처리하는 도중 Exception이 발생하여 Connection이 끊어지는 경우, 메시지는 유실되지 않고 다른 Consumer에 의해 처리될 수 있다.</p><p>Acknowlege는 설정에 따라</p><ul><li>Consumer로 메시지 수신 시 자동으로 Acknowledge를 Broker에게 전달<li>Consumer에서 수동으로(Programmitically) Acknowledge 처리 를 할 수 있다.</ul><h3 id="amqps-entities">AMQP’s Entities</h3><h4 id="exchange">Exchange</h4><p>Exchange는 메시지를 전달하는 AMQP의 개체이다. Exchange는 메시지를 수신하여 이를 0개 이상의 Queue에 전달하는 역할을 담당한다. 메시지를 Routing하는 방식은 Exchange의 종류와 Binding이라고 불리는 Rule에 의해 결정된다. 아래는 AMQP 0-9-1의 Exchange 종류이다.</p><div class="table-wrapper"><table><thead><tr><th>Name<th>Default pre-declared names<tbody><tr><td>Direct exchange<td>(Empty string) and amq.direct<tr><td>Fanout exchange<td>amq.fanout<tr><td>Topic exchange<td>amq.topic<tr><td>Headers exchange<td>amq.match (and amq.headers in RabbitMQ)</table></div><p>이와 별개로 Exchange는 몇가지 특성들을 포함하고 있다.</p><ul><li>Name: Exchange의 이름을 의미한다.<li>Durability: Broker가 재시작해도 Exchange를 유지할지에 대한 Flag.<li>Auto-delete: 모든 Queue가 Unbind 되었을 때 Exchange를 유지할지에 대한 Flag.</ul><h5 id="direct-exchange">Direct Exchange</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/spring/direct-exchange.jpg" alt="Direct Exchange" /></p><p>Direct Exchange는 메시지의 Routing Key를 이용해 Queue에게 메시지를 전달한다. Direct Exchange는 Unicast 방식으로 메시지를 전달할 때 유용하다.(물론 활용에 따라 Multicast 방식도 가능하다)</p><ul><li>Queue는 Routing Key ‘K’를 이용하여 Exchange에 Binding한다.<li>메시지가 Routing Key ‘R’과 함께 Exchange에 수신되었을 때, ‘K’와 ‘R’이 일치한다면 Exchange는 메시지를 해당 Queue에 전달한다.</ul><p>Direct Exchange는 여러 개의 Worker에게 작업을 분산할 때 주로 사용된다.</p><blockquote><p>하나의 Exchange에 서로 다른 Routing Key를 가진 Queue 여러 개가 Binding 될 수 있다. Direct Exchange에 동일한 Routing Key를 가진 서로 다른 Queue가 Binding 된다면, 동일한 Routing Key를 가진 Queue 들에게는 Fanout 방식으로 메시지가 전달된다.</p></blockquote><h5 id="fanout-exchange">Fanout Exchange</h5><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/spring/fanout-exchange.jpg" alt="Fanout Exchange" /></p><p>Fanout Exchange는 Exchange에 Binding 된 모든 Queue에게 같은 메시지를 전달한다(Ignore Routing Key). 만일 N개의 Queue가 Exchange에 Binding 되어 있는 경우, 새 메시지가 Exchange에 발생한 경우 N개의 Queue에 새로운 메시지가 복사된다.</p><p>Fanout Exchange는 메시지를 Broadcasting 할 때 유용하게 사용된다.</p><blockquote><p>Topic Exchange와 Header Exchange의 경우 현재 사용할 예정이 없기에 정리하지 않음.</p></blockquote><h4 id="queue">Queue</h4><p>AMQP 0-9-1 Model의 Queue는 다른 Queueing System에서의 Queue 개념과 거의 유사하다. Queue는 Consumer가 소비할 메시지들을 저장하고 있는 장소이다. Queue는 몇몇 Property를 Exchange와 공유한다.</p><ul><li>Name: Queue의 이름이다.<li>Durable: Broker 재시작 후에도 Queue를 유지할지에 대한 Flag.<li>Exclusive: Queue가 1개의 Connection만 허용하고, 해당 Connection이 끊긴다면 Queue를 유지할지에 대한 Flag.<li>Auto-delete: Queue를 바라보던 Consumer 들이 모두 제거된 후 Queue를 유지할지에 대한 Flag.</ul><h5 id="queue-name">Queue Name</h5><p>어플리케이션은 자신이 사용할 Queue 이름을 선택한 후 Broker에게 생성을 요청한다. Queue 이름은 255byte(UTF-8)까지 허용된다. 빈 문자열을 이용해 Queue 이름을 선언하여 생성을 요청하는 경우, Broker가 임의의 Unique한 Queue 이름을 생성한 뒤 Application에게 반환해준다.</p><blockquote><p>amq. Prefix를 가지는 Queue는 Broker 내부에서 사용되는 Queue 이름이기 때문에 생성 요청 시 403 코드를 포함한 오류가 발생하게 된다.</p></blockquote><h5 id="queue-durability">Queue Durability</h5><p>Durable Queue는 Disk에 유지되며, Broker가 재시작 되어도 유지된다. Durable하지 않는 Queue는 Transient라고 불린다.</p><p>단, Queue가 Durable하다고 해서 그 안에 저장된 메시지까지 유지되는 것은 아니다. 브로커가 재시작된 이후에도 메시지를 유지하고 싶다면 메시지를 Persistent 타입으로 지정해야 한다.</p><h4 id="binding">Binding</h4><p>Binding은 Exchange가 메시지를 Queue에게 전달하기 위한 규칙이다. 만일 메시지에 일치하는 Binding이 존재하지 않는 경우 메시지는 유실되거나 Publisher에게 반환된다.</p><h4 id="consumer">Consumer</h4><p>Consumer는 Queue에 저장된 메시지를 소비하는 어플리케이션이며, Push와 Pull 방식으로 동작할 수 있다.</p><ul><li>Push 방식: 메시지가 도착하면 Consumer에게 <strong>전달</strong>된다.<li>Pull 방식: Consumer가 필요할 때 메시지를 <strong>가져</strong>간다.</ul><p>작성중…</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a> <a href="/tags/rabbitmq/" class="post-tag no-text-decoration" >rabbitmq</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring with RabbitMQ(2) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-rabbitmq-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring with RabbitMQ(2) - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-rabbitmq-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring with RabbitMQ(2) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-rabbitmq-2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-rabbitmq-1/"><div class="card-body"> <span class="timeago small" > Dec 30, 2018 <i class="unloaded">2018-12-30T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring with RabbitMQ(1)</h3><div class="text-muted small"><p> Spring with RabbitMQ Pre Requirements RabbitMQ 3.6 RabbitMQ 설치(Docker) RabbitMQ를 물리 서버에 설치하기 위해서는 Erlang 설치를 선행한 후 RabbitMQ를 설치해야 하지만 테스트 용도이기 때문에 Docker로 설치 진행한다. Docker Hub의 RabbitMQ 페이지...</p></div></div></a></div><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-rabbitmq-1/" class="btn btn-outline-primary" prompt="Older"><p>Spring with RabbitMQ(1)</p></a> <a href="/posts/spring-bean-scopes/" class="btn btn-outline-primary" prompt="Newer"><p>Spring Core Technologies - Bean Scopes</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
