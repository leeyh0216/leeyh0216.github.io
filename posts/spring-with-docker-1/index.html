<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring + MongoDB + Docker 조합 사용 테스트" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. 1 2 3 ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. 1 {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. 1 docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. 1 docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. 1 2 3 4 xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. 1 2 3 Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. 1 docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. 1 docker network ls 1 2 3 4 5 6 7 NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. 1 2 docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. 1 docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 1 docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 1 2 3 4 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. 1 2 curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. 1 2 3 curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. 1 2 curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다." /><meta property="og:description" content="프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. 1 2 3 ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. 1 {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. 1 docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. 1 docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. 1 2 3 4 xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. 1 2 3 Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. 1 docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. 1 docker network ls 1 2 3 4 5 6 7 NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. 1 2 docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. 1 docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 1 docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 1 2 3 4 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. 1 2 curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. 1 2 3 curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. 1 2 curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-with-docker-1/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-with-docker-1/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-05-06T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring + MongoDB + Docker 조합 사용 테스트" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. 1 2 3 ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. 1 {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. 1 docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. 1 docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. 1 2 3 4 xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. 1 2 3 Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. 1 docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. 1 docker network ls 1 2 3 4 5 6 7 NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. 1 2 docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. 1 docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 1 2 3 4 5 6 7 8 9 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 1 docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 1 2 3 4 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. 1 2 curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. 1 2 3 curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. 1 2 curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다.","url":"https://leeyh0216.github.io/posts/spring-with-docker-1/","@type":"BlogPosting","headline":"Spring + MongoDB + Docker 조합 사용 테스트","dateModified":"2019-05-06T10:00:00+09:00","datePublished":"2019-05-06T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-with-docker-1/"},"@context":"https://schema.org"}</script><title>Spring + MongoDB + Docker 조합 사용 테스트 | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring + MongoDB + Docker 조합 사용 테스트</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring + MongoDB + Docker 조합 사용 테스트</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, May 6, 2019, 10:00 AM +0900" prep="on" > May 6, 2019 <i class="unloaded">2019-05-06T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2115 words">11 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="프로젝트-초기화">프로젝트 초기화</h1><h2 id="git-초기화">git 초기화</h2><ol><li><p>Git 페이지에서 <a href="https://github.com/leeyh0216/spring_mongodb_docker">spring_mongodb_docker</a> Repository를 초기화한다.</p><li><p><code class="language-plaintext highlighter-rouge">git pull https://github.com/leeyh0216/spring_mongodb_docker.git</code> 명령어를 통해 로컬로 Clone 한다.</p><li><p><a href="https://gitignore.io">gitignore.io</a> 페이지에서 gradle, java, intellij로 초기화한 <code class="language-plaintext highlighter-rouge">.gitignore</code>을 디렉토리에 추가한다.</p></ol><h2 id="spring-project-초기화">Spring Project 초기화</h2><ol><li><p>최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다.</p><li><p>spring-boot-test에서 <code class="language-plaintext highlighter-rouge">gradle init</code> 명령어로 gradle 프로젝트를 초기화한다.</p><li><p>build.gradle을 아래와 같이 작성한다.<a href="https://spring.io/guides/gs/spring-boot/">Spring Boot Guide 페이지 참고</a></p></ol><figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">buildscript</span> <span class="o">{</span>
    <span class="n">repositories</span> <span class="o">{</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="n">dependencies</span> <span class="o">{</span>
        <span class="n">classpath</span><span class="o">(</span><span class="s2">"org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'java'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'idea'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'org.springframework.boot'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'io.spring.dependency-management'</span>

<span class="n">repositories</span> <span class="o">{</span>
    <span class="n">mavenCentral</span><span class="o">()</span>
<span class="o">}</span>

<span class="n">sourceCompatibility</span> <span class="o">=</span> <span class="mf">1.8</span>
<span class="n">targetCompatibility</span> <span class="o">=</span> <span class="mf">1.8</span>

<span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span><span class="o">(</span><span class="s2">"org.springframework.boot:spring-boot-starter-web"</span><span class="o">)</span>
    <span class="n">testCompile</span><span class="o">(</span><span class="s2">"junit:junit"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure><h1 id="spring-application-코드-작성">Spring Application 코드 작성</h1><h2 id="hello-world">Hello World!</h2><p>간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleServer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SampleServer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"Hello World"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다.</p><h2 id="spring-boot-data-mongodb-starter-dependency-추가">Spring Boot Data MongoDB Starter Dependency 추가</h2><p>Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다.</p><p><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-mongodb">Maven Repository: Spring Boot Data MongoDB Starter</a> 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다.</p><h2 id="crud-service-controller-entitry-객체-클래스-구현">CRUD Service, Controller, Entitry 객체 클래스 구현</h2><p>아래와 같이 간단한 CRUD 서비스를 구현한다.</p><h3 id="personjava">Person.java</h3><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.test.crud</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>

    <span class="c1">//Getter, Setter 생략
</span>
<span class="o">}</span></code></pre></figure><h3 id="crudservicejava">CRUDService.java</h3><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.test.crud</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.data.mongodb.core.MongoTemplate</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CRUDService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MongoTemplate</span> <span class="n">mongoTemplate</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CRUDService</span><span class="o">(</span><span class="nc">MongoTemplate</span> <span class="n">mongoTemplate</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mongoTemplate</span> <span class="o">=</span> <span class="n">mongoTemplate</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Person</span> <span class="nf">createPerson</span><span class="o">(</span><span class="nc">Person</span> <span class="n">person</span><span class="o">){</span>
        <span class="n">mongoTemplate</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">person</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="nf">getPeople</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">mongoTemplate</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h3 id="crudcontrollerjava">CRUDController.java</h3><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.test.crud</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/person"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CRUDController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">CRUDService</span> <span class="n">crudService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CRUDController</span><span class="o">(</span><span class="nc">CRUDService</span> <span class="n">crudService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">crudService</span> <span class="o">=</span> <span class="n">crudService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Person</span> <span class="nf">createPerson</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">Person</span> <span class="n">person</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">crudService</span><span class="o">.</span><span class="na">createPerson</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="nf">getPeoples</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">crudService</span><span class="o">.</span><span class="na">getPeople</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h2 id="dockerfile-작성">Dockerfile 작성</h2><p>프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">FROM openjdk:8-jre-alpine

RUN <span class="nb">mkdir</span> <span class="nt">-p</span> /data/spring-boot-test
COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/

ENTRYPOINT <span class="o">[</span><span class="s2">"java"</span>, <span class="s2">"-jar"</span>, <span class="s2">"/data/spring-boot-test/spring-boot-test.jar"</span><span class="o">]</span>
EXPOSE 8080</code></pre></figure><h2 id="docker-이미지-빌드-및-실행">Docker 이미지 빌드 및 실행</h2><p>Spring 프로젝트 디렉토리에서 <code class="language-plaintext highlighter-rouge">docker build --tag spring-boot-test:0.1 .</code> 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다.</p><p>이후 <code class="language-plaintext highlighter-rouge">docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1</code> 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다.</p><p>http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다.</p><h2 id="docker-swarm-의-서비스로-실행하기">Docker Swarm 의 서비스로 실행하기</h2><p>spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자.</p><p>사실상 위의 명령어와 별다를게 없다. <code class="language-plaintext highlighter-rouge">docker run -d</code> 명령어만 <code class="language-plaintext highlighter-rouge">docker service create</code> 명령어로 바꾸어주면 된다.</p><p><code class="language-plaintext highlighter-rouge">docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1</code> 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>image spring-boot-test:0.1 could not be accessed on a registry to record
its digest. Each node will access spring-boot-test:0.1 independently,
possibly leading to different nodes running different
versions of the image.

cri8td3bfy6d3z8u342dr3ju3
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">docker service ls</code> 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>ID                  NAME                MODE                REPLICAS            IMAGE                  PORTS
i78wqngny6hp        apacheserver        replicated          1/1                 apache2:0.1            *:81-&gt;80/tcp
cri8td3bfy6d        spring-boot-test    replicated          1/1                 spring-boot-test:0.1   *:8080-&gt;8080/tcp
</pre></table></code></div></div><h1 id="mongodb-service">MongoDB Service</h1><p>위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>{"timestamp":"2019-05-06T04:24:20.077+0000","status":500,"error":"Internal Server Error","message":"Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]","path":"/person"}
</pre></table></code></div></div><p>이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다.</p><h2 id="mongodb-instance를-docker-service로-실행">Mongodb Instance를 Docker Service로 실행</h2><p><a href="https://hub.docker.com/_/mongo">DockerHub: Mongo</a> 페이지를 참고하여 Docker Image를 Pull 한다.</p><p>3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker pull 3.6
</pre></table></code></div></div><p>아래와 같이 Image가 Pull 되는 것을 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>3.6: Pulling from library/mongo
7e6591854262: Pull complete
089d60cb4e0a: Pull complete
9c461696bc09: Pull complete
45085432511a: Pull complete
e5182dfcfa20: Pull complete
ccb099326ee3: Pull complete
75804f28c4b1: Pull complete
765a10b214be: Pull complete
36cbec4a23a5: Pull complete
8d7c112fee50: Pull complete
22a72bf1a592: Pull complete
7c24e128abe6: Pull complete
44337c6f0bee: Pull complete
Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc
Status: Downloaded newer image for mongo:3.6
</pre></table></code></div></div><p>위의 이미지를 Docker Service로 실행시킨다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker service create --name mongodb -p 27017:27017 mongo:3.6
</pre></table></code></div></div><p>아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>xnrho4emt1cwem3fsyiadd3yb
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre></table></code></div></div><p>telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</pre></table></code></div></div><p>그러나 <code class="language-plaintext highlighter-rouge">docker service log spring-boot-test</code> 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | 2019-05-06 04:31:10.649  INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster               : Exception in monitor thread while connecting to server mongodb:27017
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | com.mongodb.MongoSocketException: mongodb
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | Caused by: java.net.UnknownHostException: mongodb
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      ... 5 common frames omitted
</pre></table></code></div></div><h1 id="docker-overlay-network-구성">Docker Overlay Network 구성</h1><p>위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다.</p><p>이를 찾을 수 있는 방법은 2가지가 있다.</p><ol><li><p>spring-boot-test의 <code class="language-plaintext highlighter-rouge">application.properties</code> 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법</p><li><p>Docker의 Overlay Network를 이용하는 방법</p></ol><p>여기서는 Docker의 Overlay Network를 이용해 보도록 한다.</p><h2 id="overlay-network-생성">Overlay Network 생성</h2><p>아래 명령어를 이용하여 <code class="language-plaintext highlighter-rouge">backend</code>라는 이름의 Docker Overlay Network를 생성한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker network create --attachable --driver overlay backend
</pre></table></code></div></div><p>아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker network ls
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>NETWORK ID          NAME                DRIVER              SCOPE
7p056vdum6up        backend             overlay             swarm
df830a7a0306        bridge              bridge              local
054011e7ede2        docker_gwbridge     bridge              local
c2fb0615051d        host                host                local
j39apemc19b0        ingress             overlay             swarm
1d10ebc33b36        none                null                local
</pre></table></code></div></div><p>위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다.</p><h2 id="service를-overlay-network에-연결">Service를 Overlay Network에 연결</h2><p>일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>docker service rm spring-boot-test
docker service rm mongodb
</pre></table></code></div></div><p>새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 <code class="language-plaintext highlighter-rouge">--network backend</code> 옵션을 주고 실행한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>image spring-boot-test:0.1 could not be accessed on a registry to record
its digest. Each node will access spring-boot-test:0.1 independently,
possibly leading to different nodes running different
versions of the image.

olcbruuu5jutlqg6vofqpzslz
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>z5z3crpdcy416mco2bpawwnbr
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre></table></code></div></div><h2 id="테스트">테스트</h2><p>spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자.</p><p>일단 http://localhost:8080/person 을 조회해보자.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>curl http://localhost:8080/person
[]
</pre></table></code></div></div><p>위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다.</p><p>이제 person을 생성해보도록 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>curl -XPOST -H "Content-Type: application/json" -d '{"name":"leeyh0216","age":28}' http://localhost:8080/person

{"id":"","name":"leeyh0216","age":28}
</pre></table></code></div></div><p>생성된 Person이 반환되는 것을 확인할 수 있다.</p><p>이제 person 목록을 조회해보도록 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>curl http://localhost:8080
[{"id":"","name":"leeyh0216","age":28}]
</pre></table></code></div></div><p>JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다.</p><h1 id="결론">결론</h1><p>Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다.</p><p>물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/docker/" class="post-tag no-text-decoration" >docker</a> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring + MongoDB + Docker 조합 사용 테스트 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-with-docker-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring + MongoDB + Docker 조합 사용 테스트 - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-with-docker-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring + MongoDB + Docker 조합 사용 테스트 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-with-docker-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-core-4/"><div class="card-body"> <span class="timeago small" > Dec 23, 2018 <i class="unloaded">2018-12-23T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(4)</h3><div class="text-muted small"><p> The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/annotation-based-container-configuration/" class="btn btn-outline-primary" prompt="Older"><p>Spring Core Technologies - Annotation-based container configuration(1)</p></a> <a href="/posts/spring-core-1/" class="btn btn-outline-primary" prompt="Newer"><p>Spring IoC Container - Container, Bean overview</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
