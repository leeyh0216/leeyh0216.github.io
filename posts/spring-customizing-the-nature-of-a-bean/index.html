<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - Customizing the nature of a bean" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Customizing the nature of a bean Lifecycle callbacks Spring에서 제공하는 InitializingBean 혹은 DisposableBean 인터페이스를 구현한다면, Bean의 Lifecycle을 Container에게 위임할 수 있다. Container는 Bean 생성 과정에서는 afterPropertiesSet 함수를 호출하고 Bean의 소멸 과정에서는 destroy 함수를 호출한다. InitializingBean과 DisposableBean은 Spring Framework에서 제공하는 Interface이기 때문에, 해당 Interface를 구현한 코드들은 모두 Spring과 Coupling되는 문제를 가지고 있다. 만일 Spring Framework와의 의존 관계를 없애고 싶을 경우 JSR-250에 정의된 @PostConstruct, @PreDestroy를 사용하거나, init-method, destroy-method를 메타데이터에서 지정해주는 것이 좋다. 그러나 과연 위의 가이드라인을 따른다고 해서 완전히 Spring Framework에 Independent 한 코드를 짤 수 있을지, 그리고 이러한 코드를 재활용할 수 있을지에 대해서는 의문이 든다. Spring Framework에서는 BeanPostProcessor 구현체가 Bean 초기화/소멸 과정에서 이러한 함수들을 찾아 적절히 실행시킨다. 만일 이러한 과정을 변경하고 싶다면, BeanPostProcessor를 스스로 구현해야 한다. 추가적으로 Bean의 Lifecycle을 Container의 Lifecycle에 연결하고 싶은 경우, Lifecycle Callback을 구현하면 된다. Initialization callbacks org.springframework.beans.factory.InitializingBean 인터페이스를 구현하게 되면, Container에 의해 Bean에 필요한 모든 속성(Properties 혹은 Dependencies)을 주입받은 이후 Container에 의해 afterPropertiesSet 함수가 호출된다. 단, InitializingBean 인터페이스는 Spring과 Coupling되는 이슈가 존재하기 때문에 @PostConstruct를 사용하거나 Configuration 메타데이터에 init-method를 명시해주는 것이 좋다. InitializingBean을 활용하는 방법 package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class InitializingBeanService implements InitializingBean { public InitializingBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @Override public void afterPropertiesSet() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 위와 같은 코드를 가진 Application을 실행하는 경우, 아래와 같은 출력이 발생한다. InitializingBeanService&#39;s constructor called Set MyRepository Called InitializingBeanService&#39;s init method called Container가 생성자 -&gt; Setter -&gt; 초기화 메서드 순으로 실행하는 것을 확인할 수 있다. Init-Method 를 활용하는 방법 위의 코드에서 InitializingBean 인터페이스를 제거하고, 해당 인터페이스에서 구현해야 할 함수인 afterPropertiesSet 함수를 initThis 라는 순수한 함수로 변경하였다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 다만, Container가 해당 클래스를 Bean으로 만들 때 호출해야 할 init-method를 인지할 수 있도록 Configuration 클래스에서 Bean Annotation 속성에 initMethod를 기재해주어야 한다. package com.leeyh0216.springstudy.initmethod; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.initmethod&quot;) public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean(initMethod=&quot;initThis&quot;) public InitMethodBeanService getInitializingBeanService(){ return new InitMethodBeanService(); } } 개인적으로 위와 같은 방식은 선호하지 않는다. 언제든 오타를 낼 수 있기에 initMethod에 잘못된 이름(혹은 오타가 발생)이 적히는 경우 Compile Time에 잡아낼 수 없기 때문이다(물론 테스트를 넣으면 당연히 잡을 수 있겠지만..). @PostConstruct 를 활용하는 방법 단순히 Bean이 생성된 후 호출될 함수에 @PostConstruct 어노테이션만 붙여주면 된다. package com.leeyh0216.springstudy.postconstruct; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class PostConstructBeanService { public PostConstructBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @PostConstruct public void postConstructMethod() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } Callback 메서드의 인자와 반환 Spring Framework 문서를 보면 아래와 같은 표현이 등장한다. In the case of XML-based configuration metadata, you use the init-method attribute to specify the name of the method that has a void no-argument signature. 즉, init-method는 인자가 없는 형태의 함수여야 한다는 것이다. 그래서 아래와 같이 인자를 주고 실행해 보았다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis(int a) throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 그랬더니 아래와 같이 오류가 발생한다. Caused by: org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&#39;t find an init method named &#39;initThis&#39; on bean with name &#39;getInitializingBeanService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1716) ... 그럼 인자가 아니라 반환형이 있을 경우는 어떨까? 그런 경우도 테스트 해보았는데 정상적으로 동작하는 것을 확인하였다. 동일한 내용을 @PostConstruct에도 적용해보았는데, 좀 더 디테일한 오류 메시지가 발생한다. Caused by: java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public java.lang.String com.leeyh0216.springstudy.postconstruct.PostConstructBeanService.postConstructMethod(int) throws java.lang.Exception at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.&lt;init&gt;(InitDestroyAnnotationBeanPostProcessor.java:349) ... 반환값을 지정하는 경우에는 오류가 발생하지 않고 잘 실행되었지만, 어차피 반환형을 사용하는 곳이 없기 때문에 Spring 문서에서 말했던 것과 같이 인자가 없는 함수 형태로만 정의해서 사용해야겠다. Destruction callbacks Destruction callback에서는 DisposableBean 인터페이스 구현 @PreDestroy 어노테이션 destroy-method 지정 방식을 제공하고 있다. 위의 내용은 Initialization callback과 동일한 방식으로 구현하기 때문에 별도로 코드를 첨부하지는 않는다. 다만 아래와 같은 3가지 특이사항/주의사항이 존재한다. Java에서 제공하는 리소스 해제 인터페이스 호출 Java에서는 객체가 가지고 있는 리소스를 해제할 수 있도록 강제하는 인터페이스인 java.lang.AutoClosable과 java.io.Closable 을 제공한다.(java.io.Closable은 Java 1.5, java.lang.AutoClosable은 Java 1.7에 도입된 인터페이스이며, java.io.Closable은 java.lang.AutoClosable을 상속하므로써 Backward-Compatibility를 보장한다.) 만일 Bean에 위 2개 인터페이스 중 하나라도 구현되어 있다면 해당 인터페이스의 함수들을 호출하게 된다. 위의 인터페이스들은 try-with-resource 구문과 사용도 가능하기 때문에, 별도로 구현하는 것보다는 위 인터페이스를 사용하는 것이 좋지 않을까 생각한다. Non-Web Application에서는 ApplicationContext의 registerShutdownhook()을 호출해야 한다. Non-Web Application(주로 Pure Java Application)에서는 Container에서 Application의 종료 시점을 알 수 없으므로, registerShutdownhook 함수를 호출하여 현 JVM의 Shutdown Event를 확인할 수 있도록 해야 한다. ApplicationContext의 registerShutdownhook은 내부적으로 Runtime의 addShutdownHook을 호출하여 Application 종료 이벤트를 수신한다. /** * Register a shutdown hook with the JVM runtime, closing this context * on JVM shutdown unless it has already been closed at that time. * &lt;p&gt;Delegates to {@code doClose()} for the actual closing procedure. * @see Runtime#addShutdownHook * @see #close() * @see #doClose() */ @Override public void registerShutdownHook() { if (this.shutdownHook == null) { // No shutdown hook registered yet. this.shutdownHook = new Thread() { @Override public void run() { synchronized (startupShutdownMonitor) { doClose(); } } }; Runtime.getRuntime().addShutdownHook(this.shutdownHook); } } finalize는 사용하지 말자 이 부분은 Effective Java에 나오는 내용인데, Java의 Object 객체에는 finalize라는 함수를 오버라이딩 할 수 있게 되어 있다. JavaDoc에는 아래와 같이 기술되어 있다. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. 그러나 실제로 해당 함수가 언제 호출될 지 알 수 없기때문에, 해당 함수의 사용을 권하지 않는다고 되어 있다. Combining lifecycle mechanisms Spring 2.5 버전부터 InitializingBean, DisposableBean Custom init, destroy methods @PostConstruct, @PreDestroy 등 Bean의 생애주기를 컨트롤 할 수 있는 방법이 제공된다. 위 메소드들은 아래와 같은 순서로 호출된다. @PostConstruct Annotation이 붙은 메서드 InitializingBean을 상속받았을 때 구현하는 afterPropertiesSet 메서드 커스텀 초기화 메서드 @PreDestroy Annotation이 붙은 메스더 DisposableBean을 상속받았을 때 구현하는 destroy() 메서드 커스텀 소멸 메서드" /><meta property="og:description" content="Customizing the nature of a bean Lifecycle callbacks Spring에서 제공하는 InitializingBean 혹은 DisposableBean 인터페이스를 구현한다면, Bean의 Lifecycle을 Container에게 위임할 수 있다. Container는 Bean 생성 과정에서는 afterPropertiesSet 함수를 호출하고 Bean의 소멸 과정에서는 destroy 함수를 호출한다. InitializingBean과 DisposableBean은 Spring Framework에서 제공하는 Interface이기 때문에, 해당 Interface를 구현한 코드들은 모두 Spring과 Coupling되는 문제를 가지고 있다. 만일 Spring Framework와의 의존 관계를 없애고 싶을 경우 JSR-250에 정의된 @PostConstruct, @PreDestroy를 사용하거나, init-method, destroy-method를 메타데이터에서 지정해주는 것이 좋다. 그러나 과연 위의 가이드라인을 따른다고 해서 완전히 Spring Framework에 Independent 한 코드를 짤 수 있을지, 그리고 이러한 코드를 재활용할 수 있을지에 대해서는 의문이 든다. Spring Framework에서는 BeanPostProcessor 구현체가 Bean 초기화/소멸 과정에서 이러한 함수들을 찾아 적절히 실행시킨다. 만일 이러한 과정을 변경하고 싶다면, BeanPostProcessor를 스스로 구현해야 한다. 추가적으로 Bean의 Lifecycle을 Container의 Lifecycle에 연결하고 싶은 경우, Lifecycle Callback을 구현하면 된다. Initialization callbacks org.springframework.beans.factory.InitializingBean 인터페이스를 구현하게 되면, Container에 의해 Bean에 필요한 모든 속성(Properties 혹은 Dependencies)을 주입받은 이후 Container에 의해 afterPropertiesSet 함수가 호출된다. 단, InitializingBean 인터페이스는 Spring과 Coupling되는 이슈가 존재하기 때문에 @PostConstruct를 사용하거나 Configuration 메타데이터에 init-method를 명시해주는 것이 좋다. InitializingBean을 활용하는 방법 package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class InitializingBeanService implements InitializingBean { public InitializingBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @Override public void afterPropertiesSet() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 위와 같은 코드를 가진 Application을 실행하는 경우, 아래와 같은 출력이 발생한다. InitializingBeanService&#39;s constructor called Set MyRepository Called InitializingBeanService&#39;s init method called Container가 생성자 -&gt; Setter -&gt; 초기화 메서드 순으로 실행하는 것을 확인할 수 있다. Init-Method 를 활용하는 방법 위의 코드에서 InitializingBean 인터페이스를 제거하고, 해당 인터페이스에서 구현해야 할 함수인 afterPropertiesSet 함수를 initThis 라는 순수한 함수로 변경하였다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 다만, Container가 해당 클래스를 Bean으로 만들 때 호출해야 할 init-method를 인지할 수 있도록 Configuration 클래스에서 Bean Annotation 속성에 initMethod를 기재해주어야 한다. package com.leeyh0216.springstudy.initmethod; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.initmethod&quot;) public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean(initMethod=&quot;initThis&quot;) public InitMethodBeanService getInitializingBeanService(){ return new InitMethodBeanService(); } } 개인적으로 위와 같은 방식은 선호하지 않는다. 언제든 오타를 낼 수 있기에 initMethod에 잘못된 이름(혹은 오타가 발생)이 적히는 경우 Compile Time에 잡아낼 수 없기 때문이다(물론 테스트를 넣으면 당연히 잡을 수 있겠지만..). @PostConstruct 를 활용하는 방법 단순히 Bean이 생성된 후 호출될 함수에 @PostConstruct 어노테이션만 붙여주면 된다. package com.leeyh0216.springstudy.postconstruct; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class PostConstructBeanService { public PostConstructBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @PostConstruct public void postConstructMethod() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } Callback 메서드의 인자와 반환 Spring Framework 문서를 보면 아래와 같은 표현이 등장한다. In the case of XML-based configuration metadata, you use the init-method attribute to specify the name of the method that has a void no-argument signature. 즉, init-method는 인자가 없는 형태의 함수여야 한다는 것이다. 그래서 아래와 같이 인자를 주고 실행해 보았다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis(int a) throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 그랬더니 아래와 같이 오류가 발생한다. Caused by: org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&#39;t find an init method named &#39;initThis&#39; on bean with name &#39;getInitializingBeanService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1716) ... 그럼 인자가 아니라 반환형이 있을 경우는 어떨까? 그런 경우도 테스트 해보았는데 정상적으로 동작하는 것을 확인하였다. 동일한 내용을 @PostConstruct에도 적용해보았는데, 좀 더 디테일한 오류 메시지가 발생한다. Caused by: java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public java.lang.String com.leeyh0216.springstudy.postconstruct.PostConstructBeanService.postConstructMethod(int) throws java.lang.Exception at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.&lt;init&gt;(InitDestroyAnnotationBeanPostProcessor.java:349) ... 반환값을 지정하는 경우에는 오류가 발생하지 않고 잘 실행되었지만, 어차피 반환형을 사용하는 곳이 없기 때문에 Spring 문서에서 말했던 것과 같이 인자가 없는 함수 형태로만 정의해서 사용해야겠다. Destruction callbacks Destruction callback에서는 DisposableBean 인터페이스 구현 @PreDestroy 어노테이션 destroy-method 지정 방식을 제공하고 있다. 위의 내용은 Initialization callback과 동일한 방식으로 구현하기 때문에 별도로 코드를 첨부하지는 않는다. 다만 아래와 같은 3가지 특이사항/주의사항이 존재한다. Java에서 제공하는 리소스 해제 인터페이스 호출 Java에서는 객체가 가지고 있는 리소스를 해제할 수 있도록 강제하는 인터페이스인 java.lang.AutoClosable과 java.io.Closable 을 제공한다.(java.io.Closable은 Java 1.5, java.lang.AutoClosable은 Java 1.7에 도입된 인터페이스이며, java.io.Closable은 java.lang.AutoClosable을 상속하므로써 Backward-Compatibility를 보장한다.) 만일 Bean에 위 2개 인터페이스 중 하나라도 구현되어 있다면 해당 인터페이스의 함수들을 호출하게 된다. 위의 인터페이스들은 try-with-resource 구문과 사용도 가능하기 때문에, 별도로 구현하는 것보다는 위 인터페이스를 사용하는 것이 좋지 않을까 생각한다. Non-Web Application에서는 ApplicationContext의 registerShutdownhook()을 호출해야 한다. Non-Web Application(주로 Pure Java Application)에서는 Container에서 Application의 종료 시점을 알 수 없으므로, registerShutdownhook 함수를 호출하여 현 JVM의 Shutdown Event를 확인할 수 있도록 해야 한다. ApplicationContext의 registerShutdownhook은 내부적으로 Runtime의 addShutdownHook을 호출하여 Application 종료 이벤트를 수신한다. /** * Register a shutdown hook with the JVM runtime, closing this context * on JVM shutdown unless it has already been closed at that time. * &lt;p&gt;Delegates to {@code doClose()} for the actual closing procedure. * @see Runtime#addShutdownHook * @see #close() * @see #doClose() */ @Override public void registerShutdownHook() { if (this.shutdownHook == null) { // No shutdown hook registered yet. this.shutdownHook = new Thread() { @Override public void run() { synchronized (startupShutdownMonitor) { doClose(); } } }; Runtime.getRuntime().addShutdownHook(this.shutdownHook); } } finalize는 사용하지 말자 이 부분은 Effective Java에 나오는 내용인데, Java의 Object 객체에는 finalize라는 함수를 오버라이딩 할 수 있게 되어 있다. JavaDoc에는 아래와 같이 기술되어 있다. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. 그러나 실제로 해당 함수가 언제 호출될 지 알 수 없기때문에, 해당 함수의 사용을 권하지 않는다고 되어 있다. Combining lifecycle mechanisms Spring 2.5 버전부터 InitializingBean, DisposableBean Custom init, destroy methods @PostConstruct, @PreDestroy 등 Bean의 생애주기를 컨트롤 할 수 있는 방법이 제공된다. 위 메소드들은 아래와 같은 순서로 호출된다. @PostConstruct Annotation이 붙은 메서드 InitializingBean을 상속받았을 때 구현하는 afterPropertiesSet 메서드 커스텀 초기화 메서드 @PreDestroy Annotation이 붙은 메스더 DisposableBean을 상속받았을 때 구현하는 destroy() 메서드 커스텀 소멸 메서드" /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-01-23T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - Customizing the nature of a bean" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Customizing the nature of a bean Lifecycle callbacks Spring에서 제공하는 InitializingBean 혹은 DisposableBean 인터페이스를 구현한다면, Bean의 Lifecycle을 Container에게 위임할 수 있다. Container는 Bean 생성 과정에서는 afterPropertiesSet 함수를 호출하고 Bean의 소멸 과정에서는 destroy 함수를 호출한다. InitializingBean과 DisposableBean은 Spring Framework에서 제공하는 Interface이기 때문에, 해당 Interface를 구현한 코드들은 모두 Spring과 Coupling되는 문제를 가지고 있다. 만일 Spring Framework와의 의존 관계를 없애고 싶을 경우 JSR-250에 정의된 @PostConstruct, @PreDestroy를 사용하거나, init-method, destroy-method를 메타데이터에서 지정해주는 것이 좋다. 그러나 과연 위의 가이드라인을 따른다고 해서 완전히 Spring Framework에 Independent 한 코드를 짤 수 있을지, 그리고 이러한 코드를 재활용할 수 있을지에 대해서는 의문이 든다. Spring Framework에서는 BeanPostProcessor 구현체가 Bean 초기화/소멸 과정에서 이러한 함수들을 찾아 적절히 실행시킨다. 만일 이러한 과정을 변경하고 싶다면, BeanPostProcessor를 스스로 구현해야 한다. 추가적으로 Bean의 Lifecycle을 Container의 Lifecycle에 연결하고 싶은 경우, Lifecycle Callback을 구현하면 된다. Initialization callbacks org.springframework.beans.factory.InitializingBean 인터페이스를 구현하게 되면, Container에 의해 Bean에 필요한 모든 속성(Properties 혹은 Dependencies)을 주입받은 이후 Container에 의해 afterPropertiesSet 함수가 호출된다. 단, InitializingBean 인터페이스는 Spring과 Coupling되는 이슈가 존재하기 때문에 @PostConstruct를 사용하거나 Configuration 메타데이터에 init-method를 명시해주는 것이 좋다. InitializingBean을 활용하는 방법 package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class InitializingBeanService implements InitializingBean { public InitializingBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @Override public void afterPropertiesSet() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 위와 같은 코드를 가진 Application을 실행하는 경우, 아래와 같은 출력이 발생한다. InitializingBeanService&#39;s constructor called Set MyRepository Called InitializingBeanService&#39;s init method called Container가 생성자 -&gt; Setter -&gt; 초기화 메서드 순으로 실행하는 것을 확인할 수 있다. Init-Method 를 활용하는 방법 위의 코드에서 InitializingBean 인터페이스를 제거하고, 해당 인터페이스에서 구현해야 할 함수인 afterPropertiesSet 함수를 initThis 라는 순수한 함수로 변경하였다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 다만, Container가 해당 클래스를 Bean으로 만들 때 호출해야 할 init-method를 인지할 수 있도록 Configuration 클래스에서 Bean Annotation 속성에 initMethod를 기재해주어야 한다. package com.leeyh0216.springstudy.initmethod; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.initmethod&quot;) public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean(initMethod=&quot;initThis&quot;) public InitMethodBeanService getInitializingBeanService(){ return new InitMethodBeanService(); } } 개인적으로 위와 같은 방식은 선호하지 않는다. 언제든 오타를 낼 수 있기에 initMethod에 잘못된 이름(혹은 오타가 발생)이 적히는 경우 Compile Time에 잡아낼 수 없기 때문이다(물론 테스트를 넣으면 당연히 잡을 수 있겠지만..). @PostConstruct 를 활용하는 방법 단순히 Bean이 생성된 후 호출될 함수에 @PostConstruct 어노테이션만 붙여주면 된다. package com.leeyh0216.springstudy.postconstruct; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class PostConstructBeanService { public PostConstructBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } @PostConstruct public void postConstructMethod() throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } Callback 메서드의 인자와 반환 Spring Framework 문서를 보면 아래와 같은 표현이 등장한다. In the case of XML-based configuration metadata, you use the init-method attribute to specify the name of the method that has a void no-argument signature. 즉, init-method는 인자가 없는 형태의 함수여야 한다는 것이다. 그래서 아래와 같이 인자를 주고 실행해 보았다. package com.leeyh0216.springstudy.initmethod; import org.springframework.beans.factory.annotation.Autowired; public class InitMethodBeanService { public InitMethodBeanService(){ System.out.println(String.format(&quot;%s&#39;s constructor called&quot;, getClass().getSimpleName())); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;Set MyRepository Called&quot;); } public void initThis(int a) throws Exception { System.out.println(String.format(&quot;%s&#39;s init method called&quot;, getClass().getSimpleName())); } } 그랬더니 아래와 같이 오류가 발생한다. Caused by: org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn&#39;t find an init method named &#39;initThis&#39; on bean with name &#39;getInitializingBeanService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1716) ... 그럼 인자가 아니라 반환형이 있을 경우는 어떨까? 그런 경우도 테스트 해보았는데 정상적으로 동작하는 것을 확인하였다. 동일한 내용을 @PostConstruct에도 적용해보았는데, 좀 더 디테일한 오류 메시지가 발생한다. Caused by: java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public java.lang.String com.leeyh0216.springstudy.postconstruct.PostConstructBeanService.postConstructMethod(int) throws java.lang.Exception at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.&lt;init&gt;(InitDestroyAnnotationBeanPostProcessor.java:349) ... 반환값을 지정하는 경우에는 오류가 발생하지 않고 잘 실행되었지만, 어차피 반환형을 사용하는 곳이 없기 때문에 Spring 문서에서 말했던 것과 같이 인자가 없는 함수 형태로만 정의해서 사용해야겠다. Destruction callbacks Destruction callback에서는 DisposableBean 인터페이스 구현 @PreDestroy 어노테이션 destroy-method 지정 방식을 제공하고 있다. 위의 내용은 Initialization callback과 동일한 방식으로 구현하기 때문에 별도로 코드를 첨부하지는 않는다. 다만 아래와 같은 3가지 특이사항/주의사항이 존재한다. Java에서 제공하는 리소스 해제 인터페이스 호출 Java에서는 객체가 가지고 있는 리소스를 해제할 수 있도록 강제하는 인터페이스인 java.lang.AutoClosable과 java.io.Closable 을 제공한다.(java.io.Closable은 Java 1.5, java.lang.AutoClosable은 Java 1.7에 도입된 인터페이스이며, java.io.Closable은 java.lang.AutoClosable을 상속하므로써 Backward-Compatibility를 보장한다.) 만일 Bean에 위 2개 인터페이스 중 하나라도 구현되어 있다면 해당 인터페이스의 함수들을 호출하게 된다. 위의 인터페이스들은 try-with-resource 구문과 사용도 가능하기 때문에, 별도로 구현하는 것보다는 위 인터페이스를 사용하는 것이 좋지 않을까 생각한다. Non-Web Application에서는 ApplicationContext의 registerShutdownhook()을 호출해야 한다. Non-Web Application(주로 Pure Java Application)에서는 Container에서 Application의 종료 시점을 알 수 없으므로, registerShutdownhook 함수를 호출하여 현 JVM의 Shutdown Event를 확인할 수 있도록 해야 한다. ApplicationContext의 registerShutdownhook은 내부적으로 Runtime의 addShutdownHook을 호출하여 Application 종료 이벤트를 수신한다. /** * Register a shutdown hook with the JVM runtime, closing this context * on JVM shutdown unless it has already been closed at that time. * &lt;p&gt;Delegates to {@code doClose()} for the actual closing procedure. * @see Runtime#addShutdownHook * @see #close() * @see #doClose() */ @Override public void registerShutdownHook() { if (this.shutdownHook == null) { // No shutdown hook registered yet. this.shutdownHook = new Thread() { @Override public void run() { synchronized (startupShutdownMonitor) { doClose(); } } }; Runtime.getRuntime().addShutdownHook(this.shutdownHook); } } finalize는 사용하지 말자 이 부분은 Effective Java에 나오는 내용인데, Java의 Object 객체에는 finalize라는 함수를 오버라이딩 할 수 있게 되어 있다. JavaDoc에는 아래와 같이 기술되어 있다. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. 그러나 실제로 해당 함수가 언제 호출될 지 알 수 없기때문에, 해당 함수의 사용을 권하지 않는다고 되어 있다. Combining lifecycle mechanisms Spring 2.5 버전부터 InitializingBean, DisposableBean Custom init, destroy methods @PostConstruct, @PreDestroy 등 Bean의 생애주기를 컨트롤 할 수 있는 방법이 제공된다. 위 메소드들은 아래와 같은 순서로 호출된다. @PostConstruct Annotation이 붙은 메서드 InitializingBean을 상속받았을 때 구현하는 afterPropertiesSet 메서드 커스텀 초기화 메서드 @PreDestroy Annotation이 붙은 메스더 DisposableBean을 상속받았을 때 구현하는 destroy() 메서드 커스텀 소멸 메서드","url":"https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/","@type":"BlogPosting","headline":"Spring Core Technologies - Customizing the nature of a bean","dateModified":"2019-01-23T10:00:00+09:00","datePublished":"2019-01-23T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - Customizing the nature of a bean | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - Customizing the nature of a bean</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - Customizing the nature of a bean</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 23, 2019, 10:00 AM +0900" prep="on" > Jan 23, 2019 <i class="unloaded">2019-01-23T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2013 words">11 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="customizing-the-nature-of-a-bean">Customizing the nature of a bean</h1><h2 id="lifecycle-callbacks">Lifecycle callbacks</h2><p>Spring에서 제공하는 <code class="language-plaintext highlighter-rouge">InitializingBean</code> 혹은 <code class="language-plaintext highlighter-rouge">DisposableBean</code> 인터페이스를 구현한다면, Bean의 Lifecycle을 Container에게 위임할 수 있다.</p><p>Container는 Bean 생성 과정에서는 <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 함수를 호출하고 Bean의 소멸 과정에서는 <code class="language-plaintext highlighter-rouge">destroy</code> 함수를 호출한다.</p><blockquote><p><code class="language-plaintext highlighter-rouge">InitializingBean</code>과 <code class="language-plaintext highlighter-rouge">DisposableBean</code>은 Spring Framework에서 제공하는 Interface이기 때문에, 해당 Interface를 구현한 코드들은 모두 Spring과 Coupling되는 문제를 가지고 있다. 만일 Spring Framework와의 의존 관계를 없애고 싶을 경우 JSR-250에 정의된 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>, <code class="language-plaintext highlighter-rouge">@PreDestroy</code>를 사용하거나, <code class="language-plaintext highlighter-rouge">init-method</code>, <code class="language-plaintext highlighter-rouge">destroy-method</code>를 메타데이터에서 지정해주는 것이 좋다.</p></blockquote><blockquote><p>그러나 과연 위의 가이드라인을 따른다고 해서 완전히 Spring Framework에 Independent 한 코드를 짤 수 있을지, 그리고 이러한 코드를 재활용할 수 있을지에 대해서는 의문이 든다.</p></blockquote><p>Spring Framework에서는 BeanPostProcessor 구현체가 Bean 초기화/소멸 과정에서 이러한 함수들을 찾아 적절히 실행시킨다. 만일 이러한 과정을 변경하고 싶다면, BeanPostProcessor를 스스로 구현해야 한다.</p><p>추가적으로 Bean의 Lifecycle을 Container의 Lifecycle에 연결하고 싶은 경우, <code class="language-plaintext highlighter-rouge">Lifecycle</code> Callback을 구현하면 된다.</p><h3 id="initialization-callbacks">Initialization callbacks</h3><p><code class="language-plaintext highlighter-rouge">org.springframework.beans.factory.InitializingBean</code> 인터페이스를 구현하게 되면, Container에 의해 Bean에 필요한 모든 속성(Properties 혹은 Dependencies)을 주입받은 이후 Container에 의해 <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 함수가 호출된다.</p><p>단, <code class="language-plaintext highlighter-rouge">InitializingBean</code> 인터페이스는 Spring과 Coupling되는 이슈가 존재하기 때문에 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>를 사용하거나 Configuration 메타데이터에 <code class="language-plaintext highlighter-rouge">init-method</code>를 명시해주는 것이 좋다.</p><h4 id="initializingbean을-활용하는-방법">InitializingBean을 활용하는 방법</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InitializingBeanService</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">InitializingBeanService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's constructor called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Set MyRepository Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's init method called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같은 코드를 가진 Application을 실행하는 경우, 아래와 같은 출력이 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">InitializingBeanService<span class="s1">'s constructor called
Set MyRepository Called
InitializingBeanService'</span>s init method called</code></pre></figure><p>Container가 생성자 -&gt; Setter -&gt; 초기화 메서드 순으로 실행하는 것을 확인할 수 있다.</p><h4 id="init-method-를-활용하는-방법">Init-Method 를 활용하는 방법</h4><p>위의 코드에서 <code class="language-plaintext highlighter-rouge">InitializingBean</code> 인터페이스를 제거하고, 해당 인터페이스에서 구현해야 할 함수인 <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 함수를 <code class="language-plaintext highlighter-rouge">initThis</code> 라는 순수한 함수로 변경하였다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initmethod</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InitMethodBeanService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">InitMethodBeanService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's constructor called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Set MyRepository Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initThis</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's init method called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>다만, Container가 해당 클래스를 Bean으로 만들 때 호출해야 할 <code class="language-plaintext highlighter-rouge">init-method</code>를 인지할 수 있도록 Configuration 클래스에서 Bean Annotation 속성에 <code class="language-plaintext highlighter-rouge">initMethod</code>를 기재해주어야 한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initmethod</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.initmethod"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyRepository</span> <span class="nf">getMyRepository</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyRepository</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">initMethod</span><span class="o">=</span><span class="s">"initThis"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">InitMethodBeanService</span> <span class="nf">getInitializingBeanService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">InitMethodBeanService</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>개인적으로 위와 같은 방식은 선호하지 않는다. 언제든 오타를 낼 수 있기에 <code class="language-plaintext highlighter-rouge">initMethod</code>에 잘못된 이름(혹은 오타가 발생)이 적히는 경우 Compile Time에 잡아낼 수 없기 때문이다(물론 테스트를 넣으면 당연히 잡을 수 있겠지만..).</p><h4 id="postconstruct-를-활용하는-방법">@PostConstruct 를 활용하는 방법</h4><p>단순히 Bean이 생성된 후 호출될 함수에 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션만 붙여주면 된다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.postconstruct</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PostConstructBeanService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">PostConstructBeanService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's constructor called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Set MyRepository Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstructMethod</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's init method called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h4 id="callback-메서드의-인자와-반환">Callback 메서드의 인자와 반환</h4><p>Spring Framework 문서를 보면 아래와 같은 표현이 등장한다.</p><blockquote><p>In the case of XML-based configuration metadata, you use the init-method attribute to specify the name of the method that has a void no-argument signature.</p></blockquote><p>즉, <code class="language-plaintext highlighter-rouge">init-method</code>는 인자가 없는 형태의 함수여야 한다는 것이다. 그래서 아래와 같이 인자를 주고 실행해 보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initmethod</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InitMethodBeanService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">InitMethodBeanService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's constructor called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Set MyRepository Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initThis</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s's init method called"</span><span class="o">,</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>그랬더니 아래와 같이 오류가 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Caused by: org.springframework.beans.factory.support.BeanDefinitionValidationException: Couldn<span class="s1">'t find an init method named '</span>initThis<span class="s1">' on bean with name '</span>getInitializingBeanService<span class="s1">'
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1716)
	...</span></code></pre></figure><p>그럼 인자가 아니라 반환형이 있을 경우는 어떨까? 그런 경우도 테스트 해보았는데 정상적으로 동작하는 것을 확인하였다.</p><p>동일한 내용을 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>에도 적용해보았는데, 좀 더 디테일한 오류 메시지가 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Caused by: java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public java.lang.String com.leeyh0216.springstudy.postconstruct.PostConstructBeanService.postConstructMethod<span class="o">(</span>int<span class="o">)</span> throws java.lang.Exception
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor<span class="nv">$LifecycleElement</span>.&lt;init&gt;<span class="o">(</span>InitDestroyAnnotationBeanPostProcessor.java:349<span class="o">)</span>
	...</code></pre></figure><p>반환값을 지정하는 경우에는 오류가 발생하지 않고 잘 실행되었지만, 어차피 반환형을 사용하는 곳이 없기 때문에 Spring 문서에서 말했던 것과 같이 인자가 없는 함수 형태로만 정의해서 사용해야겠다.</p><h3 id="destruction-callbacks">Destruction callbacks</h3><p>Destruction callback에서는</p><ul><li><code class="language-plaintext highlighter-rouge">DisposableBean</code> 인터페이스 구현<li><code class="language-plaintext highlighter-rouge">@PreDestroy</code> 어노테이션<li><code class="language-plaintext highlighter-rouge">destroy-method</code> 지정</ul><p>방식을 제공하고 있다.</p><p>위의 내용은 Initialization callback과 동일한 방식으로 구현하기 때문에 별도로 코드를 첨부하지는 않는다.</p><p>다만 아래와 같은 3가지 특이사항/주의사항이 존재한다.</p><h4 id="java에서-제공하는-리소스-해제-인터페이스-호출">Java에서 제공하는 리소스 해제 인터페이스 호출</h4><p>Java에서는 객체가 가지고 있는 리소스를 해제할 수 있도록 강제하는 인터페이스인 <code class="language-plaintext highlighter-rouge">java.lang.AutoClosable</code>과 <code class="language-plaintext highlighter-rouge">java.io.Closable</code> 을 제공한다.(<code class="language-plaintext highlighter-rouge">java.io.Closable</code>은 Java 1.5, <code class="language-plaintext highlighter-rouge">java.lang.AutoClosable</code>은 Java 1.7에 도입된 인터페이스이며, <code class="language-plaintext highlighter-rouge">java.io.Closable</code>은 <code class="language-plaintext highlighter-rouge">java.lang.AutoClosable</code>을 상속하므로써 Backward-Compatibility를 보장한다.)</p><p>만일 Bean에 위 2개 인터페이스 중 하나라도 구현되어 있다면 해당 인터페이스의 함수들을 호출하게 된다.</p><p>위의 인터페이스들은 try-with-resource 구문과 사용도 가능하기 때문에, 별도로 구현하는 것보다는 위 인터페이스를 사용하는 것이 좋지 않을까 생각한다.</p><h4 id="non-web-application에서는-applicationcontext의-registershutdownhook을-호출해야-한다">Non-Web Application에서는 ApplicationContext의 registerShutdownhook()을 호출해야 한다.</h4><p>Non-Web Application(주로 Pure Java Application)에서는 Container에서 Application의 종료 시점을 알 수 없으므로, <code class="language-plaintext highlighter-rouge">registerShutdownhook</code> 함수를 호출하여 현 JVM의 Shutdown Event를 확인할 수 있도록 해야 한다.</p><p><code class="language-plaintext highlighter-rouge">ApplicationContext</code>의 <code class="language-plaintext highlighter-rouge">registerShutdownhook</code>은 내부적으로 <code class="language-plaintext highlighter-rouge">Runtime</code>의 <code class="language-plaintext highlighter-rouge">addShutdownHook</code>을 호출하여 Application 종료 이벤트를 수신한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/**
	 * Register a shutdown hook with the JVM runtime, closing this context
	 * on JVM shutdown unless it has already been closed at that time.
	 * &lt;p&gt;Delegates to {@code doClose()} for the actual closing procedure.
	 * @see Runtime#addShutdownHook
	 * @see #close()
	 * @see #doClose()
	 */</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerShutdownHook</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">shutdownHook</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// No shutdown hook registered yet.
</span>
			<span class="k">this</span><span class="o">.</span><span class="na">shutdownHook</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">()</span> <span class="o">{</span>
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
					<span class="kd">synchronized</span> <span class="o">(</span><span class="n">startupShutdownMonitor</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">doClose</span><span class="o">();</span>
					<span class="o">}</span>
				<span class="o">}</span>
			<span class="o">};</span>
			<span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">addShutdownHook</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">shutdownHook</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span></code></pre></figure><h4 id="finalize는-사용하지-말자">finalize는 사용하지 말자</h4><p>이 부분은 Effective Java에 나오는 내용인데, Java의 Object 객체에는 <code class="language-plaintext highlighter-rouge">finalize</code>라는 함수를 오버라이딩 할 수 있게 되어 있다.</p><p>JavaDoc에는 아래와 같이 기술되어 있다.</p><blockquote><p>Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup.</p></blockquote><p>그러나 실제로 해당 함수가 언제 호출될 지 알 수 없기때문에, 해당 함수의 사용을 권하지 않는다고 되어 있다.</p><h3 id="combining-lifecycle-mechanisms">Combining lifecycle mechanisms</h3><p>Spring 2.5 버전부터</p><ul><li>InitializingBean, DisposableBean<li>Custom init, destroy methods<li>@PostConstruct, @PreDestroy</ul><p>등 Bean의 생애주기를 컨트롤 할 수 있는 방법이 제공된다.</p><p>위 메소드들은 아래와 같은 순서로 호출된다.</p><ol><li>@PostConstruct Annotation이 붙은 메서드<li>InitializingBean을 상속받았을 때 구현하는 afterPropertiesSet 메서드<li>커스텀 초기화 메서드<li>@PreDestroy Annotation이 붙은 메스더<li>DisposableBean을 상속받았을 때 구현하는 destroy() 메서드<li>커스텀 소멸 메서드</ol></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - Customizing the nature of a bean - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - Customizing the nature of a bean - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - Customizing the nature of a bean - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-customizing-the-nature-of-a-bean/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-core-4/"><div class="card-body"> <span class="timeago small" > Dec 23, 2018 <i class="unloaded">2018-12-23T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(4)</h3><div class="text-muted small"><p> The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-bean-scopes/" class="btn btn-outline-primary" prompt="Older"><p>Spring Core Technologies - Bean Scopes</p></a> <a href="/posts/annotation-based-container-configuration/" class="btn btn-outline-primary" prompt="Newer"><p>Spring Core Technologies - Annotation-based container configuration(1)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
