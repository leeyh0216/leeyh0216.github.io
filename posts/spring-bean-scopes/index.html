<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - Bean Scopes" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다." /><meta property="og:description" content="Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-bean-scopes/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-bean-scopes/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-01-22T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - Bean Scopes" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다.","url":"https://leeyh0216.github.io/posts/spring-bean-scopes/","@type":"BlogPosting","headline":"Spring Core Technologies - Bean Scopes","dateModified":"2019-01-22T10:00:00+09:00","datePublished":"2019-01-22T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-bean-scopes/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - Bean Scopes | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - Bean Scopes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - Bean Scopes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jan 22, 2019, 10:00 AM +0900" prep="on" > Jan 22, 2019 <i class="unloaded">2019-01-22T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1627 words">9 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="bean-scopes">Bean Scopes</h1><p>Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다.</p><p>Bean Definition에는 생성할 Bean의</p><ul><li>의존성(Dependency)<li>설정값(Configuration values)<li><strong>Scope</strong></ul><p>이 포함된다.</p><p>설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다.</p><p>Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다.</p><h2 id="singleton-scope">Singleton Scope</h2><p>Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/spring/singletonscope.jpg" alt="Singleton Scope" /></p><p>Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다.</p><p>GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다.</p><h3 id="일반적인-singleton-pattern">일반적인 Singleton Pattern</h3><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.others</span><span class="o">;</span>

<span class="c1">//Final 클래스로 만들어 상속이 불가하게 함
</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SingletonExample</span> <span class="o">{</span>

    <span class="c1">//JVM 내에서 1개만 유지되는 SingletonExample 객체
</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonExample</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">//synchronized 키워드를 통해 Thread-Safe 보장
</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">SingletonExample</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonExample</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">SingletonExample</span><span class="o">(){</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SingletonExample</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">SingletonExample</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">SingletonExample</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">SingletonExample</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 생성자를 <code class="language-plaintext highlighter-rouge">private</code>으로 선언하여 <code class="language-plaintext highlighter-rouge">new</code>를 통한 객체 생성을 막고, <code class="language-plaintext highlighter-rouge">getInstance</code> 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다.</p><p>Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다.</p><p>위 프로그램의 결과는 <code class="language-plaintext highlighter-rouge">true</code>가 나오게 된다.</p><h3 id="spring에서의-singleton-scope">Spring에서의 Singleton Scope</h3><p>테스트를 위해 3개의 파일을 작성한다.</p><ul><li>Program Entry Point 역할을 담당하는 Application 클래스<li>Configuration 역할을 담당하는 AppConfig 클래스<li>테스트 클래스인 MyService</ul><h4 id="myservicejava">MyService.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonscope</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>아무 기능도 없이 기본 생성자만 존재하는 클래스이다.</p><h4 id="appconfigjava">AppConfig.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonscope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.singletonscope"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>MyService 타입의 Bean을 반환하는 <code class="language-plaintext highlighter-rouge">getMyService</code> 함수가 정의된 Configuration 클래스이다.</p><h4 id="applicationjava">Application.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonscope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyService</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m1</span> <span class="o">==</span> <span class="n">m2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m2</span> <span class="o">==</span> <span class="n">m3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m1</span> <span class="o">==</span> <span class="n">m3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>메인 함수가 들어 있는 Application 클래스이다.</p><p>위 프로그램의 출력은 아래와 같다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">true
false
false</span></code></pre></figure><p>위의 <code class="language-plaintext highlighter-rouge">m1</code>과 <code class="language-plaintext highlighter-rouge">m2</code> 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 <code class="language-plaintext highlighter-rouge">m1</code>과 <code class="language-plaintext highlighter-rouge">m2</code> 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 <code class="language-plaintext highlighter-rouge">true</code>가 된다.</p><p>그런데 <code class="language-plaintext highlighter-rouge">m3</code> 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 <code class="language-plaintext highlighter-rouge">m1</code>, <code class="language-plaintext highlighter-rouge">m2</code> 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 <code class="language-plaintext highlighter-rouge">false</code>가 되는 것이다.</p><h2 id="prototype-scope">Prototype Scope</h2><p>Prototype Bean은 Bean을 참조하는 요청(<code class="language-plaintext highlighter-rouge">getBean</code>과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다.</p><p>Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/spring/prototypescope.jpg" alt="Prototype Scope" /></p><p>다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다.</p><h3 id="prototype-scope-테스트-코드">Prototype Scope 테스트 코드</h3><p>위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 <code class="language-plaintext highlighter-rouge">getMyService</code> 메서드에 <code class="language-plaintext highlighter-rouge">@Scope("prototype")</code> 어노테이션이 추가된 점만 다르다.</p><h4 id="appconfigjava-1">AppConfig.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.prototypescope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Scope</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.prototypescope"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위에서는 명시적으로 <code class="language-plaintext highlighter-rouge">@Scope</code> 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 <code class="language-plaintext highlighter-rouge">@Scope("singleton")</code>과 동일한 효과를 가지게 된다.</p><p>위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">false
false
false</span></code></pre></figure><p>Singleton과 다르게 Spring IoC Container에서 <code class="language-plaintext highlighter-rouge">getBean</code> 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다.</p><h3 id="lifecycle-callback-비교하기singleton-vs-prototype">Lifecycle Callback 비교하기(Singleton vs Prototype)</h3><p>Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다.</p><p>아래와 같이 테스트를 수행해보았다.</p><h4 id="singletonservicejava">SingletonService.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">SingletonService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton has created"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton is destroying"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h4 id="prototypeservicejava">PrototypeService.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrototypeService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">PrototypeService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Prototype has created"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Prototype is destroying"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h4 id="appconfigjava-2">AppConfig.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Scope</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.singletonvsprototype"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"singleton"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">SingletonService</span> <span class="nf">getSingletonService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">SingletonService</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">PrototypeService</span> <span class="nf">getPrototypeService</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">PrototypeService</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h4 id="applicationjava-1">Application.java</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">SingletonService</span> <span class="n">singletonService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">SingletonService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">PrototypeService</span> <span class="n">prototypeService1</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">PrototypeService</span> <span class="n">prototypeService2</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="o">((</span><span class="nc">AnnotationConfigApplicationContext</span><span class="o">)</span> <span class="n">applicationContext</span><span class="o">).</span><span class="na">registerShutdownHook</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위 프로그램의 출력은 아래와 같다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Singleton has created
Prototype has created
Prototype has created
Singleton is destroying</code></pre></figure><p>위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - Bean Scopes - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-bean-scopes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - Bean Scopes - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-bean-scopes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - Bean Scopes - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-bean-scopes/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-core-4/"><div class="card-body"> <span class="timeago small" > Dec 23, 2018 <i class="unloaded">2018-12-23T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(4)</h3><div class="text-muted small"><p> The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-rabbitmq-2/" class="btn btn-outline-primary" prompt="Older"><p>Spring with RabbitMQ(2)</p></a> <a href="/posts/spring-customizing-the-nature-of-a-bean/" class="btn btn-outline-primary" prompt="Newer"><p>Spring Core Technologies - Customizing the nature of a bean</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
