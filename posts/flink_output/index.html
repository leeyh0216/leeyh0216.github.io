<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Flink Concept - Operator 간 데이터 교환" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="개요 Flink Job의 Operator 간의 데이터 교환이 어떻게 이루어지는지 알아보고, 유의해야 할 옵션은 어떤 것이 있는지 알아보도록 한다. Flink의 Input과 Ouptut 위와 같이 3개의 Operator가 연결되어 있다고 생각해보자. 한 Operator의 출력 데이터는 다른 Operator의 입력 데이터로 사용된다. 그래프 관점에서는 Operator는 Vertex, Operator 사이의 단방향 화살표를 Edge로 표현한다. Flink에서는 Operator(Vertex)를 Input, 데이터 교환 채널(Edge)을 Output으로 추상화하여 사용한다. Input Flink에서 하나의 입력을 처리하는 Operator는 Input 인터페이스를 상속한다. public interface Input&lt;IN&gt; { void processElement(StreamRecord&lt;IN&gt; element) throws Exception; void processWatermark(Watermark mark) throws Exception; void processLatencyMarker(LatencyMarker latencyMarker) throws Exception; void setKeyContextElement(StreamRecord&lt;IN&gt; record) throws Exception; } Input을 상속하는 StreamMap의 코드는 아래와 같다. public class StreamMap&lt;IN, OUT&gt; extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt; implements OneInputStreamOperator&lt;IN, OUT&gt; { private static final long serialVersionUID = 1L; public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) { super(mapper); chainingStrategy = ChainingStrategy.ALWAYS; } @Override public void processElement(StreamRecord&lt;IN&gt; element) throws Exception { output.collect(element.replace(userFunction.map(element.getValue()))); } } StreamMap이 구현한 OneInputStreamOperator는 Input을 상속하기 때문에 결론적으로 StreamMap이 Input을 구현하는 구조가 된다. 모든 Input을 상속한 클래스들은 자신의 출력 결과를 다음 Operator(Input)에게 전달할 Output을 가지고 있다. Input은 자신이 가지고 있는 사용자 함수(Function)으로 이전 출력에서 가져온 입력 데이터(StreamRecord)를 처리한 뒤, Output의 collect를 통해 다음 출력으로 내보내게 된다. Output Flink에서 Operator가 처리한 데이터를 다음 Operator로 넘기는 역할은 Output이 처리한다. 이전 단계의 Operator가 자신이 처리한 데이터를 Output의 collect를 호출하여 전달하면, Output은 이 데이터를 자신이 가지고 있는 다음 Operator 객체의 processElement의 매개변수로 전달하여 데이터를 전달하는 과정을 거치게 된다. Operator 간의 관계(1:1인가, 1:N인가)와 동일 OperatorChain에 속하는지의 여부에 따라 세가지 Output으로 나뉘게 된다. Operator 간의 관계가 1:1인 경우 같은 OperatorChain에 속한 Operator 간 연결: ChainingOutput 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간 연결: RecordWriterOutput Operator 간의 관계가 1:N인 경우: BroadcastingOutputCollector 당연한 이야기이지만 두 Operator가 동일한 Parallelism을 가지고 있더라도, shuffle이나 disableChaining을 호출하여 서로 다른 OperatorChain으로 분리되는 경우에는 RecordWriterOutput이 사용된다. ChainingOutput ChainingOutput은 동일한 OperatorChain에 속한 두 Operator 간(1:1)의 데이터 전달에 사용된다. 네트워크를 사용하지 않고 1:1 관계의 교환이기 때문에 구현이 매우 간단하다. 이전 Operator(Input)의 processElement에서 데이터를 호출한 뒤 ChainingOutput의 collect를 호출하면 데이터 전달이 진행된다. collect은 아래와 같이 구현되어 있다. @Override public void collect(StreamRecord&lt;T&gt; record) { if (this.outputTag != null) { // we are not responsible for emitting to the main output. return; } pushToOperator(record); } 이전 Operator의 출력 데이터(record)를 매개변수로 pushToOperator를 호출하고 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 전달받은 record를 자신이 가지고 있는 input(다음 Operator)의 processElement를 호출하여 다음 Operator로 데이터를 전달하게 된다. RecordWriterOutput ChainingOutput은 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간의 데이터 교환에 사용된다. 네트워크를 사용하며, broadcast를 사용했는지 아닌지 여부에 따라 실제로 다음 데이터로 전달하는 객체인 RecordWriter 종류가 달라지게 된다. broadcast를 사용하지 않은 경우 ChannelSelectorRecordWriter가 사용된다. Parallelism 설정과 shuffle, rebalance, disableChaining 호출에 따라 ChannelSelector의 타입이 달라지게 된다. broadcast를 사용하는 경우 BroadcastRecordWriter가 사용된다. BroadcastingOutputCollector 하나의 Operator에서 2개 이상의 Operator로 데이터를 전달하는 경우에 사용된다. 내부적으로 Output 배열이 있어 각 Operator 간의 관계에 따라 ChainingOutput, RecordWriterOutput을 가지게 된다. 더 알아보기 pipeline.object-reuse 옵션과 Output Flink Documentation - Config 페이지에는 pipeline.object-reuse 옵션에 대한 설명이 존재한다. When enabled objects that Flink internally uses for deserialization and passing data to user-code functions will be reused. Keep in mind that this can lead to bugs when the user-code function of an operation is not aware of this behaviour. pipeline.object-reuse 옵션을 사용하면 Flink는 User Function으로 전달하는 데이터를 재사용하게 된다. Output 객체를 만들 때, 이 옵션의 활성 여부에 따라 다른 클래스의 Output 객체가 만들어진다. 같은 OperatorChain에 속하는 Operator를 연결하는 Output을 만들어내는 코드를 보자. if (containingTask.getExecutionConfig().isObjectReuseEnabled()) { currentOperatorOutput = new ChainingOutput&lt;&gt;(operator, this, outputTag); } else { TypeSerializer&lt;IN&gt; inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader); currentOperatorOutput = new CopyingChainingOutput&lt;&gt;(operator, inSerializer, outputTag, this); } pipeline.object-reuse 옵션이 활성화되어 있는 경우 초기화되는 객체가 ChainingOutput 타입이고, 활성화 되어 있지 않은 경우 CopyingChainingOutput인 것을 확인할 수 있다. 이 둘이 어떻게 다른지는 다음 Operator로 데이터를 전달하는 pushToOperator 구현을 보면 알 수 있다. ChainingOutput의 경우 아래와 같이 이전 Operator가 전달한 데이터를 별다른 변경 없이 다음 Operator로 전달하는 것을 볼 수 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 그러나 CopyingChainingOutput의 경우 중간에 이전 Record를 Deep Copy하는 코드(serializer.copy)가 호출되어 원본이 아닌 복사된 객체를 다음 Operator로 전달하는 것을 볼 수 있다. @Override protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator (and Serializer) expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); StreamRecord&lt;T&gt; copy = castRecord.copy(serializer.copy(castRecord.getValue())); input.setKeyContextElement(copy); input.processElement(copy); ... } 아마 이 옵션은 사용자가 자체 Thread를 만들어 이미 전달한 Record를 바꾸는 경우 이후 Pipeline에서 발생할 수 있는 문제를 방지하기 위해 만들었을 것으로 예상한다. 이 옵션이 켜져 있으면 Operator 갯수 - 1번의 데이터 복사가 반복해서 발생하기 떄문에 위와 같은 상황이 아니라면 false로 처리하는 편이 낫다(default는 true이다). execution.buffer-timeout과 Output Flink Documentation - Config 페이지에는 execution.buffer-timeout 옵션에 대한 설명이 존재한다. The maximum time frequency (milliseconds) for the flushing of the output buffers. By default the output buffers flush frequently to provide low latency and to aid smooth developer experience. Setting the parameter can result in three logical modes: A positive value triggers flushing periodically by that interval 0 triggers flushing after every record thus minimizing latency -1 ms triggers flushing only when the output buffer is full thus maximizing throughput Output Buffer의 데이터를 얼마나 자주 Flush 할 것인지에 대한 내용이다. 이 값이 작으면 Latency가 줄어들지만 Throughput 또한 줄어들 수 있다. 이 옵션은 네트워크를 통해 데이터를 전달하는 RecordWriter에서 사용된다. RecordWriter의 생성자의 timeout값으로 전달되며, 이 값은 내부적으로 사용되는 flushAlways옵션과 OutputFlusher의 Flush 주기에 영향을 미친다. 우선 flushAlways는 timeout값이 0인 경우 true, 아닐 경우 false로 설정된다. 이전 Operator의 결과 데이터를 다음 Operator로 전달하는 emit의 코드는 아래와 같다. protected void emit(T record, int targetSubpartition) throws IOException { checkErroneous(); targetPartition.emitRecord(serializeRecord(serializer, record), targetSubpartition); if (flushAlways) { targetPartition.flush(targetSubpartition); } } 전달해야하는 파티션(Operator)의 emitRecord를 통해 데이터를 전달한다. 그러나 이 과정에서는 내부 버퍼에만 데이터가 쌓일 뿐 Flush가 일어나지는 않는다. 이후 if문에서 flushAlways 여부에 따라 바로 Flush를 하는지 아닌지가 결정된다. 또한 RecordWriter에는 주기적으로 Buffer에 쌓인 데이터를 Flush하는 OutputFlusher가 존재한다. OutputFlusher의 run 구현은 아래와 같다. public void run() { try { while (running) { try { Thread.sleep(timeout); } catch (InterruptedException e) { // propagate this if we are still running, because it should not happen // in that case if (running) { throw new Exception(e); } } // any errors here should let the thread come to a halt and be // recognized by the writer flushAll(); } } catch (Throwable t) { notifyFlusherException(t); } } 무한 루프 내에서 timeout 주기로 Thread가 Sleep하는 것을 확인할 수 있다. 이후 flushAll 호출을 통해 버퍼의 데이터를 Flush 하는 것을 확인할 수 있다." /><meta property="og:description" content="개요 Flink Job의 Operator 간의 데이터 교환이 어떻게 이루어지는지 알아보고, 유의해야 할 옵션은 어떤 것이 있는지 알아보도록 한다. Flink의 Input과 Ouptut 위와 같이 3개의 Operator가 연결되어 있다고 생각해보자. 한 Operator의 출력 데이터는 다른 Operator의 입력 데이터로 사용된다. 그래프 관점에서는 Operator는 Vertex, Operator 사이의 단방향 화살표를 Edge로 표현한다. Flink에서는 Operator(Vertex)를 Input, 데이터 교환 채널(Edge)을 Output으로 추상화하여 사용한다. Input Flink에서 하나의 입력을 처리하는 Operator는 Input 인터페이스를 상속한다. public interface Input&lt;IN&gt; { void processElement(StreamRecord&lt;IN&gt; element) throws Exception; void processWatermark(Watermark mark) throws Exception; void processLatencyMarker(LatencyMarker latencyMarker) throws Exception; void setKeyContextElement(StreamRecord&lt;IN&gt; record) throws Exception; } Input을 상속하는 StreamMap의 코드는 아래와 같다. public class StreamMap&lt;IN, OUT&gt; extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt; implements OneInputStreamOperator&lt;IN, OUT&gt; { private static final long serialVersionUID = 1L; public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) { super(mapper); chainingStrategy = ChainingStrategy.ALWAYS; } @Override public void processElement(StreamRecord&lt;IN&gt; element) throws Exception { output.collect(element.replace(userFunction.map(element.getValue()))); } } StreamMap이 구현한 OneInputStreamOperator는 Input을 상속하기 때문에 결론적으로 StreamMap이 Input을 구현하는 구조가 된다. 모든 Input을 상속한 클래스들은 자신의 출력 결과를 다음 Operator(Input)에게 전달할 Output을 가지고 있다. Input은 자신이 가지고 있는 사용자 함수(Function)으로 이전 출력에서 가져온 입력 데이터(StreamRecord)를 처리한 뒤, Output의 collect를 통해 다음 출력으로 내보내게 된다. Output Flink에서 Operator가 처리한 데이터를 다음 Operator로 넘기는 역할은 Output이 처리한다. 이전 단계의 Operator가 자신이 처리한 데이터를 Output의 collect를 호출하여 전달하면, Output은 이 데이터를 자신이 가지고 있는 다음 Operator 객체의 processElement의 매개변수로 전달하여 데이터를 전달하는 과정을 거치게 된다. Operator 간의 관계(1:1인가, 1:N인가)와 동일 OperatorChain에 속하는지의 여부에 따라 세가지 Output으로 나뉘게 된다. Operator 간의 관계가 1:1인 경우 같은 OperatorChain에 속한 Operator 간 연결: ChainingOutput 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간 연결: RecordWriterOutput Operator 간의 관계가 1:N인 경우: BroadcastingOutputCollector 당연한 이야기이지만 두 Operator가 동일한 Parallelism을 가지고 있더라도, shuffle이나 disableChaining을 호출하여 서로 다른 OperatorChain으로 분리되는 경우에는 RecordWriterOutput이 사용된다. ChainingOutput ChainingOutput은 동일한 OperatorChain에 속한 두 Operator 간(1:1)의 데이터 전달에 사용된다. 네트워크를 사용하지 않고 1:1 관계의 교환이기 때문에 구현이 매우 간단하다. 이전 Operator(Input)의 processElement에서 데이터를 호출한 뒤 ChainingOutput의 collect를 호출하면 데이터 전달이 진행된다. collect은 아래와 같이 구현되어 있다. @Override public void collect(StreamRecord&lt;T&gt; record) { if (this.outputTag != null) { // we are not responsible for emitting to the main output. return; } pushToOperator(record); } 이전 Operator의 출력 데이터(record)를 매개변수로 pushToOperator를 호출하고 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 전달받은 record를 자신이 가지고 있는 input(다음 Operator)의 processElement를 호출하여 다음 Operator로 데이터를 전달하게 된다. RecordWriterOutput ChainingOutput은 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간의 데이터 교환에 사용된다. 네트워크를 사용하며, broadcast를 사용했는지 아닌지 여부에 따라 실제로 다음 데이터로 전달하는 객체인 RecordWriter 종류가 달라지게 된다. broadcast를 사용하지 않은 경우 ChannelSelectorRecordWriter가 사용된다. Parallelism 설정과 shuffle, rebalance, disableChaining 호출에 따라 ChannelSelector의 타입이 달라지게 된다. broadcast를 사용하는 경우 BroadcastRecordWriter가 사용된다. BroadcastingOutputCollector 하나의 Operator에서 2개 이상의 Operator로 데이터를 전달하는 경우에 사용된다. 내부적으로 Output 배열이 있어 각 Operator 간의 관계에 따라 ChainingOutput, RecordWriterOutput을 가지게 된다. 더 알아보기 pipeline.object-reuse 옵션과 Output Flink Documentation - Config 페이지에는 pipeline.object-reuse 옵션에 대한 설명이 존재한다. When enabled objects that Flink internally uses for deserialization and passing data to user-code functions will be reused. Keep in mind that this can lead to bugs when the user-code function of an operation is not aware of this behaviour. pipeline.object-reuse 옵션을 사용하면 Flink는 User Function으로 전달하는 데이터를 재사용하게 된다. Output 객체를 만들 때, 이 옵션의 활성 여부에 따라 다른 클래스의 Output 객체가 만들어진다. 같은 OperatorChain에 속하는 Operator를 연결하는 Output을 만들어내는 코드를 보자. if (containingTask.getExecutionConfig().isObjectReuseEnabled()) { currentOperatorOutput = new ChainingOutput&lt;&gt;(operator, this, outputTag); } else { TypeSerializer&lt;IN&gt; inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader); currentOperatorOutput = new CopyingChainingOutput&lt;&gt;(operator, inSerializer, outputTag, this); } pipeline.object-reuse 옵션이 활성화되어 있는 경우 초기화되는 객체가 ChainingOutput 타입이고, 활성화 되어 있지 않은 경우 CopyingChainingOutput인 것을 확인할 수 있다. 이 둘이 어떻게 다른지는 다음 Operator로 데이터를 전달하는 pushToOperator 구현을 보면 알 수 있다. ChainingOutput의 경우 아래와 같이 이전 Operator가 전달한 데이터를 별다른 변경 없이 다음 Operator로 전달하는 것을 볼 수 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 그러나 CopyingChainingOutput의 경우 중간에 이전 Record를 Deep Copy하는 코드(serializer.copy)가 호출되어 원본이 아닌 복사된 객체를 다음 Operator로 전달하는 것을 볼 수 있다. @Override protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator (and Serializer) expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); StreamRecord&lt;T&gt; copy = castRecord.copy(serializer.copy(castRecord.getValue())); input.setKeyContextElement(copy); input.processElement(copy); ... } 아마 이 옵션은 사용자가 자체 Thread를 만들어 이미 전달한 Record를 바꾸는 경우 이후 Pipeline에서 발생할 수 있는 문제를 방지하기 위해 만들었을 것으로 예상한다. 이 옵션이 켜져 있으면 Operator 갯수 - 1번의 데이터 복사가 반복해서 발생하기 떄문에 위와 같은 상황이 아니라면 false로 처리하는 편이 낫다(default는 true이다). execution.buffer-timeout과 Output Flink Documentation - Config 페이지에는 execution.buffer-timeout 옵션에 대한 설명이 존재한다. The maximum time frequency (milliseconds) for the flushing of the output buffers. By default the output buffers flush frequently to provide low latency and to aid smooth developer experience. Setting the parameter can result in three logical modes: A positive value triggers flushing periodically by that interval 0 triggers flushing after every record thus minimizing latency -1 ms triggers flushing only when the output buffer is full thus maximizing throughput Output Buffer의 데이터를 얼마나 자주 Flush 할 것인지에 대한 내용이다. 이 값이 작으면 Latency가 줄어들지만 Throughput 또한 줄어들 수 있다. 이 옵션은 네트워크를 통해 데이터를 전달하는 RecordWriter에서 사용된다. RecordWriter의 생성자의 timeout값으로 전달되며, 이 값은 내부적으로 사용되는 flushAlways옵션과 OutputFlusher의 Flush 주기에 영향을 미친다. 우선 flushAlways는 timeout값이 0인 경우 true, 아닐 경우 false로 설정된다. 이전 Operator의 결과 데이터를 다음 Operator로 전달하는 emit의 코드는 아래와 같다. protected void emit(T record, int targetSubpartition) throws IOException { checkErroneous(); targetPartition.emitRecord(serializeRecord(serializer, record), targetSubpartition); if (flushAlways) { targetPartition.flush(targetSubpartition); } } 전달해야하는 파티션(Operator)의 emitRecord를 통해 데이터를 전달한다. 그러나 이 과정에서는 내부 버퍼에만 데이터가 쌓일 뿐 Flush가 일어나지는 않는다. 이후 if문에서 flushAlways 여부에 따라 바로 Flush를 하는지 아닌지가 결정된다. 또한 RecordWriter에는 주기적으로 Buffer에 쌓인 데이터를 Flush하는 OutputFlusher가 존재한다. OutputFlusher의 run 구현은 아래와 같다. public void run() { try { while (running) { try { Thread.sleep(timeout); } catch (InterruptedException e) { // propagate this if we are still running, because it should not happen // in that case if (running) { throw new Exception(e); } } // any errors here should let the thread come to a halt and be // recognized by the writer flushAll(); } } catch (Throwable t) { notifyFlusherException(t); } } 무한 루프 내에서 timeout 주기로 Thread가 Sleep하는 것을 확인할 수 있다. 이후 flushAll 호출을 통해 버퍼의 데이터를 Flush 하는 것을 확인할 수 있다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/flink_output/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/flink_output/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-26T00:10:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Flink Concept - Operator 간 데이터 교환" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"개요 Flink Job의 Operator 간의 데이터 교환이 어떻게 이루어지는지 알아보고, 유의해야 할 옵션은 어떤 것이 있는지 알아보도록 한다. Flink의 Input과 Ouptut 위와 같이 3개의 Operator가 연결되어 있다고 생각해보자. 한 Operator의 출력 데이터는 다른 Operator의 입력 데이터로 사용된다. 그래프 관점에서는 Operator는 Vertex, Operator 사이의 단방향 화살표를 Edge로 표현한다. Flink에서는 Operator(Vertex)를 Input, 데이터 교환 채널(Edge)을 Output으로 추상화하여 사용한다. Input Flink에서 하나의 입력을 처리하는 Operator는 Input 인터페이스를 상속한다. public interface Input&lt;IN&gt; { void processElement(StreamRecord&lt;IN&gt; element) throws Exception; void processWatermark(Watermark mark) throws Exception; void processLatencyMarker(LatencyMarker latencyMarker) throws Exception; void setKeyContextElement(StreamRecord&lt;IN&gt; record) throws Exception; } Input을 상속하는 StreamMap의 코드는 아래와 같다. public class StreamMap&lt;IN, OUT&gt; extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt; implements OneInputStreamOperator&lt;IN, OUT&gt; { private static final long serialVersionUID = 1L; public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) { super(mapper); chainingStrategy = ChainingStrategy.ALWAYS; } @Override public void processElement(StreamRecord&lt;IN&gt; element) throws Exception { output.collect(element.replace(userFunction.map(element.getValue()))); } } StreamMap이 구현한 OneInputStreamOperator는 Input을 상속하기 때문에 결론적으로 StreamMap이 Input을 구현하는 구조가 된다. 모든 Input을 상속한 클래스들은 자신의 출력 결과를 다음 Operator(Input)에게 전달할 Output을 가지고 있다. Input은 자신이 가지고 있는 사용자 함수(Function)으로 이전 출력에서 가져온 입력 데이터(StreamRecord)를 처리한 뒤, Output의 collect를 통해 다음 출력으로 내보내게 된다. Output Flink에서 Operator가 처리한 데이터를 다음 Operator로 넘기는 역할은 Output이 처리한다. 이전 단계의 Operator가 자신이 처리한 데이터를 Output의 collect를 호출하여 전달하면, Output은 이 데이터를 자신이 가지고 있는 다음 Operator 객체의 processElement의 매개변수로 전달하여 데이터를 전달하는 과정을 거치게 된다. Operator 간의 관계(1:1인가, 1:N인가)와 동일 OperatorChain에 속하는지의 여부에 따라 세가지 Output으로 나뉘게 된다. Operator 간의 관계가 1:1인 경우 같은 OperatorChain에 속한 Operator 간 연결: ChainingOutput 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간 연결: RecordWriterOutput Operator 간의 관계가 1:N인 경우: BroadcastingOutputCollector 당연한 이야기이지만 두 Operator가 동일한 Parallelism을 가지고 있더라도, shuffle이나 disableChaining을 호출하여 서로 다른 OperatorChain으로 분리되는 경우에는 RecordWriterOutput이 사용된다. ChainingOutput ChainingOutput은 동일한 OperatorChain에 속한 두 Operator 간(1:1)의 데이터 전달에 사용된다. 네트워크를 사용하지 않고 1:1 관계의 교환이기 때문에 구현이 매우 간단하다. 이전 Operator(Input)의 processElement에서 데이터를 호출한 뒤 ChainingOutput의 collect를 호출하면 데이터 전달이 진행된다. collect은 아래와 같이 구현되어 있다. @Override public void collect(StreamRecord&lt;T&gt; record) { if (this.outputTag != null) { // we are not responsible for emitting to the main output. return; } pushToOperator(record); } 이전 Operator의 출력 데이터(record)를 매개변수로 pushToOperator를 호출하고 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 전달받은 record를 자신이 가지고 있는 input(다음 Operator)의 processElement를 호출하여 다음 Operator로 데이터를 전달하게 된다. RecordWriterOutput ChainingOutput은 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간의 데이터 교환에 사용된다. 네트워크를 사용하며, broadcast를 사용했는지 아닌지 여부에 따라 실제로 다음 데이터로 전달하는 객체인 RecordWriter 종류가 달라지게 된다. broadcast를 사용하지 않은 경우 ChannelSelectorRecordWriter가 사용된다. Parallelism 설정과 shuffle, rebalance, disableChaining 호출에 따라 ChannelSelector의 타입이 달라지게 된다. broadcast를 사용하는 경우 BroadcastRecordWriter가 사용된다. BroadcastingOutputCollector 하나의 Operator에서 2개 이상의 Operator로 데이터를 전달하는 경우에 사용된다. 내부적으로 Output 배열이 있어 각 Operator 간의 관계에 따라 ChainingOutput, RecordWriterOutput을 가지게 된다. 더 알아보기 pipeline.object-reuse 옵션과 Output Flink Documentation - Config 페이지에는 pipeline.object-reuse 옵션에 대한 설명이 존재한다. When enabled objects that Flink internally uses for deserialization and passing data to user-code functions will be reused. Keep in mind that this can lead to bugs when the user-code function of an operation is not aware of this behaviour. pipeline.object-reuse 옵션을 사용하면 Flink는 User Function으로 전달하는 데이터를 재사용하게 된다. Output 객체를 만들 때, 이 옵션의 활성 여부에 따라 다른 클래스의 Output 객체가 만들어진다. 같은 OperatorChain에 속하는 Operator를 연결하는 Output을 만들어내는 코드를 보자. if (containingTask.getExecutionConfig().isObjectReuseEnabled()) { currentOperatorOutput = new ChainingOutput&lt;&gt;(operator, this, outputTag); } else { TypeSerializer&lt;IN&gt; inSerializer = operatorConfig.getTypeSerializerIn1(userCodeClassloader); currentOperatorOutput = new CopyingChainingOutput&lt;&gt;(operator, inSerializer, outputTag, this); } pipeline.object-reuse 옵션이 활성화되어 있는 경우 초기화되는 객체가 ChainingOutput 타입이고, 활성화 되어 있지 않은 경우 CopyingChainingOutput인 것을 확인할 수 있다. 이 둘이 어떻게 다른지는 다음 Operator로 데이터를 전달하는 pushToOperator 구현을 보면 알 수 있다. ChainingOutput의 경우 아래와 같이 이전 Operator가 전달한 데이터를 별다른 변경 없이 다음 Operator로 전달하는 것을 볼 수 있다. protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); input.setKeyContextElement(castRecord); input.processElement(castRecord); } catch (Exception e) { throw new ExceptionInChainedOperatorException(e); } } 그러나 CopyingChainingOutput의 경우 중간에 이전 Record를 Deep Copy하는 코드(serializer.copy)가 호출되어 원본이 아닌 복사된 객체를 다음 Operator로 전달하는 것을 볼 수 있다. @Override protected &lt;X&gt; void pushToOperator(StreamRecord&lt;X&gt; record) { try { // we know that the given outputTag matches our OutputTag so the record // must be of the type that our operator (and Serializer) expects. @SuppressWarnings(&quot;unchecked&quot;) StreamRecord&lt;T&gt; castRecord = (StreamRecord&lt;T&gt;) record; numRecordsIn.inc(); StreamRecord&lt;T&gt; copy = castRecord.copy(serializer.copy(castRecord.getValue())); input.setKeyContextElement(copy); input.processElement(copy); ... } 아마 이 옵션은 사용자가 자체 Thread를 만들어 이미 전달한 Record를 바꾸는 경우 이후 Pipeline에서 발생할 수 있는 문제를 방지하기 위해 만들었을 것으로 예상한다. 이 옵션이 켜져 있으면 Operator 갯수 - 1번의 데이터 복사가 반복해서 발생하기 떄문에 위와 같은 상황이 아니라면 false로 처리하는 편이 낫다(default는 true이다). execution.buffer-timeout과 Output Flink Documentation - Config 페이지에는 execution.buffer-timeout 옵션에 대한 설명이 존재한다. The maximum time frequency (milliseconds) for the flushing of the output buffers. By default the output buffers flush frequently to provide low latency and to aid smooth developer experience. Setting the parameter can result in three logical modes: A positive value triggers flushing periodically by that interval 0 triggers flushing after every record thus minimizing latency -1 ms triggers flushing only when the output buffer is full thus maximizing throughput Output Buffer의 데이터를 얼마나 자주 Flush 할 것인지에 대한 내용이다. 이 값이 작으면 Latency가 줄어들지만 Throughput 또한 줄어들 수 있다. 이 옵션은 네트워크를 통해 데이터를 전달하는 RecordWriter에서 사용된다. RecordWriter의 생성자의 timeout값으로 전달되며, 이 값은 내부적으로 사용되는 flushAlways옵션과 OutputFlusher의 Flush 주기에 영향을 미친다. 우선 flushAlways는 timeout값이 0인 경우 true, 아닐 경우 false로 설정된다. 이전 Operator의 결과 데이터를 다음 Operator로 전달하는 emit의 코드는 아래와 같다. protected void emit(T record, int targetSubpartition) throws IOException { checkErroneous(); targetPartition.emitRecord(serializeRecord(serializer, record), targetSubpartition); if (flushAlways) { targetPartition.flush(targetSubpartition); } } 전달해야하는 파티션(Operator)의 emitRecord를 통해 데이터를 전달한다. 그러나 이 과정에서는 내부 버퍼에만 데이터가 쌓일 뿐 Flush가 일어나지는 않는다. 이후 if문에서 flushAlways 여부에 따라 바로 Flush를 하는지 아닌지가 결정된다. 또한 RecordWriter에는 주기적으로 Buffer에 쌓인 데이터를 Flush하는 OutputFlusher가 존재한다. OutputFlusher의 run 구현은 아래와 같다. public void run() { try { while (running) { try { Thread.sleep(timeout); } catch (InterruptedException e) { // propagate this if we are still running, because it should not happen // in that case if (running) { throw new Exception(e); } } // any errors here should let the thread come to a halt and be // recognized by the writer flushAll(); } } catch (Throwable t) { notifyFlusherException(t); } } 무한 루프 내에서 timeout 주기로 Thread가 Sleep하는 것을 확인할 수 있다. 이후 flushAll 호출을 통해 버퍼의 데이터를 Flush 하는 것을 확인할 수 있다.","url":"https://leeyh0216.github.io/posts/flink_output/","@type":"BlogPosting","headline":"Flink Concept - Operator 간 데이터 교환","dateModified":"2021-03-26T00:10:00+09:00","datePublished":"2021-03-26T00:10:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/flink_output/"},"@context":"https://schema.org"}</script><title>Flink Concept - Operator 간 데이터 교환 | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Flink Concept - Operator 간 데이터 교환</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Flink Concept - Operator 간 데이터 교환</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Mar 26, 2021, 12:10 AM +0900" prep="on" > Mar 26, 2021 <i class="unloaded">2021-03-26T00:10:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2223 words">12 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="개요">개요</h1><p>Flink Job의 Operator 간의 데이터 교환이 어떻게 이루어지는지 알아보고, 유의해야 할 옵션은 어떤 것이 있는지 알아보도록 한다.</p><h2 id="flink의-input과-ouptut">Flink의 Input과 Ouptut</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../assets/flink/ChainedOperators.png" alt="Chained Operators" /></p><p>위와 같이 3개의 Operator가 연결되어 있다고 생각해보자. 한 Operator의 출력 데이터는 다른 Operator의 입력 데이터로 사용된다. 그래프 관점에서는 Operator는 Vertex, Operator 사이의 단방향 화살표를 Edge로 표현한다.</p><p>Flink에서는 Operator(Vertex)를 <code class="language-plaintext highlighter-rouge">Input</code>, 데이터 교환 채널(Edge)을 <code class="language-plaintext highlighter-rouge">Output</code>으로 추상화하여 사용한다.</p><h3 id="input">Input</h3><p>Flink에서 하나의 입력을 처리하는 Operator는 <code class="language-plaintext highlighter-rouge">Input</code> 인터페이스를 상속한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Input</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">&gt;</span> <span class="n">element</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">processWatermark</span><span class="o">(</span><span class="nc">Watermark</span> <span class="n">mark</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">processLatencyMarker</span><span class="o">(</span><span class="nc">LatencyMarker</span> <span class="n">latencyMarker</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">setKeyContextElement</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">Input</code>을 상속하는 <code class="language-plaintext highlighter-rouge">StreamMap</code>의 코드는 아래와 같다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StreamMap</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">,</span> <span class="no">OUT</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="no">OUT</span><span class="o">,</span> <span class="nc">MapFunction</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">,</span> <span class="no">OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="nc">OneInputStreamOperator</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">,</span> <span class="no">OUT</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">StreamMap</span><span class="o">(</span><span class="nc">MapFunction</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">,</span> <span class="no">OUT</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">mapper</span><span class="o">);</span>
        <span class="n">chainingStrategy</span> <span class="o">=</span> <span class="nc">ChainingStrategy</span><span class="o">.</span><span class="na">ALWAYS</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">&gt;</span> <span class="n">element</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">output</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">userFunction</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">getValue</span><span class="o">())));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">StreamMap</code>이 구현한 <code class="language-plaintext highlighter-rouge">OneInputStreamOperator</code>는 <code class="language-plaintext highlighter-rouge">Input</code>을 상속하기 때문에 결론적으로 <code class="language-plaintext highlighter-rouge">StreamMap</code>이 <code class="language-plaintext highlighter-rouge">Input</code>을 구현하는 구조가 된다.</p><p>모든 <code class="language-plaintext highlighter-rouge">Input</code>을 상속한 클래스들은 자신의 출력 결과를 다음 <code class="language-plaintext highlighter-rouge">Operator</code>(<code class="language-plaintext highlighter-rouge">Input</code>)에게 전달할 <code class="language-plaintext highlighter-rouge">Output</code>을 가지고 있다.</p><p><code class="language-plaintext highlighter-rouge">Input</code>은 자신이 가지고 있는 사용자 함수(Function)으로 이전 출력에서 가져온 입력 데이터(<code class="language-plaintext highlighter-rouge">StreamRecord</code>)를 처리한 뒤, <code class="language-plaintext highlighter-rouge">Output</code>의 <code class="language-plaintext highlighter-rouge">collect</code>를 통해 다음 출력으로 내보내게 된다.</p><h3 id="output">Output</h3><p>Flink에서 Operator가 처리한 데이터를 다음 Operator로 넘기는 역할은 <code class="language-plaintext highlighter-rouge">Output</code>이 처리한다.</p><p>이전 단계의 Operator가 자신이 처리한 데이터를 <code class="language-plaintext highlighter-rouge">Output</code>의 <code class="language-plaintext highlighter-rouge">collect</code>를 호출하여 전달하면, <code class="language-plaintext highlighter-rouge">Output</code>은 이 데이터를 자신이 가지고 있는 다음 <code class="language-plaintext highlighter-rouge">Operator</code> 객체의 <code class="language-plaintext highlighter-rouge">processElement</code>의 매개변수로 전달하여 데이터를 전달하는 과정을 거치게 된다.</p><p>Operator 간의 관계(1:1인가, 1:N인가)와 동일 OperatorChain에 속하는지의 여부에 따라 세가지 <code class="language-plaintext highlighter-rouge">Output</code>으로 나뉘게 된다.</p><ul><li>Operator 간의 관계가 1:1인 경우<ul><li>같은 OperatorChain에 속한 Operator 간 연결: <code class="language-plaintext highlighter-rouge">ChainingOutput</code><li>한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간 연결: <code class="language-plaintext highlighter-rouge">RecordWriterOutput</code></ul><li>Operator 간의 관계가 1:N인 경우: <code class="language-plaintext highlighter-rouge">BroadcastingOutputCollector</code></ul><p>당연한 이야기이지만 두 Operator가 동일한 Parallelism을 가지고 있더라도, <code class="language-plaintext highlighter-rouge">shuffle</code>이나 <code class="language-plaintext highlighter-rouge">disableChaining</code>을 호출하여 서로 다른 OperatorChain으로 분리되는 경우에는 <code class="language-plaintext highlighter-rouge">RecordWriterOutput</code>이 사용된다.</p><h4 id="chainingoutput">ChainingOutput</h4><p><code class="language-plaintext highlighter-rouge">ChainingOutput</code>은 동일한 OperatorChain에 속한 두 Operator 간(1:1)의 데이터 전달에 사용된다. 네트워크를 사용하지 않고 1:1 관계의 교환이기 때문에 구현이 매우 간단하다.</p><p>이전 Operator(<code class="language-plaintext highlighter-rouge">Input</code>)의 <code class="language-plaintext highlighter-rouge">processElement</code>에서 데이터를 호출한 뒤 <code class="language-plaintext highlighter-rouge">ChainingOutput</code>의 <code class="language-plaintext highlighter-rouge">collect</code>를 호출하면 데이터 전달이 진행된다. <code class="language-plaintext highlighter-rouge">collect</code>은 아래와 같이 구현되어 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">outputTag</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// we are not responsible for emitting to the main output.
</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">pushToOperator</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>이전 Operator의 출력 데이터(record)를 매개변수로 <code class="language-plaintext highlighter-rouge">pushToOperator</code>를 호출하고 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">pushToOperator</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// we know that the given outputTag matches our OutputTag so the record
</span>
    <span class="c1">// must be of the type that our operator expects.
</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">castRecord</span> <span class="o">=</span> <span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="n">record</span><span class="o">;</span>

    <span class="n">numRecordsIn</span><span class="o">.</span><span class="na">inc</span><span class="o">();</span>
    <span class="n">input</span><span class="o">.</span><span class="na">setKeyContextElement</span><span class="o">(</span><span class="n">castRecord</span><span class="o">);</span>
    <span class="n">input</span><span class="o">.</span><span class="na">processElement</span><span class="o">(</span><span class="n">castRecord</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ExceptionInChainedOperatorException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>전달받은 record를 자신이 가지고 있는 <code class="language-plaintext highlighter-rouge">input</code>(다음 Operator)의 <code class="language-plaintext highlighter-rouge">processElement</code>를 호출하여 다음 Operator로 데이터를 전달하게 된다.</p><h4 id="recordwriteroutput">RecordWriterOutput</h4><p><code class="language-plaintext highlighter-rouge">ChainingOutput</code>은 한 OperatorChain의 마지막 Operator와 다음 OperatorChain의 첫번째 Operator 간의 데이터 교환에 사용된다. 네트워크를 사용하며, <code class="language-plaintext highlighter-rouge">broadcast</code>를 사용했는지 아닌지 여부에 따라 실제로 다음 데이터로 전달하는 객체인 <code class="language-plaintext highlighter-rouge">RecordWriter</code> 종류가 달라지게 된다.</p><ul><li><code class="language-plaintext highlighter-rouge">broadcast</code>를 사용하지 않은 경우<ul><li><code class="language-plaintext highlighter-rouge">ChannelSelectorRecordWriter</code>가 사용된다.<li>Parallelism 설정과 <code class="language-plaintext highlighter-rouge">shuffle</code>, <code class="language-plaintext highlighter-rouge">rebalance</code>, <code class="language-plaintext highlighter-rouge">disableChaining</code> 호출에 따라 ChannelSelector의 타입이 달라지게 된다.</ul><li><code class="language-plaintext highlighter-rouge">broadcast</code>를 사용하는 경우<ul><li><code class="language-plaintext highlighter-rouge">BroadcastRecordWriter</code>가 사용된다.</ul></ul><h4 id="broadcastingoutputcollector">BroadcastingOutputCollector</h4><p>하나의 Operator에서 2개 이상의 Operator로 데이터를 전달하는 경우에 사용된다.</p><p>내부적으로 Output 배열이 있어 각 Operator 간의 관계에 따라 <code class="language-plaintext highlighter-rouge">ChainingOutput</code>, <code class="language-plaintext highlighter-rouge">RecordWriterOutput</code>을 가지게 된다.</p><h2 id="더-알아보기">더 알아보기</h2><h3 id="pipelineobject-reuse-옵션과-output"><code class="language-plaintext highlighter-rouge">pipeline.object-reuse</code> 옵션과 Output</h3><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html">Flink Documentation - Config</a> 페이지에는 <code class="language-plaintext highlighter-rouge">pipeline.object-reuse</code> 옵션에 대한 설명이 존재한다.</p><p>When enabled objects that Flink internally uses for deserialization and passing data to user-code functions will be reused. Keep in mind that this can lead to bugs when the user-code function of an operation is not aware of this behaviour.</p><blockquote><p><code class="language-plaintext highlighter-rouge">pipeline.object-reuse</code> 옵션을 사용하면 Flink는 User Function으로 전달하는 데이터를 재사용하게 된다.</p></blockquote><p><code class="language-plaintext highlighter-rouge">Output</code> 객체를 만들 때, 이 옵션의 활성 여부에 따라 다른 클래스의 <code class="language-plaintext highlighter-rouge">Output</code> 객체가 만들어진다. 같은 OperatorChain에 속하는 Operator를 연결하는 <code class="language-plaintext highlighter-rouge">Output</code>을 만들어내는 코드를 보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">containingTask</span><span class="o">.</span><span class="na">getExecutionConfig</span><span class="o">().</span><span class="na">isObjectReuseEnabled</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">currentOperatorOutput</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ChainingOutput</span><span class="o">&lt;&gt;(</span><span class="n">operator</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="n">outputTag</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="nc">TypeSerializer</span><span class="o">&lt;</span><span class="no">IN</span><span class="o">&gt;</span> <span class="n">inSerializer</span> <span class="o">=</span>
    <span class="n">operatorConfig</span><span class="o">.</span><span class="na">getTypeSerializerIn1</span><span class="o">(</span><span class="n">userCodeClassloader</span><span class="o">);</span>
  <span class="n">currentOperatorOutput</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">CopyingChainingOutput</span><span class="o">&lt;&gt;(</span><span class="n">operator</span><span class="o">,</span> <span class="n">inSerializer</span><span class="o">,</span> <span class="n">outputTag</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">pipeline.object-reuse</code> 옵션이 활성화되어 있는 경우 초기화되는 객체가 <code class="language-plaintext highlighter-rouge">ChainingOutput</code> 타입이고, 활성화 되어 있지 않은 경우 <code class="language-plaintext highlighter-rouge">CopyingChainingOutput</code>인 것을 확인할 수 있다.</p><p>이 둘이 어떻게 다른지는 다음 Operator로 데이터를 전달하는 <code class="language-plaintext highlighter-rouge">pushToOperator</code> 구현을 보면 알 수 있다. <code class="language-plaintext highlighter-rouge">ChainingOutput</code>의 경우 아래와 같이 이전 Operator가 전달한 데이터를 별다른 변경 없이 다음 Operator로 전달하는 것을 볼 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">pushToOperator</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// we know that the given outputTag matches our OutputTag so the record
</span>
    <span class="c1">// must be of the type that our operator expects.
</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">castRecord</span> <span class="o">=</span> <span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="n">record</span><span class="o">;</span>

    <span class="n">numRecordsIn</span><span class="o">.</span><span class="na">inc</span><span class="o">();</span>
    <span class="n">input</span><span class="o">.</span><span class="na">setKeyContextElement</span><span class="o">(</span><span class="n">castRecord</span><span class="o">);</span>
    <span class="n">input</span><span class="o">.</span><span class="na">processElement</span><span class="o">(</span><span class="n">castRecord</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ExceptionInChainedOperatorException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>그러나 <code class="language-plaintext highlighter-rouge">CopyingChainingOutput</code>의 경우 중간에 이전 Record를 Deep Copy하는 코드(<code class="language-plaintext highlighter-rouge">serializer.copy</code>)가 호출되어 원본이 아닌 복사된 객체를 다음 Operator로 전달하는 것을 볼 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">pushToOperator</span><span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">X</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="c1">// we know that the given outputTag matches our OutputTag so the record
</span>
      <span class="c1">// must be of the type that our operator (and Serializer) expects.
</span>
      <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
      <span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">castRecord</span> <span class="o">=</span> <span class="o">(</span><span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="n">record</span><span class="o">;</span>

      <span class="n">numRecordsIn</span><span class="o">.</span><span class="na">inc</span><span class="o">();</span>
      <span class="nc">StreamRecord</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">castRecord</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">serializer</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">castRecord</span><span class="o">.</span><span class="na">getValue</span><span class="o">()));</span>
      <span class="n">input</span><span class="o">.</span><span class="na">setKeyContextElement</span><span class="o">(</span><span class="n">copy</span><span class="o">);</span>
      <span class="n">input</span><span class="o">.</span><span class="na">processElement</span><span class="o">(</span><span class="n">copy</span><span class="o">);</span>
  <span class="o">...</span>
<span class="o">}</span></code></pre></figure><p>아마 이 옵션은 사용자가 자체 Thread를 만들어 이미 전달한 Record를 바꾸는 경우 이후 Pipeline에서 발생할 수 있는 문제를 방지하기 위해 만들었을 것으로 예상한다.</p><p>이 옵션이 켜져 있으면 Operator 갯수 - 1번의 데이터 복사가 반복해서 발생하기 떄문에 위와 같은 상황이 아니라면 false로 처리하는 편이 낫다(default는 true이다).</p><h3 id="executionbuffer-timeout과-output"><code class="language-plaintext highlighter-rouge">execution.buffer-timeout</code>과 Output</h3><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html">Flink Documentation - Config</a> 페이지에는 <code class="language-plaintext highlighter-rouge">execution.buffer-timeout</code> 옵션에 대한 설명이 존재한다.</p><p>The maximum time frequency (milliseconds) for the flushing of the output buffers. By default the output buffers flush frequently to provide low latency and to aid smooth developer experience. Setting the parameter can result in three logical modes: A positive value triggers flushing periodically by that interval 0 triggers flushing after every record thus minimizing latency -1 ms triggers flushing only when the output buffer is full thus maximizing throughput</p><blockquote><p>Output Buffer의 데이터를 얼마나 자주 Flush 할 것인지에 대한 내용이다. 이 값이 작으면 Latency가 줄어들지만 Throughput 또한 줄어들 수 있다.</p></blockquote><p>이 옵션은 네트워크를 통해 데이터를 전달하는 <code class="language-plaintext highlighter-rouge">RecordWriter</code>에서 사용된다. <code class="language-plaintext highlighter-rouge">RecordWriter</code>의 생성자의 <code class="language-plaintext highlighter-rouge">timeout</code>값으로 전달되며, 이 값은 내부적으로 사용되는 <code class="language-plaintext highlighter-rouge">flushAlways</code>옵션과 <code class="language-plaintext highlighter-rouge">OutputFlusher</code>의 Flush 주기에 영향을 미친다.</p><p>우선 <code class="language-plaintext highlighter-rouge">flushAlways</code>는 <code class="language-plaintext highlighter-rouge">timeout</code>값이 0인 경우 true, 아닐 경우 false로 설정된다. 이전 Operator의 결과 데이터를 다음 Operator로 전달하는 <code class="language-plaintext highlighter-rouge">emit</code>의 코드는 아래와 같다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">emit</span><span class="o">(</span><span class="no">T</span> <span class="n">record</span><span class="o">,</span> <span class="kt">int</span> <span class="n">targetSubpartition</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
  <span class="n">checkErroneous</span><span class="o">();</span>

  <span class="n">targetPartition</span><span class="o">.</span><span class="na">emitRecord</span><span class="o">(</span><span class="n">serializeRecord</span><span class="o">(</span><span class="n">serializer</span><span class="o">,</span> <span class="n">record</span><span class="o">),</span> <span class="n">targetSubpartition</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">flushAlways</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">targetPartition</span><span class="o">.</span><span class="na">flush</span><span class="o">(</span><span class="n">targetSubpartition</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>전달해야하는 파티션(Operator)의 <code class="language-plaintext highlighter-rouge">emitRecord</code>를 통해 데이터를 전달한다. 그러나 이 과정에서는 내부 버퍼에만 데이터가 쌓일 뿐 Flush가 일어나지는 않는다. 이후 if문에서 <code class="language-plaintext highlighter-rouge">flushAlways</code> 여부에 따라 바로 Flush를 하는지 아닌지가 결정된다.</p><p>또한 <code class="language-plaintext highlighter-rouge">RecordWriter</code>에는 주기적으로 Buffer에 쌓인 데이터를 Flush하는 <code class="language-plaintext highlighter-rouge">OutputFlusher</code>가 존재한다. <code class="language-plaintext highlighter-rouge">OutputFlusher</code>의 <code class="language-plaintext highlighter-rouge">run</code> 구현은 아래와 같다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">timeout</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// propagate this if we are still running, because it should not happen
</span>
        <span class="c1">// in that case
</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="c1">// any errors here should let the thread come to a halt and be
</span>
      <span class="c1">// recognized by the writer
</span>
      <span class="n">flushAll</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">notifyFlusherException</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>무한 루프 내에서 <code class="language-plaintext highlighter-rouge">timeout</code> 주기로 Thread가 Sleep하는 것을 확인할 수 있다. 이후 <code class="language-plaintext highlighter-rouge">flushAll</code> 호출을 통해 버퍼의 데이터를 Flush 하는 것을 확인할 수 있다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/flink/'>flink</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Flink Concept - Operator 간 데이터 교환 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/flink_output/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Flink Concept - Operator 간 데이터 교환 - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/flink_output/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Flink Concept - Operator 간 데이터 교환 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/flink_output/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/flink_concepts_1/"><div class="card-body"> <span class="timeago small" > Aug 2, 2020 <i class="unloaded">2020-08-02T18:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Flink Concept - Operator, Task, Parallelism</h3><div class="text-muted small"><p> 개요 진행 중인 프로젝트에서 Flink를 사용할 기회가 생겼다. 처음 코드를 작성할 때는 ‘Spark과 거의 비슷하네?’ 라는 생각을 했는데, 사용하면 할 수록 다른 부분을 많이 느끼게 되어 정리 차 글을 작성한다. 아래 자료들을 참고하여 작성하였다. Apache Flink - Flink Architecture 삼성 SDS - 연산 처리...</p></div></div></a></div><div class="card"> <a href="/posts/flink_checkpoint_1/"><div class="card-body"> <span class="timeago small" > Mar 1, 2021 <i class="unloaded">2021-03-01T17:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Flink Concept - Checkpointing(1)</h3><div class="text-muted small"><p> 이 글은 Coursera - Cloud Computing Concepts, Part 1을 참고하여 작성하였습니다. 개요 스트리밍 애플리케이션은 매우 긴 시간 동안 수행되며 내부적으로 상태를 가지고 있다. 예를 들어 아래와 같이 (사용자, 페이지 체류 시간)이 입력으로 들어오고, 평균 사용자 체류 시간을 계산하는 애플리케이션이 있다고 가정하자...</p></div></div></a></div><div class="card"> <a href="/posts/flink_object_reuse/"><div class="card-body"> <span class="timeago small" > Mar 27, 2021 <i class="unloaded">2021-03-27T00:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Flink Concept - pipeline.object_reuse</h3><div class="text-muted small"><p> 개요 이전 글에서 pipeline.object_reuse 옵션에 대해 설명하였다. 이 옵션을 사용하면 안되는 경우에 대해서는 Flink 공식 문서에 나와 있지 않으며, 이전 글에서도 제대로 설명하지 못했다. 이번 글에서는 언제 이 옵션을 사용하면 안되는지와 그럼에도 불구하고 옵션을 적용하고 싶은 경우 우회하는 방법에 대해 알아보도록 한다. pip...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/kerberos_concept/" class="btn btn-outline-primary" prompt="Older"><p>Kerberos 개념</p></a> <a href="/posts/lead_lag_function/" class="btn btn-outline-primary" prompt="Newer"><p>LEAD, LAG 함수</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
