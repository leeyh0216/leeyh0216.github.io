<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - The IoC Container(3)" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다." /><meta property="og:description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-core-3/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-core-3/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-12-03T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - The IoC Container(3)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다.","url":"https://leeyh0216.github.io/posts/spring-core-3/","@type":"BlogPosting","headline":"Spring Core Technologies - The IoC Container(3)","dateModified":"2018-12-03T10:00:00+09:00","datePublished":"2018-12-03T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-core-3/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - The IoC Container(3) | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - The IoC Container(3)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - The IoC Container(3)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 3, 2018, 10:00 AM +0900" prep="on" > Dec 3, 2018 <i class="unloaded">2018-12-03T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2115 words">11 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="the-ioc-container">The IoC Container</h1><h2 id="introduction-to-the-spring-ioc-container-and-beans">Introduction to the Spring IoC Container and Beans</h2><h3 id="bean-dependencies">Bean Dependencies</h3><p>Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자.</p><p>MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다)</p><p>이러한 경우 아래와 같은 코드를 작성해야 할까?</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.beandependencies</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRepository</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p><code class="language-plaintext highlighter-rouge">getMyService</code> 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 <code class="language-plaintext highlighter-rouge">getMyService</code> 함수 또한 비대해진다.</p><p>ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다.</p><p>즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, <code class="language-plaintext highlighter-rouge">getMyService</code> 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 <code class="language-plaintext highlighter-rouge">MyRepository</code> Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, <code class="language-plaintext highlighter-rouge">MyService</code> Bean 초기화 함수인 <code class="language-plaintext highlighter-rouge">getMyService</code>의 인수로 이미 Bean으로 생성되어 있는 <code class="language-plaintext highlighter-rouge">MyRepository</code> 객체를 주입시켜준다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.beandependencies</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyRepository</span> <span class="nf">getMyRepository</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyRepository</span><span class="o">();</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">(</span><span class="n">myRepository</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><h3 id="receiving-lifecycle-callbacks">Receiving Lifecycle Callbacks</h3><p>@Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다.</p><p>또한 Spring Framework의 <code class="language-plaintext highlighter-rouge">InitializingBean</code>, <code class="language-plaintext highlighter-rouge">DisposableBean</code>, <code class="language-plaintext highlighter-rouge">Lifecycle</code>을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다.</p><h4 id="initializingbean을-상속하는-방법">InitializingBean을 상속하는 방법</h4><p><code class="language-plaintext highlighter-rouge">InitializingBean</code>는 Bean이 <code class="language-plaintext highlighter-rouge">BeanFactory</code>에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다.</p><p>그렇다면 생성자와 다른 점은 무엇인가?</p><p>객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. <code class="language-plaintext highlighter-rouge">InitializingBean</code>은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다.</p><p><code class="language-plaintext highlighter-rouge">InitializingBean</code> 인터페이스를 상속받은 클래스는 <code class="language-plaintext highlighter-rouge">void afterPropertiesSet()</code> 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다.</p><p>다루지는 않았었지만 <code class="language-plaintext highlighter-rouge">@Autowired</code> 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다.</p><p>아래와 같은 MyService 클래스가 있다고 생각해보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"afterPropertiesSet Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다.</p><ol><li><code class="language-plaintext highlighter-rouge">MyService</code> 클래스의 생성자<li><code class="language-plaintext highlighter-rouge">setMyRepository</code> 메서드<li><code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 메서드</ol><p>즉, <code class="language-plaintext highlighter-rouge">InitializingBean</code> 인터페이스의 <code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다.</p><h4 id="postconstruct-어노테이션을-붙인-메서드를-만드는-방법"><code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션을 붙인 메서드를 만드는 방법</h4><p>Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다.</p><ol><li><code class="language-plaintext highlighter-rouge">MyService</code> 클래스의 생성자<li><code class="language-plaintext highlighter-rouge">setMyRepository</code> 메서드<li><code class="language-plaintext highlighter-rouge">postConstruct</code> 메서드</ol><p>그렇다면 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드에 인자를 추가해보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(</span><span class="nc">String</span> <span class="n">author</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>호출해보면 아래와 같은 오류가 발생한다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getMyService' defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String)</code></pre></figure><p><em>Lifecycle method annotation requires a no-arg method</em>. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다.</p><h4 id="postconstruct-vs-afterpropertiesset"><code class="language-plaintext highlighter-rouge">@PostConstruct</code> vs <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code></h4><p>그렇다면 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>와 <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 둘 모두를 구현하는 경우 어떻게 동작할까?</p><p>아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"afterPropertiesSet Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>호출 결과 아래와 같은 로그가 발생하였다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">MyService Constructor Called
setMyRepository Called
postConstruct Called
afterPropertiesSet Called</code></pre></figure><p>즉, <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드가 <code class="language-plaintext highlighter-rouge">afterPropertiesSet</code> 메서드보다 우선순위가 높은 것을 확인할 수 있다.</p><h4 id="disposablebean-인터페이스를-상속하는-방법"><code class="language-plaintext highlighter-rouge">DisposableBean</code> 인터페이스를 상속하는 방법</h4><p>Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. <code class="language-plaintext highlighter-rouge">void destroy()</code> 메소드를 구현해야 한다.</p><p>아래와 같이 <code class="language-plaintext highlighter-rouge">DisposableBean</code> 인터페이스를 구현한 MyService 클래스를 구현해보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">DisposableBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다.</p><p>ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 <code class="language-plaintext highlighter-rouge">registerShutdownHook()</code> 메서드를 호출해주어야 한다.</p><p>즉, 변경된 Application 클래스 코드는 아래와 같다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.AbstractApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>

        <span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">).</span><span class="na">registerShutdownHook</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다.</p><h4 id="predestroy-어노테이션을-붙인-메서드를-만드는-방법"><code class="language-plaintext highlighter-rouge">@PreDestroy</code> 어노테이션을 붙인 메서드를 만드는 방법</h4><p>Bean 클래스 내에 <code class="language-plaintext highlighter-rouge">@PreDestroy</code> 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) <code class="language-plaintext highlighter-rouge">@PreDestory</code> 어노테이션을 붙인 함수를 호출하게 된다.</p><p>아래와 같이 MyService에 <code class="language-plaintext highlighter-rouge">@PreDestory</code> 어노테이션이 붙은 메서드를 구현해보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다.</p><h4 id="predestory-vs-destroy"><code class="language-plaintext highlighter-rouge">@PreDestory</code> vs <code class="language-plaintext highlighter-rouge">destroy()</code></h4><p>그렇다면 <code class="language-plaintext highlighter-rouge">@PostConstruct</code>와 <code class="language-plaintext highlighter-rouge">afterPropertiesSet()</code> 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">DisposableBean</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preDestory</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"preDestroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>호출 결과 아래와 같은 로그가 발생하였다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">preDestory Called
destroy Called</code></pre></figure><p>즉, <code class="language-plaintext highlighter-rouge">@PreDestory</code> 어노테이션이 <code class="language-plaintext highlighter-rouge">destroy()</code> 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다.</p><p><strong>결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다.</strong></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/spring/'>spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - The IoC Container(3) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - The IoC Container(3) - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-core-3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - The IoC Container(3) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-3/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-core-2/"><div class="card-body"> <span class="timeago small" > Nov 29, 2018 <i class="unloaded">2018-11-29T21:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(2)</h3><div class="text-muted small"><p> The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에...</p></div></div></a></div><div class="card"> <a href="/posts/heap-and-gc/"><div class="card-body"> <span class="timeago small" > Jul 14 <i class="unloaded">2024-07-14T17:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM Heap과 GC를 다른 관점에서 바라보기</h3><div class="text-muted small"><p> 개요 Garbage Collection을 검색해보면 대부분의 글이 특정 GC(CMS, G1, Z 등)의 배경이 되는 이론(ex. Generational Collection Theory)이나, 알고리즘(ex. Mark-Sweep), 튜닝 등에 대한 내용을 다루고 있다. 그리고 해당 이론에 근거하여 Heap 메모리의 구조를 설명하다보니, Heap 영역을...</p></div></div></a></div><div class="card"> <a href="/posts/protobuf_2_5_build/"><div class="card-body"> <span class="timeago small" > Mar 10 <i class="unloaded">2024-03-10T12:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>protobuf 2.5 빌드하기(Apple Silicon)</h3><div class="text-muted small"><p> 이 문제는 Apple Silicon(M1, M2, M3 등)에서만 발생합니다. Ubuntu나 Intel Mac에서는 발생하지 않을 수 있음을 유의하시기 바랍니다. Hadoop 3.2.2 버전을 빌드하려다보니, 아래와 같은 메시지가 발생하며 빌드에 실패하였다. 1 [ERROR] Failed to execute goal org.apache.ha...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-core-2/" class="btn btn-outline-primary" prompt="Older"><p>Spring Core Technologies - The IoC Container(2)</p></a> <a href="/posts/ioc_and_di_pattern/" class="btn btn-outline-primary" prompt="Newer"><p>Inversion of Control Containers and the Dependency Injection pattern</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
