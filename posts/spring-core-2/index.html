<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - The IoC Container(2)" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다." /><meta property="og:description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-core-2/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-core-2/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-11-29T21:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - The IoC Container(2)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다.","url":"https://leeyh0216.github.io/posts/spring-core-2/","@type":"BlogPosting","headline":"Spring Core Technologies - The IoC Container(2)","dateModified":"2018-11-29T21:00:00+09:00","datePublished":"2018-11-29T21:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-core-2/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - The IoC Container(2) | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - The IoC Container(2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - The IoC Container(2)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 29, 2018, 9:00 PM +0900" prep="on" > Nov 29, 2018 <i class="unloaded">2018-11-29T21:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2647 words">14 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="the-ioc-container">The IoC Container</h1><h2 id="introduction-to-the-spring-ioc-container-and-beans">Introduction to the Spring IoC Container and Beans</h2><h3 id="bean-선언-시의-interface-활용">Bean 선언 시의 Interface 활용</h3><p>Bean 객체를 초기화하여 반환하는 메소드(<code class="language-plaintext highlighter-rouge">@Bean</code> 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다.</p><p>해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다.</p><p>먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">();</span>
    
<span class="o">}</span></code></pre></figure><p>위의 인터페이스를 상속한 MyServiceV1을 구현한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyServiceV1</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다.</p><p>이를 테스트하는 Application 클래스를 아래와 같이 생성한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>실행 결과는 아래와 같다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence
21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence
...생략
21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'getMyService'
My Service: MY_SERVICE_V1</code></pre></figure><p>위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다.</p><p>아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고,</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV2</span> <span class="kd">implements</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V2"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV2</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyServiceV2</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.147</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">env</span><span class="o">.</span><span class="na">StandardEnvironment</span> <span class="o">-</span> <span class="nc">Adding</span> <span class="o">[</span><span class="n">systemProperties</span><span class="o">]</span> <span class="nc">PropertySource</span> <span class="n">with</span> <span class="n">lowest</span> <span class="n">search</span> <span class="n">precedence</span>
<span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.157</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">env</span><span class="o">.</span><span class="na">StandardEnvironment</span> <span class="o">-</span> <span class="nc">Adding</span> <span class="o">[</span><span class="n">systemEnvironment</span><span class="o">]</span> <span class="nc">PropertySource</span> <span class="n">with</span> <span class="n">lowest</span> <span class="n">search</span> <span class="n">precedence</span>
<span class="o">...</span><span class="na">생략</span>
<span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.929</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">beans</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">DefaultListableBeanFactory</span> <span class="o">-</span> <span class="nc">Returning</span> <span class="n">cached</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">singleton</span> <span class="n">bean</span> <span class="err">'</span><span class="n">getMyService</span><span class="err">'</span>
<span class="nc">My</span> <span class="nl">Service:</span> <span class="no">MY_SERVICE_V2</span></code></pre></figure><h3 id="여러-개의-인터페이스를-구현한-하나의-클래스를-통해-초기화된-객체">여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체</h3><p>아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">();</span>
    
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">();</span>

<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure><p>Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">MyServiceV1</span> <span class="n">myService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">();</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span> <span class="k">return</span> <span class="n">myService</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IAnotherService</span> <span class="nf">getAnotherService</span><span class="o">(){</span> <span class="k">return</span> <span class="n">myService</span><span class="o">;</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만,</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">Exception in thread "main" org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.leeyh0216.springstudy.manyinterfacebean.IMyService' available: expected single matching bean but found 2: getMyService,getAnotherService
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345)
...생략</code></pre></figure><p>IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다.</p><p>분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다.</p><p>Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면,</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span></code></pre></figure><p>와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면</p><figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">resolveNamedBean</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">requiredType</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="s">"Required type must not be null"</span><span class="o">);</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">autowireCandidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(!</span><span class="n">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">)</span> <span class="o">||</span> <span class="n">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">).</span><span class="na">isAutowireCandidate</span><span class="o">())</span> <span class="o">{</span>
					<span class="n">autowireCandidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(!</span><span class="n">autowireCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="n">candidateNames</span> <span class="o">=</span> <span class="n">autowireCandidates</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">autowireCandidates</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">candidateNames</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
			<span class="k">return</span> <span class="k">new</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">containsSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
					<span class="n">candidates</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="o">{</span>
					<span class="n">candidates</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getType</span><span class="o">(</span><span class="n">beanName</span><span class="o">));</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="nc">String</span> <span class="n">candidateName</span> <span class="o">=</span> <span class="n">determinePrimaryCandidate</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">candidateName</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">candidateName</span> <span class="o">=</span> <span class="n">determineHighestPriorityCandidate</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">candidateName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">Object</span> <span class="n">beanInstance</span> <span class="o">=</span> <span class="n">candidates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">candidateName</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">beanInstance</span> <span class="k">instanceof</span> <span class="nc">Class</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">beanInstance</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">candidateName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="k">return</span> <span class="k">new</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">candidateName</span><span class="o">,</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">beanInstance</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">NoUniqueBeanDefinitionException</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="n">candidates</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span></code></pre></figure><p>거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다.</p><p>원인은 위 함수의 거의 맨 윗 줄에 있는</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span></code></pre></figure><p>의 <code class="language-plaintext highlighter-rouge">getBeanNamesForType</code> 함수이다.</p><p>이 함수는 <code class="language-plaintext highlighter-rouge">org.springframework.beans.factory</code> 패키지에 선언된 <code class="language-plaintext highlighter-rouge">ListableBeanFactory</code>의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다.</p><blockquote><p>주어진 타입(<strong>SubClass를 포함하여</strong>)과 일치하는 Bean 목록을 반환합니다.</p></blockquote><p>SubClass를 포함했다는 사실이 매우 중요하다.</p><p>우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다.</p><p>즉, IMyService 클래스를 <code class="language-plaintext highlighter-rouge">getBeanNamesForType</code>에 넘긴다 해도 구체화 클래스인 <code class="language-plaintext highlighter-rouge">MyService</code> 클래스의 객체인 <code class="language-plaintext highlighter-rouge">getMyService</code> Bean과 <code class="language-plaintext highlighter-rouge">getAnotherService</code> Bean이 반환된다.</p><p>두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 <code class="language-plaintext highlighter-rouge">resolveNamedBean</code> 메소드에 구현되어 있는데,</p><ol><li><code class="language-plaintext highlighter-rouge">getBeanNamesForType</code>에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환<li><code class="language-plaintext highlighter-rouge">getBeanNamesForType</code>에서 반환한 Bean 이름이 여러개인 경우<ol><li><code class="language-plaintext highlighter-rouge">@Primiary</code> 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환<li>우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw</ol></ol><p>와 같은 과정을 가지고 있다.</p><p>위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다.</p><ol><li>Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법<li><code class="language-plaintext highlighter-rouge">IMyService</code>, <code class="language-plaintext highlighter-rouge">IAnotherService</code>를 모두를 상속받는 인터페이스를 <code class="language-plaintext highlighter-rouge">MyService</code> 클래스가 구현하여 Bean을 1개로 만드는 방법<li><code class="language-plaintext highlighter-rouge">@Primary</code>와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법</ol><p>각 방법을 테스트해보도록 하겠다.</p><h4 id="class가-아닌-bean-이름을-통해-bean을-선택하는-방법">Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법</h4><p>아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IMyService</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"getMyService"</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IAnotherService</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"getAnotherService"</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>이 경우 또한 ApplicationContext에 <code class="language-plaintext highlighter-rouge">getMyService</code>와 <code class="language-plaintext highlighter-rouge">getAnotherService</code> Bean 모두가 등록되어 있지만 <code class="language-plaintext highlighter-rouge">getMyService</code> 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다.</p><h4 id="imyservice-ianotherservice-를-상속받은-인터페이스를-myservice가-구현하는-방법"><code class="language-plaintext highlighter-rouge">IMyService</code>, <code class="language-plaintext highlighter-rouge">IAnotherService</code> 를 상속받은 인터페이스를 MyService가 구현하는 방법</h4><p>아래와 같이 <code class="language-plaintext highlighter-rouge">IMyService</code>, <code class="language-plaintext highlighter-rouge">IAnotherService</code>를 상속하는 <code class="language-plaintext highlighter-rouge">ITotalService</code> 인터페이스를 만든다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITotalService</span> <span class="kd">extends</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">{</span>
<span class="o">}</span></code></pre></figure><p>그 후 MyService가 해당 Interface를 구현하도록 한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">ITotalService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure><p>또한 Configuration 클래스 또한 아래와 같이 <code class="language-plaintext highlighter-rouge">ITotalService</code>를 반환하도록 수정해주고</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ITotalService</span> <span class="nf">getTotalService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">();</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>main 함수 또한 아래와 같이 <code class="language-plaintext highlighter-rouge">IMyService</code>, <code class="language-plaintext highlighter-rouge">IAnotherService</code>를 따로 가져오는 것이 아닌 <code class="language-plaintext highlighter-rouge">ITotalService</code> 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">ITotalService</span> <span class="n">totalService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">ITotalService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">totalService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">totalService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다.</p><h4 id="primary-어노테이션을-이용하여-우선순위에-따라-선택되게-만드는-방법"><code class="language-plaintext highlighter-rouge">@Primary</code> 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법</h4><p>우선 MyService 클래스를 아래와 같이 수정하여, <code class="language-plaintext highlighter-rouge">getMyService</code>와 <code class="language-plaintext highlighter-rouge">getAnotherService</code>에서 반환되는 객체를 구분할 수 있도록 하자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">serviceName</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(</span><span class="nc">String</span> <span class="n">serviceName</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">serviceName</span> <span class="o">=</span> <span class="n">serviceName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="n">serviceName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure><p>Configuration 클래스의 <code class="language-plaintext highlighter-rouge">getMyService</code> 메서드에 아래와 같이 <code class="language-plaintext highlighter-rouge">@Primary</code> 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Primary</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Primary</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">(</span><span class="s">"primary"</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IAnotherService</span> <span class="nf">getAnotherService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">(</span><span class="s">"no priority"</span><span class="o">);</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>그 후 main 함수를 아래와 같이 작성하여 돌려보면 <code class="language-plaintext highlighter-rouge">getMyService</code> 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>이 경우 또한 ApplicationContext에 <code class="language-plaintext highlighter-rouge">getMyService</code>와 <code class="language-plaintext highlighter-rouge">getAnotherService</code> Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다.</p><p>여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/spring/'>spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - The IoC Container(2) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - The IoC Container(2) - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-core-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - The IoC Container(2) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-core-3/"><div class="card-body"> <span class="timeago small" > Dec 3, 2018 <i class="unloaded">2018-12-03T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(3)</h3><div class="text-muted small"><p> The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyServic...</p></div></div></a></div><div class="card"> <a href="/posts/heap-and-gc/"><div class="card-body"> <span class="timeago small" > Jul 14 <i class="unloaded">2024-07-14T17:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM Heap과 GC를 다른 관점에서 바라보기</h3><div class="text-muted small"><p> 개요 Garbage Collection을 검색해보면 대부분의 글이 특정 GC(CMS, G1, Z 등)의 배경이 되는 이론(ex. Generational Collection Theory)이나, 알고리즘(ex. Mark-Sweep), 튜닝 등에 대한 내용을 다루고 있다. 그리고 해당 이론에 근거하여 Heap 메모리의 구조를 설명하다보니, Heap 영역을...</p></div></div></a></div><div class="card"> <a href="/posts/protobuf_2_5_build/"><div class="card-body"> <span class="timeago small" > Mar 10 <i class="unloaded">2024-03-10T12:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>protobuf 2.5 빌드하기(Apple Silicon)</h3><div class="text-muted small"><p> 이 문제는 Apple Silicon(M1, M2, M3 등)에서만 발생합니다. Ubuntu나 Intel Mac에서는 발생하지 않을 수 있음을 유의하시기 바랍니다. Hadoop 3.2.2 버전을 빌드하려다보니, 아래와 같은 메시지가 발생하며 빌드에 실패하였다. 1 [ERROR] Failed to execute goal org.apache.ha...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/elasticsearch-1/" class="btn btn-outline-primary" prompt="Older"><p>ElasticSearch + MetricBeat + Kibana로 서버 모니터링하기</p></a> <a href="/posts/spring-core-3/" class="btn btn-outline-primary" prompt="Newer"><p>Spring Core Technologies - The IoC Container(3)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
