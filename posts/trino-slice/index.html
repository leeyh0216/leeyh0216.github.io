<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Java Object의 Memory Layout과 Trino의 Slice" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Java Object의 Memory Layout Data structure alignment WORD CPU에서 어떤 작업을 하기 위해서는 메모리 영역의 데이터를 레지스터로 옮겨야 한다. 이 때 CPU가 레지스터로 데이터를 옮겨오는 단위를 WORD라고 한다. WORD의 크기는 CPU마다 다르다. 32bit CPU에서는 WORD의 크기가 32bit 64bit CPU에서는 WORD의 크기가 64bit 다만 Intel x86에서 WORD=16bit로 정해놓은 MACRO가 존재하였기 때문에, 어셈블리 상에서는 아직도 WORD=16bit 로 표현한다. DOUBLE WORD=32bit, QUAD WORD=64bit로 표현한다. 1 2 3 4 5 6 7 8 int main(void) { int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100}; for(int i = 0; i &lt; 10; i++) { arr[i] = i; } return 0; } 위의 코드를 어셈블리로 변경했을 때, Loop 내의 arr[i] = i 구문은 아래와 같이 표현된다. 1 2 3 4 mov eax, DWORD PTR [rbp-4] cdqe mov edx, DWORD PTR [rbp-4] mov DWORD PTR [rbp-48+rax*4], edx 여기서 eax, edx 등의 레지스터로 DWORD PTR 씩 옮기는 것을 볼 수 있는데, 32bit 메모리 주소만큼의 데이터를 복사하는 것으로 이해할 수 있다. Aligned Memory Access vs Misaligned Memory Access CPU는 메모리 공간에 접근할 때, WORD 단위로 접근한다. 만일 32bit CPU가 Memory를 접근할 때는 (0x0 ~ 0x3), (0x4 ~ 0x7) … 와 같이 4의 배수씩 끊어서 메모리 공간에 접근한다. 4byte 짜리 데이터가 (0x0 ~ 0x3) 주소에 위치해있다고 생각해보자. CPU에서 레지스터에 해당 데이터를 올려놓기 위해서는 (0x0 ~ 0x3) 주소 구간 1번만을 접근하면 된다. 이러한 메모리 접근을 Aligned Memory Access라고 한다. 반면 같은 데이터가 0x1 ~ 0x4 공간에 위치해있다면, CPU는 (0x0 ~ 0x3), (0x4 ~ 0x7)과 같이 2회 메모리에 접근해야 온전한 데이터를 가져올 수 있다. 이러한 메모리 접근을 Misaligned Memory Access라고 한다. Data structure padding 1 2 3 4 5 6 7 8 9 10 #include&lt;stdio.h&gt; struct MyStruct { short a; int b; }; int main(void) { printf(&quot;%d&quot;, sizeof(MyStruct)); return 0; } 우리가 알고 있는 프로그래밍 지식으로 생각하면 위 코드는 6을 출력해야 한다. short형 2byte + int형 4byte = 6byte이기 때문이다. 그러나 실제로는 8이라는 결과가 출력된다. 이는 CPU의 메모리 접근을 최적화시키기 위하여 컴파일러에서 Padding이라는 것을 삽입하기 때문이다. Padding 없이 위 구조체를 메모리 공간에 할당한다면, 0x0 ~ 0x1: a 0x2 ~ 0x3: b의 상위 2byte 0x4 ~ 0x5: b의 하위 2byte 와 같이 할당된다. CPU에서 a에 접근하기 위해서는 1개 WORD만 가져오면 되지만, b에 접근하기 위해서는 2개 WORD를 가져와야 한다. 이러한 문제를 해결하기 위해 Compiler는 Padding을 삽입하여 구조체를 위한 메모리 공간을 아래와 같이 마련한다. 0x0 ~ 0x1: a 0x2 ~ 0x3: Padding 0x4 ~ 0x7: b 이렇게 되면 메모리 공간은 손해이지만, CPU의 메모리 접근은 최적화된다. 추가로 aligned 키워드를 통한 Cache Line 최적화 내용도 Data Memory Alignment에 영향을 미치긴 하는데, 현재의 내용과 연관이 깊지 않아 다음에 시간이 되면 다루려 한다. Java Ordinary Object Pointer와 Memory Layout Java에서는 객체를 가리키기 위한 포인터를 Ordinary Object Pointer(OOP)라 한다. instanceOop: 단일 객체를 표현하기 위한 OOP arrayOop: 배열을 가리키기 위한 OOP 이 OOP들은 모두 oopDesc라는 클래스를 기반으로 한다. oopDesc는 mark word와 klass word 필드를 포함하고 있다. mark word: Object Header 정보를 포함하고 있다. 32bit 운영체제에서는 4byte, 64bit 운영체제에서는 8byte 크기를 가진다. klass word: Language Level에서의 메타데이터를 포함하고 있다. 4byte 크기를 가진다. 즉, 모든 자바 객체들은 기본적으로 12byte의 Overhead(64bit 운영체제 기준, 8byte mark word + 4byte klass word)를 가지고 있다. Short 자료형 Memory Layout 확인해보기 Java Object Layout 라이브러리를 사용하면, 자바 객체의 메모리 레이아웃을 확인할 수 있다. 아래 코드를 통해 Short 타입의 메모리 구조에 대해 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 short a = 1; System.out.println(ClassLayout.parseClass(Short.class).toPrintable(a)); -- 출력 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 13: 실제 Short 데이터 영역. 2byte Offset 14 ~ 15: Padding 위에서 설명했듯 CPU에서는 메모리 접근을 최적화하기 위해 WORD 단위로 접근한다. 64bit 운영체제에서는 WORD가 8byte(64bit)이기 때문에 JVM에서는 이에 맞추어 Memory Alignment 단위를 8byte로 지정하고 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 System.out.println(VM.current().details()); -- 출력 # Running 64-bit HotSpot VM. # Using compressed oop with 3-bit shift. # Using compressed klass with 3-bit shift. # WARNING | Compressed references base/shifts are guessed by the experiment! # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE. # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses. # Objects are 8 bytes aligned. # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] 위의 “Objects are 8bytes aligned.”라는 메시지를 통해 Java의 Memory Alignment 단위가 8byte라는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total 다시 Short 자료형에 대해 생각해보자면, 12byte의 header(mark, klass)와 2byte(Short)의 데이터를 합쳐 총 14byte의 크기임을 확인할 수 있다. 그러나 WORD 단위로 데이터를 Align하기 위해 마지막에 2byte Padding을 추가하는 것이다. Padding을 추가하였기 때문에 2byte의 Space Loss(이 경우 객체 External Fragmentation이기 때문에 External Loss가 추가)가 발생하는 것을 확인할 수 있다. short 배열 Memory Layout 확인해보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 short[] arr = new short[1025]; System.out.println(ClassLayout.parseClass(short[].class).toPrintable(arr)); -- 출력 [S object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00006d08 12 4 (array length) 1025 12 4 (alignment/padding gap) 16 0 short [S.&lt;elements&gt; N/A 16 0 (object alignment gap) Instance size: 2072 bytes Space losses: 4 bytes internal + 0 bytes external = 4 bytes total 배열에 대한 OOP에는 배열 길이에 대한 정보를 포함하고 있다. mark, klass 헤더 정보 + 배열 길이 + 데이터로 구성된다. Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 15: 배열의 길이. 4byte OOP 공간은 16byte이기 때문에 별도의 Padding이 추가되지 않는다. 16번째 Offset부터 실제 배열의 데이터가 할당되는데, 길이 1025의 배열이므로 총 2050byte를 차지하게 된다. 여기서 알 수 있는 점은 다음과 같다. 예상되는 배열 객체의 크기는 2066byte(= 16byte + 2050byte(2byte * 1025))이다. 실제 배열 객체의 크기는 2072byte(= 16byte + 2050byte(2byte * 1025) + 6byte(=Padding))이다. Java의 Unsafe를 이용한 저수준 데이터 조작 C, C++과 같은 저수준 언어에서는 Pointer를 통한 저수준 데이터 조작이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include&lt;stdio.h&gt; int main(void){ int arr[4] = {1,2,3,4}; int* ptr = arr; for(int i = 0; i &lt; 4; i++) { printf(&quot;%p\n&quot;, ptr); *ptr = (*ptr) * 10; ptr = ptr + 1; } for(int i = 0; i &lt; 4; i++) { printf(&quot;%d\n&quot;, arr[i]); } return 0; } 자바에서는 객체의 주소값을 직접 참조하는 기능을 표면적으로는 제공하지 않지만, Unsafe를 사용하면 위와 같은 코드를 작성할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sun.misc.Unsafe; import java.lang.reflect.Field; import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET; import static sun.misc.Unsafe.ARRAY_INT_INDEX_SCALE; public class UnsafeIteration { public static Unsafe getUnsafe() throws Exception { Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); return (Unsafe) theUnsafe.get(null); } public void mulAndPrint() throws Exception { Unsafe unsafe = getUnsafe(); int[] arr = {1, 2, 3, 4}; Object base = arr; long address = ARRAY_INT_BASE_OFFSET; for(int i = 0; i &lt; 4; i++) { System.out.println(&quot;Address &quot; + i +&quot;th element: &quot; + address); unsafe.putInt(base, address, unsafe.getInt(base, address) * 10); address += ARRAY_INT_INDEX_SCALE; } for(int i = 0; i &lt; 4; i++) System.out.println(arr[i]); } public static void main(String[] args) throws Exception { new UnsafeIteration().mulAndPrint(); } } 위 코드의 mulAndPrint 동작은 다음과 같다. 특정 객체를 가리키기 위한 Pointer인 base Object 객체를 만들고, base가 arr을 가리키도록 만든다. 데이터의 주소를 가리키기 위한 변수인 address를 선언한다. Unsafe에서 주소 참조는 두가지로 나뉜다. 절대 주소를 사용하는 방법 상대 주소를 사용하는 방법: 기준 주소(객체 포인터)와 Offset을 사용하여 절대 주소 계산 여기서는 기준 주소와 Offset을 사용하는 방법을 사용한다. 위에서 설명했듯, 배열 객체는 16byte의 Header(mark + klass + 배열 길이)를 사용한다. 그렇기 때문에 ARRAY_INT_BASE_OFFSET을 사용하여 시작 주소를 옮긴다. Loop를 순회한다. unsafe.getInt(base, address): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값으로부터 4byte int를 읽는다. unsafe.putInt(base, address, unsafe.getint(base, address) * 10): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값에 4byte int 데이터를 넣는다. address += ARRAY_INT_INDEX_SCALE: 주소 값에 4byte만큼을 증가시킨다. 위 연산들은 모두 ByteBuffer를 통해서도 동일하게 수행할 수 있다. How to speed up a byte[] lookup to be faster using sun.misc.Unsafe? 글을 참고해보면 Unsafe 방식이 10 ~ 15% 가량의 성능 이점이 있을 수 있다고 되어 있다. Unsafe는 잘못 사용할 경우 저수준 언어에서의 Segmentation Fault 등의 문제를 동일하게 겪을 수 있기 때문에, Java에서는 Public API로 노출되어 있지 않다. 다만 Trino나 Spark과 같은 성능이 중시되는 애플리케이션에서는 MicroOptimization 또한 중요하기 때문에 Unsafe를 사용한다. Trino의 Slice 사실 정확히 표현하자면 Trino에서 사용하는 Airlift의 Slice 라이브러리이다. Slice는 “Slice is a Java library for efficiently working with heap and off-heap memory.”와 같은 소개를 하고 있는데, Trino에서는 데이터의 저장/전송 등에 Slice를 사용한다. 내부적으로 사용되는 라이브러리이기 때문에, 별도의 공식 문서가 없어 코드 자체를 확인해보았다. Slice Unsafe를 사용하여 저수준 데이터 조작을 수행하는 클래스이다. Slice 에서 코드 확인이 가능하다. 6개의 멤버 변수를 포함하고 있다. 1 2 3 4 5 6 7 8 9 10 11 private final Object base; private final long address; private final int size; private final long retainedSize; private final Object reference; private int hash; reference와 hash를 제외한 각 변수의 역할은 다음과 같다. base: Slice 객체가 가리키는 원본 객체이다. Slice에서 Unsafe의 상대 주소를 사용하기 때문에, 기준점이 되는 주소를 제공한다고 볼 수 있다. address: 원본 객체의 데이터 시작 주소를 의미한다. 위에서 설명했듯 헤더 데이터 등을 제외하고 실제로 데이터가 시작되는 주소 값을 의미한다. size: 데이터의 크기이다. retainedSize: Slice 객체의 크기를 포함한 데이터의 크기이다. 생성자 Slice의 생성자는 모두 private 접근 제한자를 가지고 있다. 외부에서의 생성은 팩토리 역할을 수행하는 Slices 클래스에 존재한다. 간단하게 int 타입 배열을 다루는 Slice의 생성자에 대해 확인해본다. 1 2 3 4 5 6 7 8 9 10 11 Slice(int[] base, int offset, int length) { requireNonNull(base, &quot;base is null&quot;); checkPositionIndexes(offset, offset + length, base.length); this.base = base; this.address = sizeOfIntArray(offset); this.size = multiplyExact(length, ARRAY_INT_INDEX_SCALE); this.retainedSize = INSTANCE_SIZE + sizeOf(base); this.reference = (offset == 0 &amp;&amp; length == base.length) ? COMPACT : NOT_COMPACT; } base는 int 배열을 가리킨다. address는 sizeOfIntArray를 호출하여 초기화한다. 1 2 3 4 public static long sizeOfIntArray(int length) { return ARRAY_INT_BASE_OFFSET + (((long) ARRAY_INT_INDEX_SCALE) * length); } Slice 생성 시 원본 배열의 일부 구간(offset ~ offset + length - 1)을 기준으로 생성할 수 있기 때문에, 데이터의 시작 주소(address)는 ARRAY_INT_BASE_OFFSET에 Skip할 offset * ARRAY_INT_INDEX_SCALE만큼을 더해주어야 한다. size는 데이터의 실제 크기를 계산하여 집어넣는다. retainedSize는 Slice 객체 자체의 크기(INSTANCE_SIZE)에 데이터의 크기를 더한 크기이다. 1 private static final int INSTANCE_SIZE = toIntExact(ClassLayout.parseClass(Slice.class).instanceSize()); set, get 계열 메서드 Slice의 set 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset에 데이터를 설정할 수 있다. 1 2 3 4 5 6 7 8 9 10 public void setInt(int index, int value) { checkIndexLength(index, SIZE_OF_INT); setIntUnchecked(index, value); } void setIntUnchecked(int index, int value) { unsafe.putInt(base, address + index, value); } setInt를 통해 특정 Index(index)에 값(value)를 설정할 수 있다. setIntUnchecked는 Unsafe의 putInt를 통해 넣어야 할 주소(base + address + index)에 값을 설정하는 것을 확인할 수 있다. 반대로 get 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset의 데이터를 조회할 수 있다. 1 2 3 4 5 6 7 8 9 10 public int getInt(int index) { checkIndexLength(index, SIZE_OF_INT); return getIntUnchecked(index); } int getIntUnchecked(int index) { return unsafe.getInt(base, address + index); } Slices Slices는 Slice 생성을 위한 정적 팩토리 메서드를 제공하는 클래스이다. 아래는 int형 배열을 기반으로 하는 Slice를 생성하는 wrappedIntArray 코드이다. 1 2 3 4 5 6 7 public static Slice wrappedIntArray(int[] array, int offset, int length) { if (length == 0) { return EMPTY_SLICE; } return new Slice(array, offset, length); } Usage Slice in Trino Slice는 Trino의 데이터 조작에서 굉장히 많이 사용되고 있으며, 특히 파일 입/출력 시 버퍼로 자주 사용된다. OrcOutputBuffer 등에서 사용되니 코드를 하나씩 확인해보면 좋을 것 같다. 참고자료 Data Structure Alignment - Wikipedia Java Memory Layout - Baeldung" /><meta property="og:description" content="Java Object의 Memory Layout Data structure alignment WORD CPU에서 어떤 작업을 하기 위해서는 메모리 영역의 데이터를 레지스터로 옮겨야 한다. 이 때 CPU가 레지스터로 데이터를 옮겨오는 단위를 WORD라고 한다. WORD의 크기는 CPU마다 다르다. 32bit CPU에서는 WORD의 크기가 32bit 64bit CPU에서는 WORD의 크기가 64bit 다만 Intel x86에서 WORD=16bit로 정해놓은 MACRO가 존재하였기 때문에, 어셈블리 상에서는 아직도 WORD=16bit 로 표현한다. DOUBLE WORD=32bit, QUAD WORD=64bit로 표현한다. 1 2 3 4 5 6 7 8 int main(void) { int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100}; for(int i = 0; i &lt; 10; i++) { arr[i] = i; } return 0; } 위의 코드를 어셈블리로 변경했을 때, Loop 내의 arr[i] = i 구문은 아래와 같이 표현된다. 1 2 3 4 mov eax, DWORD PTR [rbp-4] cdqe mov edx, DWORD PTR [rbp-4] mov DWORD PTR [rbp-48+rax*4], edx 여기서 eax, edx 등의 레지스터로 DWORD PTR 씩 옮기는 것을 볼 수 있는데, 32bit 메모리 주소만큼의 데이터를 복사하는 것으로 이해할 수 있다. Aligned Memory Access vs Misaligned Memory Access CPU는 메모리 공간에 접근할 때, WORD 단위로 접근한다. 만일 32bit CPU가 Memory를 접근할 때는 (0x0 ~ 0x3), (0x4 ~ 0x7) … 와 같이 4의 배수씩 끊어서 메모리 공간에 접근한다. 4byte 짜리 데이터가 (0x0 ~ 0x3) 주소에 위치해있다고 생각해보자. CPU에서 레지스터에 해당 데이터를 올려놓기 위해서는 (0x0 ~ 0x3) 주소 구간 1번만을 접근하면 된다. 이러한 메모리 접근을 Aligned Memory Access라고 한다. 반면 같은 데이터가 0x1 ~ 0x4 공간에 위치해있다면, CPU는 (0x0 ~ 0x3), (0x4 ~ 0x7)과 같이 2회 메모리에 접근해야 온전한 데이터를 가져올 수 있다. 이러한 메모리 접근을 Misaligned Memory Access라고 한다. Data structure padding 1 2 3 4 5 6 7 8 9 10 #include&lt;stdio.h&gt; struct MyStruct { short a; int b; }; int main(void) { printf(&quot;%d&quot;, sizeof(MyStruct)); return 0; } 우리가 알고 있는 프로그래밍 지식으로 생각하면 위 코드는 6을 출력해야 한다. short형 2byte + int형 4byte = 6byte이기 때문이다. 그러나 실제로는 8이라는 결과가 출력된다. 이는 CPU의 메모리 접근을 최적화시키기 위하여 컴파일러에서 Padding이라는 것을 삽입하기 때문이다. Padding 없이 위 구조체를 메모리 공간에 할당한다면, 0x0 ~ 0x1: a 0x2 ~ 0x3: b의 상위 2byte 0x4 ~ 0x5: b의 하위 2byte 와 같이 할당된다. CPU에서 a에 접근하기 위해서는 1개 WORD만 가져오면 되지만, b에 접근하기 위해서는 2개 WORD를 가져와야 한다. 이러한 문제를 해결하기 위해 Compiler는 Padding을 삽입하여 구조체를 위한 메모리 공간을 아래와 같이 마련한다. 0x0 ~ 0x1: a 0x2 ~ 0x3: Padding 0x4 ~ 0x7: b 이렇게 되면 메모리 공간은 손해이지만, CPU의 메모리 접근은 최적화된다. 추가로 aligned 키워드를 통한 Cache Line 최적화 내용도 Data Memory Alignment에 영향을 미치긴 하는데, 현재의 내용과 연관이 깊지 않아 다음에 시간이 되면 다루려 한다. Java Ordinary Object Pointer와 Memory Layout Java에서는 객체를 가리키기 위한 포인터를 Ordinary Object Pointer(OOP)라 한다. instanceOop: 단일 객체를 표현하기 위한 OOP arrayOop: 배열을 가리키기 위한 OOP 이 OOP들은 모두 oopDesc라는 클래스를 기반으로 한다. oopDesc는 mark word와 klass word 필드를 포함하고 있다. mark word: Object Header 정보를 포함하고 있다. 32bit 운영체제에서는 4byte, 64bit 운영체제에서는 8byte 크기를 가진다. klass word: Language Level에서의 메타데이터를 포함하고 있다. 4byte 크기를 가진다. 즉, 모든 자바 객체들은 기본적으로 12byte의 Overhead(64bit 운영체제 기준, 8byte mark word + 4byte klass word)를 가지고 있다. Short 자료형 Memory Layout 확인해보기 Java Object Layout 라이브러리를 사용하면, 자바 객체의 메모리 레이아웃을 확인할 수 있다. 아래 코드를 통해 Short 타입의 메모리 구조에 대해 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 short a = 1; System.out.println(ClassLayout.parseClass(Short.class).toPrintable(a)); -- 출력 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 13: 실제 Short 데이터 영역. 2byte Offset 14 ~ 15: Padding 위에서 설명했듯 CPU에서는 메모리 접근을 최적화하기 위해 WORD 단위로 접근한다. 64bit 운영체제에서는 WORD가 8byte(64bit)이기 때문에 JVM에서는 이에 맞추어 Memory Alignment 단위를 8byte로 지정하고 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 System.out.println(VM.current().details()); -- 출력 # Running 64-bit HotSpot VM. # Using compressed oop with 3-bit shift. # Using compressed klass with 3-bit shift. # WARNING | Compressed references base/shifts are guessed by the experiment! # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE. # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses. # Objects are 8 bytes aligned. # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] 위의 “Objects are 8bytes aligned.”라는 메시지를 통해 Java의 Memory Alignment 단위가 8byte라는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total 다시 Short 자료형에 대해 생각해보자면, 12byte의 header(mark, klass)와 2byte(Short)의 데이터를 합쳐 총 14byte의 크기임을 확인할 수 있다. 그러나 WORD 단위로 데이터를 Align하기 위해 마지막에 2byte Padding을 추가하는 것이다. Padding을 추가하였기 때문에 2byte의 Space Loss(이 경우 객체 External Fragmentation이기 때문에 External Loss가 추가)가 발생하는 것을 확인할 수 있다. short 배열 Memory Layout 확인해보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 short[] arr = new short[1025]; System.out.println(ClassLayout.parseClass(short[].class).toPrintable(arr)); -- 출력 [S object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00006d08 12 4 (array length) 1025 12 4 (alignment/padding gap) 16 0 short [S.&lt;elements&gt; N/A 16 0 (object alignment gap) Instance size: 2072 bytes Space losses: 4 bytes internal + 0 bytes external = 4 bytes total 배열에 대한 OOP에는 배열 길이에 대한 정보를 포함하고 있다. mark, klass 헤더 정보 + 배열 길이 + 데이터로 구성된다. Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 15: 배열의 길이. 4byte OOP 공간은 16byte이기 때문에 별도의 Padding이 추가되지 않는다. 16번째 Offset부터 실제 배열의 데이터가 할당되는데, 길이 1025의 배열이므로 총 2050byte를 차지하게 된다. 여기서 알 수 있는 점은 다음과 같다. 예상되는 배열 객체의 크기는 2066byte(= 16byte + 2050byte(2byte * 1025))이다. 실제 배열 객체의 크기는 2072byte(= 16byte + 2050byte(2byte * 1025) + 6byte(=Padding))이다. Java의 Unsafe를 이용한 저수준 데이터 조작 C, C++과 같은 저수준 언어에서는 Pointer를 통한 저수준 데이터 조작이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include&lt;stdio.h&gt; int main(void){ int arr[4] = {1,2,3,4}; int* ptr = arr; for(int i = 0; i &lt; 4; i++) { printf(&quot;%p\n&quot;, ptr); *ptr = (*ptr) * 10; ptr = ptr + 1; } for(int i = 0; i &lt; 4; i++) { printf(&quot;%d\n&quot;, arr[i]); } return 0; } 자바에서는 객체의 주소값을 직접 참조하는 기능을 표면적으로는 제공하지 않지만, Unsafe를 사용하면 위와 같은 코드를 작성할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sun.misc.Unsafe; import java.lang.reflect.Field; import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET; import static sun.misc.Unsafe.ARRAY_INT_INDEX_SCALE; public class UnsafeIteration { public static Unsafe getUnsafe() throws Exception { Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); return (Unsafe) theUnsafe.get(null); } public void mulAndPrint() throws Exception { Unsafe unsafe = getUnsafe(); int[] arr = {1, 2, 3, 4}; Object base = arr; long address = ARRAY_INT_BASE_OFFSET; for(int i = 0; i &lt; 4; i++) { System.out.println(&quot;Address &quot; + i +&quot;th element: &quot; + address); unsafe.putInt(base, address, unsafe.getInt(base, address) * 10); address += ARRAY_INT_INDEX_SCALE; } for(int i = 0; i &lt; 4; i++) System.out.println(arr[i]); } public static void main(String[] args) throws Exception { new UnsafeIteration().mulAndPrint(); } } 위 코드의 mulAndPrint 동작은 다음과 같다. 특정 객체를 가리키기 위한 Pointer인 base Object 객체를 만들고, base가 arr을 가리키도록 만든다. 데이터의 주소를 가리키기 위한 변수인 address를 선언한다. Unsafe에서 주소 참조는 두가지로 나뉜다. 절대 주소를 사용하는 방법 상대 주소를 사용하는 방법: 기준 주소(객체 포인터)와 Offset을 사용하여 절대 주소 계산 여기서는 기준 주소와 Offset을 사용하는 방법을 사용한다. 위에서 설명했듯, 배열 객체는 16byte의 Header(mark + klass + 배열 길이)를 사용한다. 그렇기 때문에 ARRAY_INT_BASE_OFFSET을 사용하여 시작 주소를 옮긴다. Loop를 순회한다. unsafe.getInt(base, address): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값으로부터 4byte int를 읽는다. unsafe.putInt(base, address, unsafe.getint(base, address) * 10): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값에 4byte int 데이터를 넣는다. address += ARRAY_INT_INDEX_SCALE: 주소 값에 4byte만큼을 증가시킨다. 위 연산들은 모두 ByteBuffer를 통해서도 동일하게 수행할 수 있다. How to speed up a byte[] lookup to be faster using sun.misc.Unsafe? 글을 참고해보면 Unsafe 방식이 10 ~ 15% 가량의 성능 이점이 있을 수 있다고 되어 있다. Unsafe는 잘못 사용할 경우 저수준 언어에서의 Segmentation Fault 등의 문제를 동일하게 겪을 수 있기 때문에, Java에서는 Public API로 노출되어 있지 않다. 다만 Trino나 Spark과 같은 성능이 중시되는 애플리케이션에서는 MicroOptimization 또한 중요하기 때문에 Unsafe를 사용한다. Trino의 Slice 사실 정확히 표현하자면 Trino에서 사용하는 Airlift의 Slice 라이브러리이다. Slice는 “Slice is a Java library for efficiently working with heap and off-heap memory.”와 같은 소개를 하고 있는데, Trino에서는 데이터의 저장/전송 등에 Slice를 사용한다. 내부적으로 사용되는 라이브러리이기 때문에, 별도의 공식 문서가 없어 코드 자체를 확인해보았다. Slice Unsafe를 사용하여 저수준 데이터 조작을 수행하는 클래스이다. Slice 에서 코드 확인이 가능하다. 6개의 멤버 변수를 포함하고 있다. 1 2 3 4 5 6 7 8 9 10 11 private final Object base; private final long address; private final int size; private final long retainedSize; private final Object reference; private int hash; reference와 hash를 제외한 각 변수의 역할은 다음과 같다. base: Slice 객체가 가리키는 원본 객체이다. Slice에서 Unsafe의 상대 주소를 사용하기 때문에, 기준점이 되는 주소를 제공한다고 볼 수 있다. address: 원본 객체의 데이터 시작 주소를 의미한다. 위에서 설명했듯 헤더 데이터 등을 제외하고 실제로 데이터가 시작되는 주소 값을 의미한다. size: 데이터의 크기이다. retainedSize: Slice 객체의 크기를 포함한 데이터의 크기이다. 생성자 Slice의 생성자는 모두 private 접근 제한자를 가지고 있다. 외부에서의 생성은 팩토리 역할을 수행하는 Slices 클래스에 존재한다. 간단하게 int 타입 배열을 다루는 Slice의 생성자에 대해 확인해본다. 1 2 3 4 5 6 7 8 9 10 11 Slice(int[] base, int offset, int length) { requireNonNull(base, &quot;base is null&quot;); checkPositionIndexes(offset, offset + length, base.length); this.base = base; this.address = sizeOfIntArray(offset); this.size = multiplyExact(length, ARRAY_INT_INDEX_SCALE); this.retainedSize = INSTANCE_SIZE + sizeOf(base); this.reference = (offset == 0 &amp;&amp; length == base.length) ? COMPACT : NOT_COMPACT; } base는 int 배열을 가리킨다. address는 sizeOfIntArray를 호출하여 초기화한다. 1 2 3 4 public static long sizeOfIntArray(int length) { return ARRAY_INT_BASE_OFFSET + (((long) ARRAY_INT_INDEX_SCALE) * length); } Slice 생성 시 원본 배열의 일부 구간(offset ~ offset + length - 1)을 기준으로 생성할 수 있기 때문에, 데이터의 시작 주소(address)는 ARRAY_INT_BASE_OFFSET에 Skip할 offset * ARRAY_INT_INDEX_SCALE만큼을 더해주어야 한다. size는 데이터의 실제 크기를 계산하여 집어넣는다. retainedSize는 Slice 객체 자체의 크기(INSTANCE_SIZE)에 데이터의 크기를 더한 크기이다. 1 private static final int INSTANCE_SIZE = toIntExact(ClassLayout.parseClass(Slice.class).instanceSize()); set, get 계열 메서드 Slice의 set 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset에 데이터를 설정할 수 있다. 1 2 3 4 5 6 7 8 9 10 public void setInt(int index, int value) { checkIndexLength(index, SIZE_OF_INT); setIntUnchecked(index, value); } void setIntUnchecked(int index, int value) { unsafe.putInt(base, address + index, value); } setInt를 통해 특정 Index(index)에 값(value)를 설정할 수 있다. setIntUnchecked는 Unsafe의 putInt를 통해 넣어야 할 주소(base + address + index)에 값을 설정하는 것을 확인할 수 있다. 반대로 get 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset의 데이터를 조회할 수 있다. 1 2 3 4 5 6 7 8 9 10 public int getInt(int index) { checkIndexLength(index, SIZE_OF_INT); return getIntUnchecked(index); } int getIntUnchecked(int index) { return unsafe.getInt(base, address + index); } Slices Slices는 Slice 생성을 위한 정적 팩토리 메서드를 제공하는 클래스이다. 아래는 int형 배열을 기반으로 하는 Slice를 생성하는 wrappedIntArray 코드이다. 1 2 3 4 5 6 7 public static Slice wrappedIntArray(int[] array, int offset, int length) { if (length == 0) { return EMPTY_SLICE; } return new Slice(array, offset, length); } Usage Slice in Trino Slice는 Trino의 데이터 조작에서 굉장히 많이 사용되고 있으며, 특히 파일 입/출력 시 버퍼로 자주 사용된다. OrcOutputBuffer 등에서 사용되니 코드를 하나씩 확인해보면 좋을 것 같다. 참고자료 Data Structure Alignment - Wikipedia Java Memory Layout - Baeldung" /><link rel="canonical" href="https://leeyh0216.github.io/posts/trino-slice/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/trino-slice/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-12-24T15:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java Object의 Memory Layout과 Trino의 Slice" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Java Object의 Memory Layout Data structure alignment WORD CPU에서 어떤 작업을 하기 위해서는 메모리 영역의 데이터를 레지스터로 옮겨야 한다. 이 때 CPU가 레지스터로 데이터를 옮겨오는 단위를 WORD라고 한다. WORD의 크기는 CPU마다 다르다. 32bit CPU에서는 WORD의 크기가 32bit 64bit CPU에서는 WORD의 크기가 64bit 다만 Intel x86에서 WORD=16bit로 정해놓은 MACRO가 존재하였기 때문에, 어셈블리 상에서는 아직도 WORD=16bit 로 표현한다. DOUBLE WORD=32bit, QUAD WORD=64bit로 표현한다. 1 2 3 4 5 6 7 8 int main(void) { int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100}; for(int i = 0; i &lt; 10; i++) { arr[i] = i; } return 0; } 위의 코드를 어셈블리로 변경했을 때, Loop 내의 arr[i] = i 구문은 아래와 같이 표현된다. 1 2 3 4 mov eax, DWORD PTR [rbp-4] cdqe mov edx, DWORD PTR [rbp-4] mov DWORD PTR [rbp-48+rax*4], edx 여기서 eax, edx 등의 레지스터로 DWORD PTR 씩 옮기는 것을 볼 수 있는데, 32bit 메모리 주소만큼의 데이터를 복사하는 것으로 이해할 수 있다. Aligned Memory Access vs Misaligned Memory Access CPU는 메모리 공간에 접근할 때, WORD 단위로 접근한다. 만일 32bit CPU가 Memory를 접근할 때는 (0x0 ~ 0x3), (0x4 ~ 0x7) … 와 같이 4의 배수씩 끊어서 메모리 공간에 접근한다. 4byte 짜리 데이터가 (0x0 ~ 0x3) 주소에 위치해있다고 생각해보자. CPU에서 레지스터에 해당 데이터를 올려놓기 위해서는 (0x0 ~ 0x3) 주소 구간 1번만을 접근하면 된다. 이러한 메모리 접근을 Aligned Memory Access라고 한다. 반면 같은 데이터가 0x1 ~ 0x4 공간에 위치해있다면, CPU는 (0x0 ~ 0x3), (0x4 ~ 0x7)과 같이 2회 메모리에 접근해야 온전한 데이터를 가져올 수 있다. 이러한 메모리 접근을 Misaligned Memory Access라고 한다. Data structure padding 1 2 3 4 5 6 7 8 9 10 #include&lt;stdio.h&gt; struct MyStruct { short a; int b; }; int main(void) { printf(&quot;%d&quot;, sizeof(MyStruct)); return 0; } 우리가 알고 있는 프로그래밍 지식으로 생각하면 위 코드는 6을 출력해야 한다. short형 2byte + int형 4byte = 6byte이기 때문이다. 그러나 실제로는 8이라는 결과가 출력된다. 이는 CPU의 메모리 접근을 최적화시키기 위하여 컴파일러에서 Padding이라는 것을 삽입하기 때문이다. Padding 없이 위 구조체를 메모리 공간에 할당한다면, 0x0 ~ 0x1: a 0x2 ~ 0x3: b의 상위 2byte 0x4 ~ 0x5: b의 하위 2byte 와 같이 할당된다. CPU에서 a에 접근하기 위해서는 1개 WORD만 가져오면 되지만, b에 접근하기 위해서는 2개 WORD를 가져와야 한다. 이러한 문제를 해결하기 위해 Compiler는 Padding을 삽입하여 구조체를 위한 메모리 공간을 아래와 같이 마련한다. 0x0 ~ 0x1: a 0x2 ~ 0x3: Padding 0x4 ~ 0x7: b 이렇게 되면 메모리 공간은 손해이지만, CPU의 메모리 접근은 최적화된다. 추가로 aligned 키워드를 통한 Cache Line 최적화 내용도 Data Memory Alignment에 영향을 미치긴 하는데, 현재의 내용과 연관이 깊지 않아 다음에 시간이 되면 다루려 한다. Java Ordinary Object Pointer와 Memory Layout Java에서는 객체를 가리키기 위한 포인터를 Ordinary Object Pointer(OOP)라 한다. instanceOop: 단일 객체를 표현하기 위한 OOP arrayOop: 배열을 가리키기 위한 OOP 이 OOP들은 모두 oopDesc라는 클래스를 기반으로 한다. oopDesc는 mark word와 klass word 필드를 포함하고 있다. mark word: Object Header 정보를 포함하고 있다. 32bit 운영체제에서는 4byte, 64bit 운영체제에서는 8byte 크기를 가진다. klass word: Language Level에서의 메타데이터를 포함하고 있다. 4byte 크기를 가진다. 즉, 모든 자바 객체들은 기본적으로 12byte의 Overhead(64bit 운영체제 기준, 8byte mark word + 4byte klass word)를 가지고 있다. Short 자료형 Memory Layout 확인해보기 Java Object Layout 라이브러리를 사용하면, 자바 객체의 메모리 레이아웃을 확인할 수 있다. 아래 코드를 통해 Short 타입의 메모리 구조에 대해 확인할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 short a = 1; System.out.println(ClassLayout.parseClass(Short.class).toPrintable(a)); -- 출력 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 13: 실제 Short 데이터 영역. 2byte Offset 14 ~ 15: Padding 위에서 설명했듯 CPU에서는 메모리 접근을 최적화하기 위해 WORD 단위로 접근한다. 64bit 운영체제에서는 WORD가 8byte(64bit)이기 때문에 JVM에서는 이에 맞추어 Memory Alignment 단위를 8byte로 지정하고 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 System.out.println(VM.current().details()); -- 출력 # Running 64-bit HotSpot VM. # Using compressed oop with 3-bit shift. # Using compressed klass with 3-bit shift. # WARNING | Compressed references base/shifts are guessed by the experiment! # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE. # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses. # Objects are 8 bytes aligned. # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes] 위의 “Objects are 8bytes aligned.”라는 메시지를 통해 Java의 Memory Alignment 단위가 8byte라는 것을 확인할 수 있다. 1 2 3 4 5 6 7 8 java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000004be6566201 (hash: 0x4be65662; age: 0) 8 4 (object header: class) 0x0003e7b0 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total 다시 Short 자료형에 대해 생각해보자면, 12byte의 header(mark, klass)와 2byte(Short)의 데이터를 합쳐 총 14byte의 크기임을 확인할 수 있다. 그러나 WORD 단위로 데이터를 Align하기 위해 마지막에 2byte Padding을 추가하는 것이다. Padding을 추가하였기 때문에 2byte의 Space Loss(이 경우 객체 External Fragmentation이기 때문에 External Loss가 추가)가 발생하는 것을 확인할 수 있다. short 배열 Memory Layout 확인해보기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 short[] arr = new short[1025]; System.out.println(ClassLayout.parseClass(short[].class).toPrintable(arr)); -- 출력 [S object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00006d08 12 4 (array length) 1025 12 4 (alignment/padding gap) 16 0 short [S.&lt;elements&gt; N/A 16 0 (object alignment gap) Instance size: 2072 bytes Space losses: 4 bytes internal + 0 bytes external = 4 bytes total 배열에 대한 OOP에는 배열 길이에 대한 정보를 포함하고 있다. mark, klass 헤더 정보 + 배열 길이 + 데이터로 구성된다. Offset 0 ~ 7: mark word 영역. 64bit 운영체제이기 때문에 8byte Offset 8 ~ 11: klass word 영역. 4byte Offset 12 ~ 15: 배열의 길이. 4byte OOP 공간은 16byte이기 때문에 별도의 Padding이 추가되지 않는다. 16번째 Offset부터 실제 배열의 데이터가 할당되는데, 길이 1025의 배열이므로 총 2050byte를 차지하게 된다. 여기서 알 수 있는 점은 다음과 같다. 예상되는 배열 객체의 크기는 2066byte(= 16byte + 2050byte(2byte * 1025))이다. 실제 배열 객체의 크기는 2072byte(= 16byte + 2050byte(2byte * 1025) + 6byte(=Padding))이다. Java의 Unsafe를 이용한 저수준 데이터 조작 C, C++과 같은 저수준 언어에서는 Pointer를 통한 저수준 데이터 조작이 가능하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include&lt;stdio.h&gt; int main(void){ int arr[4] = {1,2,3,4}; int* ptr = arr; for(int i = 0; i &lt; 4; i++) { printf(&quot;%p\\n&quot;, ptr); *ptr = (*ptr) * 10; ptr = ptr + 1; } for(int i = 0; i &lt; 4; i++) { printf(&quot;%d\\n&quot;, arr[i]); } return 0; } 자바에서는 객체의 주소값을 직접 참조하는 기능을 표면적으로는 제공하지 않지만, Unsafe를 사용하면 위와 같은 코드를 작성할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sun.misc.Unsafe; import java.lang.reflect.Field; import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET; import static sun.misc.Unsafe.ARRAY_INT_INDEX_SCALE; public class UnsafeIteration { public static Unsafe getUnsafe() throws Exception { Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); return (Unsafe) theUnsafe.get(null); } public void mulAndPrint() throws Exception { Unsafe unsafe = getUnsafe(); int[] arr = {1, 2, 3, 4}; Object base = arr; long address = ARRAY_INT_BASE_OFFSET; for(int i = 0; i &lt; 4; i++) { System.out.println(&quot;Address &quot; + i +&quot;th element: &quot; + address); unsafe.putInt(base, address, unsafe.getInt(base, address) * 10); address += ARRAY_INT_INDEX_SCALE; } for(int i = 0; i &lt; 4; i++) System.out.println(arr[i]); } public static void main(String[] args) throws Exception { new UnsafeIteration().mulAndPrint(); } } 위 코드의 mulAndPrint 동작은 다음과 같다. 특정 객체를 가리키기 위한 Pointer인 base Object 객체를 만들고, base가 arr을 가리키도록 만든다. 데이터의 주소를 가리키기 위한 변수인 address를 선언한다. Unsafe에서 주소 참조는 두가지로 나뉜다. 절대 주소를 사용하는 방법 상대 주소를 사용하는 방법: 기준 주소(객체 포인터)와 Offset을 사용하여 절대 주소 계산 여기서는 기준 주소와 Offset을 사용하는 방법을 사용한다. 위에서 설명했듯, 배열 객체는 16byte의 Header(mark + klass + 배열 길이)를 사용한다. 그렇기 때문에 ARRAY_INT_BASE_OFFSET을 사용하여 시작 주소를 옮긴다. Loop를 순회한다. unsafe.getInt(base, address): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값으로부터 4byte int를 읽는다. unsafe.putInt(base, address, unsafe.getint(base, address) * 10): 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값에 4byte int 데이터를 넣는다. address += ARRAY_INT_INDEX_SCALE: 주소 값에 4byte만큼을 증가시킨다. 위 연산들은 모두 ByteBuffer를 통해서도 동일하게 수행할 수 있다. How to speed up a byte[] lookup to be faster using sun.misc.Unsafe? 글을 참고해보면 Unsafe 방식이 10 ~ 15% 가량의 성능 이점이 있을 수 있다고 되어 있다. Unsafe는 잘못 사용할 경우 저수준 언어에서의 Segmentation Fault 등의 문제를 동일하게 겪을 수 있기 때문에, Java에서는 Public API로 노출되어 있지 않다. 다만 Trino나 Spark과 같은 성능이 중시되는 애플리케이션에서는 MicroOptimization 또한 중요하기 때문에 Unsafe를 사용한다. Trino의 Slice 사실 정확히 표현하자면 Trino에서 사용하는 Airlift의 Slice 라이브러리이다. Slice는 “Slice is a Java library for efficiently working with heap and off-heap memory.”와 같은 소개를 하고 있는데, Trino에서는 데이터의 저장/전송 등에 Slice를 사용한다. 내부적으로 사용되는 라이브러리이기 때문에, 별도의 공식 문서가 없어 코드 자체를 확인해보았다. Slice Unsafe를 사용하여 저수준 데이터 조작을 수행하는 클래스이다. Slice 에서 코드 확인이 가능하다. 6개의 멤버 변수를 포함하고 있다. 1 2 3 4 5 6 7 8 9 10 11 private final Object base; private final long address; private final int size; private final long retainedSize; private final Object reference; private int hash; reference와 hash를 제외한 각 변수의 역할은 다음과 같다. base: Slice 객체가 가리키는 원본 객체이다. Slice에서 Unsafe의 상대 주소를 사용하기 때문에, 기준점이 되는 주소를 제공한다고 볼 수 있다. address: 원본 객체의 데이터 시작 주소를 의미한다. 위에서 설명했듯 헤더 데이터 등을 제외하고 실제로 데이터가 시작되는 주소 값을 의미한다. size: 데이터의 크기이다. retainedSize: Slice 객체의 크기를 포함한 데이터의 크기이다. 생성자 Slice의 생성자는 모두 private 접근 제한자를 가지고 있다. 외부에서의 생성은 팩토리 역할을 수행하는 Slices 클래스에 존재한다. 간단하게 int 타입 배열을 다루는 Slice의 생성자에 대해 확인해본다. 1 2 3 4 5 6 7 8 9 10 11 Slice(int[] base, int offset, int length) { requireNonNull(base, &quot;base is null&quot;); checkPositionIndexes(offset, offset + length, base.length); this.base = base; this.address = sizeOfIntArray(offset); this.size = multiplyExact(length, ARRAY_INT_INDEX_SCALE); this.retainedSize = INSTANCE_SIZE + sizeOf(base); this.reference = (offset == 0 &amp;&amp; length == base.length) ? COMPACT : NOT_COMPACT; } base는 int 배열을 가리킨다. address는 sizeOfIntArray를 호출하여 초기화한다. 1 2 3 4 public static long sizeOfIntArray(int length) { return ARRAY_INT_BASE_OFFSET + (((long) ARRAY_INT_INDEX_SCALE) * length); } Slice 생성 시 원본 배열의 일부 구간(offset ~ offset + length - 1)을 기준으로 생성할 수 있기 때문에, 데이터의 시작 주소(address)는 ARRAY_INT_BASE_OFFSET에 Skip할 offset * ARRAY_INT_INDEX_SCALE만큼을 더해주어야 한다. size는 데이터의 실제 크기를 계산하여 집어넣는다. retainedSize는 Slice 객체 자체의 크기(INSTANCE_SIZE)에 데이터의 크기를 더한 크기이다. 1 private static final int INSTANCE_SIZE = toIntExact(ClassLayout.parseClass(Slice.class).instanceSize()); set, get 계열 메서드 Slice의 set 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset에 데이터를 설정할 수 있다. 1 2 3 4 5 6 7 8 9 10 public void setInt(int index, int value) { checkIndexLength(index, SIZE_OF_INT); setIntUnchecked(index, value); } void setIntUnchecked(int index, int value) { unsafe.putInt(base, address + index, value); } setInt를 통해 특정 Index(index)에 값(value)를 설정할 수 있다. setIntUnchecked는 Unsafe의 putInt를 통해 넣어야 할 주소(base + address + index)에 값을 설정하는 것을 확인할 수 있다. 반대로 get 계열 메서드를 통해 Slice를 구성하는 데이터의 특정 Offset의 데이터를 조회할 수 있다. 1 2 3 4 5 6 7 8 9 10 public int getInt(int index) { checkIndexLength(index, SIZE_OF_INT); return getIntUnchecked(index); } int getIntUnchecked(int index) { return unsafe.getInt(base, address + index); } Slices Slices는 Slice 생성을 위한 정적 팩토리 메서드를 제공하는 클래스이다. 아래는 int형 배열을 기반으로 하는 Slice를 생성하는 wrappedIntArray 코드이다. 1 2 3 4 5 6 7 public static Slice wrappedIntArray(int[] array, int offset, int length) { if (length == 0) { return EMPTY_SLICE; } return new Slice(array, offset, length); } Usage Slice in Trino Slice는 Trino의 데이터 조작에서 굉장히 많이 사용되고 있으며, 특히 파일 입/출력 시 버퍼로 자주 사용된다. OrcOutputBuffer 등에서 사용되니 코드를 하나씩 확인해보면 좋을 것 같다. 참고자료 Data Structure Alignment - Wikipedia Java Memory Layout - Baeldung","url":"https://leeyh0216.github.io/posts/trino-slice/","@type":"BlogPosting","headline":"Java Object의 Memory Layout과 Trino의 Slice","dateModified":"2022-12-24T15:00:00+09:00","datePublished":"2022-12-24T15:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/trino-slice/"},"@context":"https://schema.org"}</script><title>Java Object의 Memory Layout과 Trino의 Slice | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Java Object의 Memory Layout과 Trino의 Slice</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java Object의 Memory Layout과 Trino의 Slice</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Dec 24, 2022, 3:00 PM +0900" prep="on" > Dec 24, 2022 <i class="unloaded">2022-12-24T15:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3788 words">21 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="java-object의-memory-layout">Java Object의 Memory Layout</h1><h2 id="data-structure-alignment">Data structure alignment</h2><h3 id="word">WORD</h3><p>CPU에서 어떤 작업을 하기 위해서는 메모리 영역의 데이터를 레지스터로 옮겨야 한다. 이 때 CPU가 레지스터로 데이터를 옮겨오는 단위를 <a href="https://ko.wikipedia.org/wiki/%EC%9B%8C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)">WORD</a>라고 한다. WORD의 크기는 CPU마다 다르다.</p><ul><li>32bit CPU에서는 WORD의 크기가 32bit<li>64bit CPU에서는 WORD의 크기가 64bit</ul><p>다만 Intel x86에서 WORD=16bit로 정해놓은 MACRO가 존재하였기 때문에, 어셈블리 상에서는 아직도 WORD=16bit 로 표현한다. DOUBLE WORD=32bit, QUAD WORD=64bit로 표현한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>int main(void) {
    int arr[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    for(int i = 0; i &lt; 10; i++) {
        arr[i] = i;
    }

    return 0;
}
</pre></table></code></div></div><p>위의 코드를 어셈블리로 변경했을 때, Loop 내의 <code class="language-plaintext highlighter-rouge">arr[i] = i</code> 구문은 아래와 같이 표현된다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>mov     eax, DWORD PTR [rbp-4]
cdqe
mov     edx, DWORD PTR [rbp-4]
mov     DWORD PTR [rbp-48+rax*4], edx
</pre></table></code></div></div><p>여기서 <code class="language-plaintext highlighter-rouge">eax</code>, <code class="language-plaintext highlighter-rouge">edx</code> 등의 레지스터로 DWORD PTR 씩 옮기는 것을 볼 수 있는데, 32bit 메모리 주소만큼의 데이터를 복사하는 것으로 이해할 수 있다.</p><h3 id="aligned-memory-access-vs-misaligned-memory-access">Aligned Memory Access vs Misaligned Memory Access</h3><p>CPU는 메모리 공간에 접근할 때, WORD 단위로 접근한다. 만일 32bit CPU가 Memory를 접근할 때는 (0x0 ~ 0x3), (0x4 ~ 0x7) … 와 같이 4의 배수씩 끊어서 메모리 공간에 접근한다.</p><p>4byte 짜리 데이터가 (0x0 ~ 0x3) 주소에 위치해있다고 생각해보자. CPU에서 레지스터에 해당 데이터를 올려놓기 위해서는 (0x0 ~ 0x3) 주소 구간 1번만을 접근하면 된다. 이러한 메모리 접근을 Aligned Memory Access라고 한다.</p><p>반면 같은 데이터가 0x1 ~ 0x4 공간에 위치해있다면, CPU는 (0x0 ~ 0x3), (0x4 ~ 0x7)과 같이 2회 메모리에 접근해야 온전한 데이터를 가져올 수 있다. 이러한 메모리 접근을 Misaligned Memory Access라고 한다.</p><h3 id="data-structure-padding">Data structure padding</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>#include&lt;stdio.h&gt;

struct MyStruct {
        short a;
        int b;
};
int main(void) {
        printf("%d", sizeof(MyStruct));
        return 0;
}
</pre></table></code></div></div><p>우리가 알고 있는 프로그래밍 지식으로 생각하면 위 코드는 6을 출력해야 한다. <code class="language-plaintext highlighter-rouge">short</code>형 2byte + <code class="language-plaintext highlighter-rouge">int</code>형 4byte = 6byte이기 때문이다. 그러나 실제로는 8이라는 결과가 출력된다. 이는 CPU의 메모리 접근을 최적화시키기 위하여 컴파일러에서 Padding이라는 것을 삽입하기 때문이다.</p><p>Padding 없이 위 구조체를 메모리 공간에 할당한다면,</p><ul><li>0x0 ~ 0x1: <code class="language-plaintext highlighter-rouge">a</code><li>0x2 ~ 0x3: <code class="language-plaintext highlighter-rouge">b</code>의 상위 2byte<li>0x4 ~ 0x5: <code class="language-plaintext highlighter-rouge">b</code>의 하위 2byte</ul><p>와 같이 할당된다. CPU에서 <code class="language-plaintext highlighter-rouge">a</code>에 접근하기 위해서는 1개 WORD만 가져오면 되지만, <code class="language-plaintext highlighter-rouge">b</code>에 접근하기 위해서는 2개 WORD를 가져와야 한다.</p><p>이러한 문제를 해결하기 위해 Compiler는 Padding을 삽입하여 구조체를 위한 메모리 공간을 아래와 같이 마련한다.</p><ul><li>0x0 ~ 0x1: <code class="language-plaintext highlighter-rouge">a</code><li>0x2 ~ 0x3: Padding<li>0x4 ~ 0x7: <code class="language-plaintext highlighter-rouge">b</code></ul><p>이렇게 되면 메모리 공간은 손해이지만, CPU의 메모리 접근은 최적화된다.</p><blockquote><p>추가로 <code class="language-plaintext highlighter-rouge">aligned</code> 키워드를 통한 Cache Line 최적화 내용도 Data Memory Alignment에 영향을 미치긴 하는데, 현재의 내용과 연관이 깊지 않아 다음에 시간이 되면 다루려 한다.</p></blockquote><h2 id="java-ordinary-object-pointer와-memory-layout">Java Ordinary Object Pointer와 Memory Layout</h2><p>Java에서는 객체를 가리키기 위한 포인터를 Ordinary Object Pointer(OOP)라 한다.</p><ul><li><a href="https://github.com/openjdk/jdk15/blob/master/src/hotspot/share/oops/instanceOop.hpp"><code class="language-plaintext highlighter-rouge">instanceOop</code></a>: 단일 객체를 표현하기 위한 OOP<li><a href="https://github.com/openjdk/jdk15/blob/master/src/hotspot/share/oops/arrayOop.hpp"><code class="language-plaintext highlighter-rouge">arrayOop</code></a>: 배열을 가리키기 위한 OOP</ul><p>이 OOP들은 모두 <a href="https://github.com/openjdk/jdk15/blob/master/src/hotspot/share/oops/oop.hpp"><code class="language-plaintext highlighter-rouge">oopDesc</code></a>라는 클래스를 기반으로 한다. <code class="language-plaintext highlighter-rouge">oopDesc</code>는 <code class="language-plaintext highlighter-rouge">mark word</code>와 <code class="language-plaintext highlighter-rouge">klass word</code> 필드를 포함하고 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">mark word</code>: Object Header 정보를 포함하고 있다. 32bit 운영체제에서는 4byte, 64bit 운영체제에서는 8byte 크기를 가진다.<li><code class="language-plaintext highlighter-rouge">klass word</code>: Language Level에서의 메타데이터를 포함하고 있다. 4byte 크기를 가진다.</ul><p>즉, 모든 자바 객체들은 기본적으로 12byte의 Overhead(64bit 운영체제 기준, 8byte <code class="language-plaintext highlighter-rouge">mark word</code> + 4byte <code class="language-plaintext highlighter-rouge">klass word</code>)를 가지고 있다.</p><h3 id="short-자료형-memory-layout-확인해보기">Short 자료형 Memory Layout 확인해보기</h3><p>Java Object Layout 라이브러리를 사용하면, 자바 객체의 메모리 레이아웃을 확인할 수 있다. 아래 코드를 통해 <code class="language-plaintext highlighter-rouge">Short</code> 타입의 메모리 구조에 대해 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>short a = 1;
System.out.println(ClassLayout.parseClass(Short.class).toPrintable(a));

-- 출력

java.lang.Short object internals:
OFF  SZ    TYPE DESCRIPTION               VALUE
  0   8         (object header: mark)     0x0000004be6566201 (hash: 0x4be65662; age: 0)
  8   4         (object header: class)    0x0003e7b0
 12   2   short Short.value               1
 14   2         (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 2 bytes external = 2 bytes total
</pre></table></code></div></div><ul><li>Offset 0 ~ 7: <code class="language-plaintext highlighter-rouge">mark word</code> 영역. 64bit 운영체제이기 때문에 8byte<li>Offset 8 ~ 11: <code class="language-plaintext highlighter-rouge">klass word</code> 영역. 4byte<li>Offset 12 ~ 13: 실제 Short 데이터 영역. 2byte<li>Offset 14 ~ 15: Padding</ul><p>위에서 설명했듯 CPU에서는 메모리 접근을 최적화하기 위해 WORD 단위로 접근한다. 64bit 운영체제에서는 WORD가 8byte(64bit)이기 때문에 JVM에서는 이에 맞추어 Memory Alignment 단위를 8byte로 지정하고 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>System.out.println(VM.current().details());

-- 출력

# Running 64-bit HotSpot VM.
# Using compressed oop with 3-bit shift.
# Using compressed klass with 3-bit shift.
# WARNING | Compressed references base/shifts are guessed by the experiment!
# WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.
# WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.
# Objects are 8 bytes aligned.
# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
</pre></table></code></div></div><p>위의 “Objects are 8bytes aligned.”라는 메시지를 통해 Java의 Memory Alignment 단위가 8byte라는 것을 확인할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>java.lang.Short object internals:
OFF  SZ    TYPE DESCRIPTION               VALUE
  0   8         (object header: mark)     0x0000004be6566201 (hash: 0x4be65662; age: 0)
  8   4         (object header: class)    0x0003e7b0
 12   2   short Short.value               1
 14   2         (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 2 bytes external = 2 bytes total
</pre></table></code></div></div><p>다시 Short 자료형에 대해 생각해보자면, 12byte의 header(<code class="language-plaintext highlighter-rouge">mark</code>, <code class="language-plaintext highlighter-rouge">klass</code>)와 2byte(Short)의 데이터를 합쳐 총 14byte의 크기임을 확인할 수 있다. 그러나 WORD 단위로 데이터를 Align하기 위해 마지막에 2byte Padding을 추가하는 것이다. Padding을 추가하였기 때문에 2byte의 Space Loss(이 경우 객체 External Fragmentation이기 때문에 External Loss가 추가)가 발생하는 것을 확인할 수 있다.</p><h3 id="short-배열-memory-layout-확인해보기">short 배열 Memory Layout 확인해보기</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>short[] arr = new short[1025];
System.out.println(ClassLayout.parseClass(short[].class).toPrintable(arr));

-- 출력
[S object internals:
OFF  SZ    TYPE DESCRIPTION               VALUE
  0   8         (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4         (object header: class)    0x00006d08
 12   4         (array length)            1025
 12   4         (alignment/padding gap)   
 16   0   short [S.&lt;elements&gt;             N/A
 16   0         (object alignment gap)    
Instance size: 2072 bytes
Space losses: 4 bytes internal + 0 bytes external = 4 bytes total
</pre></table></code></div></div><p>배열에 대한 OOP에는 배열 길이에 대한 정보를 포함하고 있다. <code class="language-plaintext highlighter-rouge">mark</code>, <code class="language-plaintext highlighter-rouge">klass</code> 헤더 정보 + 배열 길이 + 데이터로 구성된다.</p><ul><li>Offset 0 ~ 7: <code class="language-plaintext highlighter-rouge">mark word</code> 영역. 64bit 운영체제이기 때문에 8byte<li>Offset 8 ~ 11: <code class="language-plaintext highlighter-rouge">klass word</code> 영역. 4byte<li>Offset 12 ~ 15: 배열의 길이. 4byte</ul><p>OOP 공간은 16byte이기 때문에 별도의 Padding이 추가되지 않는다. 16번째 Offset부터 실제 배열의 데이터가 할당되는데, 길이 1025의 배열이므로 총 2050byte를 차지하게 된다. 여기서 알 수 있는 점은 다음과 같다.</p><ul><li>예상되는 배열 객체의 크기는 2066byte(= 16byte + 2050byte(2byte * 1025))이다.<li>실제 배열 객체의 크기는 2072byte(= 16byte + 2050byte(2byte * 1025) + 6byte(=Padding))이다.</ul><h1 id="java의-unsafe를-이용한-저수준-데이터-조작">Java의 Unsafe를 이용한 저수준 데이터 조작</h1><p>C, C++과 같은 저수준 언어에서는 Pointer를 통한 저수준 데이터 조작이 가능하다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>#include&lt;stdio.h&gt;

int main(void){
        int arr[4] = {1,2,3,4};
        int* ptr = arr;
        for(int i = 0; i &lt; 4; i++) {
                printf("%p\n", ptr);

                *ptr = (*ptr) * 10;
                ptr = ptr + 1;
        }
        for(int i = 0; i &lt; 4; i++) {
                printf("%d\n", arr[i]);
        }
        return 0;
}
</pre></table></code></div></div><p>자바에서는 객체의 주소값을 직접 참조하는 기능을 표면적으로는 제공하지 않지만, <code class="language-plaintext highlighter-rouge">Unsafe</code>를 사용하면 위와 같은 코드를 작성할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre>import sun.misc.Unsafe;

import java.lang.reflect.Field;

import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
import static sun.misc.Unsafe.ARRAY_INT_INDEX_SCALE;

public class UnsafeIteration {
    public static Unsafe getUnsafe() throws Exception {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        return (Unsafe) theUnsafe.get(null);
    }

    public void mulAndPrint() throws Exception {
        Unsafe unsafe = getUnsafe();
        int[] arr = {1, 2, 3, 4};

        Object base = arr;
        long address = ARRAY_INT_BASE_OFFSET;

        for(int i = 0; i &lt; 4; i++) {
            System.out.println("Address " + i +"th element: " + address);

            unsafe.putInt(base, address, unsafe.getInt(base, address) * 10);
            address += ARRAY_INT_INDEX_SCALE;

        }
        for(int i = 0; i &lt; 4; i++)
            System.out.println(arr[i]);
    }

    public static void main(String[] args) throws Exception {
        new UnsafeIteration().mulAndPrint();
    }
}
</pre></table></code></div></div><p>위 코드의 <code class="language-plaintext highlighter-rouge">mulAndPrint</code> 동작은 다음과 같다.</p><ul><li>특정 객체를 가리키기 위한 Pointer인 <code class="language-plaintext highlighter-rouge">base</code> Object 객체를 만들고, <code class="language-plaintext highlighter-rouge">base</code>가 <code class="language-plaintext highlighter-rouge">arr</code>을 가리키도록 만든다.<li>데이터의 주소를 가리키기 위한 변수인 <code class="language-plaintext highlighter-rouge">address</code>를 선언한다.<ul><li>Unsafe에서 주소 참조는 두가지로 나뉜다.<ul><li>절대 주소를 사용하는 방법<li>상대 주소를 사용하는 방법: 기준 주소(객체 포인터)와 Offset을 사용하여 절대 주소 계산</ul><li>여기서는 기준 주소와 Offset을 사용하는 방법을 사용한다.<li>위에서 설명했듯, 배열 객체는 16byte의 Header(<code class="language-plaintext highlighter-rouge">mark</code> + <code class="language-plaintext highlighter-rouge">klass</code> + 배열 길이)를 사용한다. 그렇기 때문에 <code class="language-plaintext highlighter-rouge">ARRAY_INT_BASE_OFFSET</code>을 사용하여 시작 주소를 옮긴다.</ul><li>Loop를 순회한다.<ul><li><code class="language-plaintext highlighter-rouge">unsafe.getInt(base, address)</code>: 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값으로부터 4byte int를 읽는다.<li><code class="language-plaintext highlighter-rouge">unsafe.putInt(base, address, unsafe.getint(base, address) * 10)</code>: 기준 주소에 Offset 주소를 더한 뒤, 해당 주소값에 4byte int 데이터를 넣는다.<li><code class="language-plaintext highlighter-rouge">address += ARRAY_INT_INDEX_SCALE</code>: 주소 값에 4byte만큼을 증가시킨다.</ul></ul><blockquote><p>위 연산들은 모두 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>를 통해서도 동일하게 수행할 수 있다. <a href="https://stackoverflow.com/questions/12226123/busted-how-to-speed-up-a-byte-lookup-to-be-faster-using-sun-misc-unsafe">How to speed up a byte[] lookup to be faster using sun.misc.Unsafe?</a> 글을 참고해보면 Unsafe 방식이 10 ~ 15% 가량의 성능 이점이 있을 수 있다고 되어 있다.</p><p><code class="language-plaintext highlighter-rouge">Unsafe</code>는 잘못 사용할 경우 저수준 언어에서의 Segmentation Fault 등의 문제를 동일하게 겪을 수 있기 때문에, Java에서는 Public API로 노출되어 있지 않다.</p><p>다만 Trino나 Spark과 같은 성능이 중시되는 애플리케이션에서는 MicroOptimization 또한 중요하기 때문에 Unsafe를 사용한다.</p></blockquote><h1 id="trino의-slice">Trino의 Slice</h1><p>사실 정확히 표현하자면 Trino에서 사용하는 Airlift의 <a href="https://github.com/airlift/slice">Slice</a> 라이브러리이다.</p><p>Slice는 “Slice is a Java library for efficiently working with heap and off-heap memory.”와 같은 소개를 하고 있는데, Trino에서는 데이터의 저장/전송 등에 Slice를 사용한다.</p><p>내부적으로 사용되는 라이브러리이기 때문에, 별도의 공식 문서가 없어 코드 자체를 확인해보았다.</p><h2 id="slice">Slice</h2><p><code class="language-plaintext highlighter-rouge">Unsafe</code>를 사용하여 저수준 데이터 조작을 수행하는 클래스이다. <a href="https://github.com/airlift/slice/blob/master/src/main/java/io/airlift/slice/Slice.java">Slice</a> 에서 코드 확인이 가능하다.</p><p>6개의 멤버 변수를 포함하고 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>private final Object base;

private final long address;

private final int size;

private final long retainedSize;

private final Object reference;

private int hash;
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">reference</code>와 <code class="language-plaintext highlighter-rouge">hash</code>를 제외한 각 변수의 역할은 다음과 같다.</p><ul><li><code class="language-plaintext highlighter-rouge">base</code>: Slice 객체가 가리키는 원본 객체이다. <code class="language-plaintext highlighter-rouge">Slice</code>에서 <code class="language-plaintext highlighter-rouge">Unsafe</code>의 상대 주소를 사용하기 때문에, 기준점이 되는 주소를 제공한다고 볼 수 있다.<li><code class="language-plaintext highlighter-rouge">address</code>: 원본 객체의 데이터 시작 주소를 의미한다. 위에서 설명했듯 헤더 데이터 등을 제외하고 실제로 데이터가 시작되는 주소 값을 의미한다.<li><code class="language-plaintext highlighter-rouge">size</code>: 데이터의 크기이다.<li><code class="language-plaintext highlighter-rouge">retainedSize</code>: Slice 객체의 크기를 포함한 데이터의 크기이다.</ul><h3 id="생성자">생성자</h3><p><code class="language-plaintext highlighter-rouge">Slice</code>의 생성자는 모두 <code class="language-plaintext highlighter-rouge">private</code> 접근 제한자를 가지고 있다. 외부에서의 생성은 팩토리 역할을 수행하는 <code class="language-plaintext highlighter-rouge">Slices</code> 클래스에 존재한다.</p><p>간단하게 <code class="language-plaintext highlighter-rouge">int</code> 타입 배열을 다루는 <code class="language-plaintext highlighter-rouge">Slice</code>의 생성자에 대해 확인해본다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>Slice(int[] base, int offset, int length)
{
    requireNonNull(base, "base is null");
    checkPositionIndexes(offset, offset + length, base.length);

    this.base = base;
    this.address = sizeOfIntArray(offset);
    this.size = multiplyExact(length, ARRAY_INT_INDEX_SCALE);
    this.retainedSize = INSTANCE_SIZE + sizeOf(base);
    this.reference = (offset == 0 &amp;&amp; length == base.length) ? COMPACT : NOT_COMPACT;
}
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">base</code>는 <code class="language-plaintext highlighter-rouge">int</code> 배열을 가리킨다.<li><code class="language-plaintext highlighter-rouge">address</code>는 <code class="language-plaintext highlighter-rouge">sizeOfIntArray</code>를 호출하여 초기화한다.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>public static long sizeOfIntArray(int length)
{
  return ARRAY_INT_BASE_OFFSET + (((long) ARRAY_INT_INDEX_SCALE) * length);
}
</pre></table></code></div></div><ul><li>Slice 생성 시 원본 배열의 일부 구간(offset ~ offset + length - 1)을 기준으로 생성할 수 있기 때문에, 데이터의 시작 주소(<code class="language-plaintext highlighter-rouge">address</code>)는 <code class="language-plaintext highlighter-rouge">ARRAY_INT_BASE_OFFSET</code>에 Skip할 <code class="language-plaintext highlighter-rouge">offset</code> * <code class="language-plaintext highlighter-rouge">ARRAY_INT_INDEX_SCALE</code>만큼을 더해주어야 한다.</ul><li><code class="language-plaintext highlighter-rouge">size</code>는 데이터의 실제 크기를 계산하여 집어넣는다.<li><code class="language-plaintext highlighter-rouge">retainedSize</code>는 <code class="language-plaintext highlighter-rouge">Slice</code> 객체 자체의 크기(<code class="language-plaintext highlighter-rouge">INSTANCE_SIZE</code>)에 데이터의 크기를 더한 크기이다.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>private static final int INSTANCE_SIZE = toIntExact(ClassLayout.parseClass(Slice.class).instanceSize());
</pre></table></code></div></div></ul><h3 id="set-get-계열-메서드"><code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">get</code> 계열 메서드</h3><p><code class="language-plaintext highlighter-rouge">Slice</code>의 <code class="language-plaintext highlighter-rouge">set</code> 계열 메서드를 통해 <code class="language-plaintext highlighter-rouge">Slice</code>를 구성하는 데이터의 특정 Offset에 데이터를 설정할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>public void setInt(int index, int value)
{
    checkIndexLength(index, SIZE_OF_INT);
    setIntUnchecked(index, value);
}

void setIntUnchecked(int index, int value)
{
    unsafe.putInt(base, address + index, value);
}
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">setInt</code>를 통해 특정 Index(<code class="language-plaintext highlighter-rouge">index</code>)에 값(<code class="language-plaintext highlighter-rouge">value</code>)를 설정할 수 있다. <code class="language-plaintext highlighter-rouge">setIntUnchecked</code>는 <code class="language-plaintext highlighter-rouge">Unsafe</code>의 <code class="language-plaintext highlighter-rouge">putInt</code>를 통해 넣어야 할 주소(<code class="language-plaintext highlighter-rouge">base</code> + <code class="language-plaintext highlighter-rouge">address</code> + <code class="language-plaintext highlighter-rouge">index</code>)에 값을 설정하는 것을 확인할 수 있다.</p><p>반대로 <code class="language-plaintext highlighter-rouge">get</code> 계열 메서드를 통해 <code class="language-plaintext highlighter-rouge">Slice</code>를 구성하는 데이터의 특정 Offset의 데이터를 조회할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>public int getInt(int index)
{
    checkIndexLength(index, SIZE_OF_INT);
    return getIntUnchecked(index);
}

int getIntUnchecked(int index)
{
    return unsafe.getInt(base, address + index);
}
</pre></table></code></div></div><h2 id="slices">Slices</h2><p><code class="language-plaintext highlighter-rouge">Slices</code>는 <code class="language-plaintext highlighter-rouge">Slice</code> 생성을 위한 정적 팩토리 메서드를 제공하는 클래스이다. 아래는 <code class="language-plaintext highlighter-rouge">int</code>형 배열을 기반으로 하는 <code class="language-plaintext highlighter-rouge">Slice</code>를 생성하는 <code class="language-plaintext highlighter-rouge">wrappedIntArray</code> 코드이다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>public static Slice wrappedIntArray(int[] array, int offset, int length)
{
    if (length == 0) {
        return EMPTY_SLICE;
    }
    return new Slice(array, offset, length);
}
</pre></table></code></div></div><h2 id="usage-slice-in-trino">Usage Slice in Trino</h2><p><code class="language-plaintext highlighter-rouge">Slice</code>는 Trino의 데이터 조작에서 굉장히 많이 사용되고 있으며, 특히 파일 입/출력 시 버퍼로 자주 사용된다. <code class="language-plaintext highlighter-rouge">OrcOutputBuffer</code> 등에서 사용되니 코드를 하나씩 확인해보면 좋을 것 같다.</p><h1 id="참고자료">참고자료</h1><ul><li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data Structure Alignment - Wikipedia</a><li><a href="https://www.baeldung.com/java-memory-layout">Java Memory Layout - Baeldung</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/trino/" class="post-tag no-text-decoration" >trino</a> <a href="/tags/airlift/" class="post-tag no-text-decoration" >airlift</a> <a href="/tags/unsafe/" class="post-tag no-text-decoration" >unsafe</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Java Object의 Memory Layout과 Trino의 Slice - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/trino-slice/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Java Object의 Memory Layout과 Trino의 Slice - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/trino-slice/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Java Object의 Memory Layout과 Trino의 Slice - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/trino-slice/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/trino-summit-2023/"><div class="card-body"> <span class="timeago small" > Dec 16, 2023 <i class="unloaded">2023-12-16T18:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trino Summit 2023 발표 회고</h3><div class="text-muted small"><p> Trino Summit 2023 2023년 12월 13 ~ 14일(한국 기준 14 ~ 15일)에 Trino Summit 2023이 온라인에서 열렸다. Trino 블로그에도 Trino Summit 2023 nears with an awesome lineup에 “SK Telecom: Unstructured data analysis using polym...</p></div></div></a></div><div class="card"> <a href="/posts/Orc-Impl-1/"><div class="card-body"> <span class="timeago small" > Jan 1, 2023 <i class="unloaded">2023-01-01T01:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>ORC Spec을 보고 Reader/Writer를 구현해보기 - PostScript</h3><div class="text-muted small"><p> 개요 대부분의 오픈소스 ETL 프로젝트(Spark, Flink 등)들에서는 ORC, Parquet 등의 컬럼 기반 파일 포맷의 읽기/쓰기를 지원하며, 고수준 API를 통해 간단히 특정 포맷으로의 읽기/쓰기를 수행할 수 있다. 1 2 3 4 5 -- ORC의 읽기 spark.read.orc("PATH_TO_READ").show(100, false) ...</p></div></div></a></div><div class="card"> <a href="/posts/truth_of_threadpoolexecutor/"><div class="card-body"> <span class="timeago small" > Feb 21, 2020 <i class="unloaded">2020-02-21T01:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>ThreadPoolExecutor에 대한 오해와 진실</h3><div class="text-muted small"><p> ThreadPoolExecutor에 대한 오해와 진실 회사에서 팀원 분이 코드 리뷰를 해주셨는데, ThreadPoolExecutor을 잘못 사용하고 있다는 내용이었다. 내가 작성한 원본 코드는 대략 아래와 같다. int numTasks = 60; CountDownLatch countDownLatch = new CountDownLatch(numTa...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spark-adaptive-query-execution/" class="btn btn-outline-primary" prompt="Older"><p>Apache Spark 3.0에서 도입된 Adaptive Query Execution 알아보기</p></a> <a href="/posts/Orc-Impl-1/" class="btn btn-outline-primary" prompt="Newer"><p>ORC Spec을 보고 Reader/Writer를 구현해보기 - PostScript</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
