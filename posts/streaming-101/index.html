<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Streaming Systems - Streaming 101" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Streaming 101 스트리밍 데이터 처리는 다음과 같은 장점을 가지고 있다. 배치 시스템에 비해 낮은 레이턴시를 보장할 수 있는 방법이다. 무한한 크기의 데이터를 처리하는 시스템을 통해 거대하고 Unbound 된 데이터를 처리할 수 있다. 데이터를 처리 워크로드를 분산시킬 수 있다. 스트리밍 시스템은 무한한 데이터를 처리할 수 있도록 디자인된 데이터 처리 엔진이다. 데이터를 분류하는 기준은 크게 두 가지가 존재하는데, Cardinality와 Constitution이다. Cardinality 데이터의 크기를 의미한다. Cardinality를 기준으로 데이터를 분류하면 Bounded Data와 Unbounded Data로 분류할 수 있다. Bounded Data: 유한한 크기를 가진 데이터 Unbounded Data: (이론적으로) 무한한 크기를 가진 데이터 Constitution 데이터와 상호작용할 수 있는 방법을 의미한다. Table: 특정 시점에서의 데이터를 바라보는 관점이다. Stream: 시간에 걸쳐 변화하는 데이터를 바라보는 관점이다. Event time vs Processing time Unbound Data 처리를 위해서는 Time domain에 대해 이해하여야 한다. Time domain은 두가지가 존재한다. Event time: 이벤트가 실제로 발생한 시간 Processing time: 시스템에서 이벤트가 관측된 시간 이상적으로는 Event가 발생하자마자 시스템에서 즉시 처리되어야 하므로 Event time과 Processing time이 같다. 하지만 실제로는 입력 데이터(모바일 환경에서는 네트워크 등의 상황 때문에 데이터 전송이 늦어질 수 있음), 실행 엔진(엔진에 따라 데이터를 처리하는 시점이 다름), 하드웨어(여러 Application이 Hardware를 Share하는 형태이기 때문에 지연이 발생할 수 있음)의 특성 때문에 Event time과 Processing time 사이에 Skew가 발생한다. 출처: O’reilly - The world beyond streaming 101 이상적인 상황에서는 Event가 발생함과 동시에 처리되기 때문에 그래프에 ideal과 같은 곡선이 그려져야 한다. 그러나 여러가지 이유로 인해 데이터의 처리가 늦어지기 때문에 Event time과 Processing time 사이에 갭이 발생하게 되고, 이를 Event time Skew(Processing time lag)이라고 표현한다. Processing time 기준으로 데이터를 처리하게 되면 Event time skew 때문에 부정확한 결과가 만들어질 수 있다. 그러나 Event time 기준으로 데이터를 처리하는 것 또한 문제가 발생할 수 있다. 언제 처리해야 모든 Event가 발생했는지 판단하기 어렵기 때문이다.(ex. 모바일 환경에서 비행기 모드로 진입 후 발송되지 않았던 데이터가 하루 뒤 시스템에 들어오게 된다면?) Data processing patterns Bounded Data 배치 시스템에서 데이터를 처리하는 일반적인 방식. 저장되어 있는 데이터를 읽어 결과물을 출력한다. Unbounded Data: Batch 배치 시스템은 명시적으로 Unbounded Data를 처리할 수 있도록 디자인되어 있지는 않지만, Unbounded Data를 Bound Data로 쪼개어 처리하는 방식으로 Unbounded Data를 처리할 수 있다. Fixed windows 입력 데이터를 고정된 Window로 쪼개어 반복적으로 처리한다. 예를 들어 로그 데이터의 경우 시간 단위의 디렉토리 혹은 파일로 저장하고 특정 시간에 한번에 읽어 처리할 수 있다. 물론 이러한 방식도 정말 늦게 들어오는 데이터(Late data)를 처리한다거나, 시간 단위로 데이터를 저장할 수 없을 경우 등의 문제점이 있을 수 있다. Sessions Session은 일반적으로 사용자의 활동 시간(시작 ~ 종료)를 의미한다. 세션의 길이는 가변적이기 때문에, Fixed window로 처리할 경우 위의 붉은 구간과 같이 잘릴 수 있다. 그렇기 때문에 Window의 크기를 크게 잡거나(아무리 크게 잡아도 잘릴 수 있음) 이전 결과를 참조(처리 로직의 복잡도가 높아질 수 있음)하여 처리하게 된다. Unbounded Data: Streaming 배치 시스템이 Ad-hoc하게 Unbounded Data를 처리하는 것과 달리 스트리밍 시스템은 애초에 Unbounded Data를 처리하도록 설계되었다. 그러나 스트리밍 시스템에서도 Unbounded Data를 처리하는데 아래와 같은 장애물이 있다. 데이터들이 Event time 순서에 맞게 순차적으로 들어오지 않기 때문에, 데이터를 처리하는 파이프라인 내에서 시간 기준의 정렬이 필요하다. Event time skew가 발생하기 때문에 Event가 발생한 시점부터 상수 시간 내에 항상 해당 Event를 볼 수 있다고 단정할 수 없다. 이러한 특성을 가지는 데이터를 다루는 데에 필요한 접근은 Time-agnostic, Approximation, Windowing by processing time, Windowing by event time 으로 분류할 수 있다. Time-agnostic Time-agnostic 처리는 시간과 관계 없는 데이터를 처리하는데에 사용된다. 이러한 데이터를 처리 할 때는 스트리밍 시스템이 단순히 데이터를 전달하는 역할 밖에 하지 않는다. Filtering 가장 기본적인 Time-agnostic 연산 중 하나이다. 하나의 데이터 요소를 데이터의 특성으로 걸러내는 방식이기 때문에, 다른 데이터와 연관이 없다. 결과적으로 데이터가 Unbounded, Unordeded, Event time skew 되더라도 아무런 상관이 없다. Inner joins 두 개의 데이터 스트림이 존재할 때, 하나의 데이터 스트림을 특정 시간 동안 모아놓고(Buffering), 다른 하나의 데이터 스트림이 들어오면 버퍼링 된 데이터와 Join을 수행하는 방식이다. Windowing Windowing은 데이터에 대한 처리를 수행하기 위해 데이터를 유한한 크기로 분할하는 것이다. Windowing에는 Fixed windows, Sliding windows, Sessions와 같은 방법이 존재한다. Fixed windows(aka tumbling windows) Fixed windows는 고정된 길이의 Window로 데이터를 분할하는 방식이다. Sliding windows(aka hopping windows) Sliding windows는 고정된 길이와 고정된 주기로 정의할 수 있다. 주기가 길이보다 짧은 경우 Window가 Overlap 된다. 주기와 길이가 동일한 경우 Fixed windows가 된다. 주기가 길이보다 긴 경우 데이터를 Sampling하는 효과가 발생한다. Sessions Session은 유동적인 Window 형태를 가진다. Time domain 기준으로 Windowing 할 수도 있다. Windowing by processing time 일정한 Processing time 동안 입력 데이터를 버퍼링하여 처리하는 방식이다. 이 방식은 시스템에 입력되어 처리되는 시간(Processing time)만 고려하면 되기 때문에(다른 말로 Event time을 전혀 신경쓰지 않기 때문에), 데이터의 지연이나 시간에 의한 섞임이라는 개념이 존재할 수 없다(는 장점이 있다). 그러나 Event time에 종속적인 분석은 불가능하다.(예를 들어 사용자가 언제, 어떤 순서로 어떤 행위를 수행했는지에 대한 분석 등) Windowing by event time Event time을 반영하여 입력 데이터를 쪼개서 처리하는 방식이다. 데이터가 Input 축에서는 Event time에 관계 없이 Processing time에 아무렇게나 분포되어 있지만, Output 축으로 이동할 때(데이터가 처리된 이후)는 Event time에 맞게 재배열된 후 처리된다. Event time 기준으로 데이터를 처리하게 되면 정확도는 Processing time 기준으로 처리하는 것보다 정확도가 높지만, 다음과 같은 단점을 가지게 된다. Buffering: Windowing by processing time 방식과는 달리 Event의 지연 전송 등을 고려하기 때문에 더 많은 데이터를 버퍼링해야 한다. Completeness: 데이터의 지연 전송 등으로 언제 마지막 데이터가 들어오는지 알 수 없기 때문에, Window의 끝을 정하기가 어렵다. 대부분의 Framework에서는 Heuristic 방식을 사용하여 Window의 끝을 판단한다." /><meta property="og:description" content="Streaming 101 스트리밍 데이터 처리는 다음과 같은 장점을 가지고 있다. 배치 시스템에 비해 낮은 레이턴시를 보장할 수 있는 방법이다. 무한한 크기의 데이터를 처리하는 시스템을 통해 거대하고 Unbound 된 데이터를 처리할 수 있다. 데이터를 처리 워크로드를 분산시킬 수 있다. 스트리밍 시스템은 무한한 데이터를 처리할 수 있도록 디자인된 데이터 처리 엔진이다. 데이터를 분류하는 기준은 크게 두 가지가 존재하는데, Cardinality와 Constitution이다. Cardinality 데이터의 크기를 의미한다. Cardinality를 기준으로 데이터를 분류하면 Bounded Data와 Unbounded Data로 분류할 수 있다. Bounded Data: 유한한 크기를 가진 데이터 Unbounded Data: (이론적으로) 무한한 크기를 가진 데이터 Constitution 데이터와 상호작용할 수 있는 방법을 의미한다. Table: 특정 시점에서의 데이터를 바라보는 관점이다. Stream: 시간에 걸쳐 변화하는 데이터를 바라보는 관점이다. Event time vs Processing time Unbound Data 처리를 위해서는 Time domain에 대해 이해하여야 한다. Time domain은 두가지가 존재한다. Event time: 이벤트가 실제로 발생한 시간 Processing time: 시스템에서 이벤트가 관측된 시간 이상적으로는 Event가 발생하자마자 시스템에서 즉시 처리되어야 하므로 Event time과 Processing time이 같다. 하지만 실제로는 입력 데이터(모바일 환경에서는 네트워크 등의 상황 때문에 데이터 전송이 늦어질 수 있음), 실행 엔진(엔진에 따라 데이터를 처리하는 시점이 다름), 하드웨어(여러 Application이 Hardware를 Share하는 형태이기 때문에 지연이 발생할 수 있음)의 특성 때문에 Event time과 Processing time 사이에 Skew가 발생한다. 출처: O’reilly - The world beyond streaming 101 이상적인 상황에서는 Event가 발생함과 동시에 처리되기 때문에 그래프에 ideal과 같은 곡선이 그려져야 한다. 그러나 여러가지 이유로 인해 데이터의 처리가 늦어지기 때문에 Event time과 Processing time 사이에 갭이 발생하게 되고, 이를 Event time Skew(Processing time lag)이라고 표현한다. Processing time 기준으로 데이터를 처리하게 되면 Event time skew 때문에 부정확한 결과가 만들어질 수 있다. 그러나 Event time 기준으로 데이터를 처리하는 것 또한 문제가 발생할 수 있다. 언제 처리해야 모든 Event가 발생했는지 판단하기 어렵기 때문이다.(ex. 모바일 환경에서 비행기 모드로 진입 후 발송되지 않았던 데이터가 하루 뒤 시스템에 들어오게 된다면?) Data processing patterns Bounded Data 배치 시스템에서 데이터를 처리하는 일반적인 방식. 저장되어 있는 데이터를 읽어 결과물을 출력한다. Unbounded Data: Batch 배치 시스템은 명시적으로 Unbounded Data를 처리할 수 있도록 디자인되어 있지는 않지만, Unbounded Data를 Bound Data로 쪼개어 처리하는 방식으로 Unbounded Data를 처리할 수 있다. Fixed windows 입력 데이터를 고정된 Window로 쪼개어 반복적으로 처리한다. 예를 들어 로그 데이터의 경우 시간 단위의 디렉토리 혹은 파일로 저장하고 특정 시간에 한번에 읽어 처리할 수 있다. 물론 이러한 방식도 정말 늦게 들어오는 데이터(Late data)를 처리한다거나, 시간 단위로 데이터를 저장할 수 없을 경우 등의 문제점이 있을 수 있다. Sessions Session은 일반적으로 사용자의 활동 시간(시작 ~ 종료)를 의미한다. 세션의 길이는 가변적이기 때문에, Fixed window로 처리할 경우 위의 붉은 구간과 같이 잘릴 수 있다. 그렇기 때문에 Window의 크기를 크게 잡거나(아무리 크게 잡아도 잘릴 수 있음) 이전 결과를 참조(처리 로직의 복잡도가 높아질 수 있음)하여 처리하게 된다. Unbounded Data: Streaming 배치 시스템이 Ad-hoc하게 Unbounded Data를 처리하는 것과 달리 스트리밍 시스템은 애초에 Unbounded Data를 처리하도록 설계되었다. 그러나 스트리밍 시스템에서도 Unbounded Data를 처리하는데 아래와 같은 장애물이 있다. 데이터들이 Event time 순서에 맞게 순차적으로 들어오지 않기 때문에, 데이터를 처리하는 파이프라인 내에서 시간 기준의 정렬이 필요하다. Event time skew가 발생하기 때문에 Event가 발생한 시점부터 상수 시간 내에 항상 해당 Event를 볼 수 있다고 단정할 수 없다. 이러한 특성을 가지는 데이터를 다루는 데에 필요한 접근은 Time-agnostic, Approximation, Windowing by processing time, Windowing by event time 으로 분류할 수 있다. Time-agnostic Time-agnostic 처리는 시간과 관계 없는 데이터를 처리하는데에 사용된다. 이러한 데이터를 처리 할 때는 스트리밍 시스템이 단순히 데이터를 전달하는 역할 밖에 하지 않는다. Filtering 가장 기본적인 Time-agnostic 연산 중 하나이다. 하나의 데이터 요소를 데이터의 특성으로 걸러내는 방식이기 때문에, 다른 데이터와 연관이 없다. 결과적으로 데이터가 Unbounded, Unordeded, Event time skew 되더라도 아무런 상관이 없다. Inner joins 두 개의 데이터 스트림이 존재할 때, 하나의 데이터 스트림을 특정 시간 동안 모아놓고(Buffering), 다른 하나의 데이터 스트림이 들어오면 버퍼링 된 데이터와 Join을 수행하는 방식이다. Windowing Windowing은 데이터에 대한 처리를 수행하기 위해 데이터를 유한한 크기로 분할하는 것이다. Windowing에는 Fixed windows, Sliding windows, Sessions와 같은 방법이 존재한다. Fixed windows(aka tumbling windows) Fixed windows는 고정된 길이의 Window로 데이터를 분할하는 방식이다. Sliding windows(aka hopping windows) Sliding windows는 고정된 길이와 고정된 주기로 정의할 수 있다. 주기가 길이보다 짧은 경우 Window가 Overlap 된다. 주기와 길이가 동일한 경우 Fixed windows가 된다. 주기가 길이보다 긴 경우 데이터를 Sampling하는 효과가 발생한다. Sessions Session은 유동적인 Window 형태를 가진다. Time domain 기준으로 Windowing 할 수도 있다. Windowing by processing time 일정한 Processing time 동안 입력 데이터를 버퍼링하여 처리하는 방식이다. 이 방식은 시스템에 입력되어 처리되는 시간(Processing time)만 고려하면 되기 때문에(다른 말로 Event time을 전혀 신경쓰지 않기 때문에), 데이터의 지연이나 시간에 의한 섞임이라는 개념이 존재할 수 없다(는 장점이 있다). 그러나 Event time에 종속적인 분석은 불가능하다.(예를 들어 사용자가 언제, 어떤 순서로 어떤 행위를 수행했는지에 대한 분석 등) Windowing by event time Event time을 반영하여 입력 데이터를 쪼개서 처리하는 방식이다. 데이터가 Input 축에서는 Event time에 관계 없이 Processing time에 아무렇게나 분포되어 있지만, Output 축으로 이동할 때(데이터가 처리된 이후)는 Event time에 맞게 재배열된 후 처리된다. Event time 기준으로 데이터를 처리하게 되면 정확도는 Processing time 기준으로 처리하는 것보다 정확도가 높지만, 다음과 같은 단점을 가지게 된다. Buffering: Windowing by processing time 방식과는 달리 Event의 지연 전송 등을 고려하기 때문에 더 많은 데이터를 버퍼링해야 한다. Completeness: 데이터의 지연 전송 등으로 언제 마지막 데이터가 들어오는지 알 수 없기 때문에, Window의 끝을 정하기가 어렵다. 대부분의 Framework에서는 Heuristic 방식을 사용하여 Window의 끝을 판단한다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/streaming-101/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/streaming-101/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-06-22T15:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Streaming Systems - Streaming 101" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Streaming 101 스트리밍 데이터 처리는 다음과 같은 장점을 가지고 있다. 배치 시스템에 비해 낮은 레이턴시를 보장할 수 있는 방법이다. 무한한 크기의 데이터를 처리하는 시스템을 통해 거대하고 Unbound 된 데이터를 처리할 수 있다. 데이터를 처리 워크로드를 분산시킬 수 있다. 스트리밍 시스템은 무한한 데이터를 처리할 수 있도록 디자인된 데이터 처리 엔진이다. 데이터를 분류하는 기준은 크게 두 가지가 존재하는데, Cardinality와 Constitution이다. Cardinality 데이터의 크기를 의미한다. Cardinality를 기준으로 데이터를 분류하면 Bounded Data와 Unbounded Data로 분류할 수 있다. Bounded Data: 유한한 크기를 가진 데이터 Unbounded Data: (이론적으로) 무한한 크기를 가진 데이터 Constitution 데이터와 상호작용할 수 있는 방법을 의미한다. Table: 특정 시점에서의 데이터를 바라보는 관점이다. Stream: 시간에 걸쳐 변화하는 데이터를 바라보는 관점이다. Event time vs Processing time Unbound Data 처리를 위해서는 Time domain에 대해 이해하여야 한다. Time domain은 두가지가 존재한다. Event time: 이벤트가 실제로 발생한 시간 Processing time: 시스템에서 이벤트가 관측된 시간 이상적으로는 Event가 발생하자마자 시스템에서 즉시 처리되어야 하므로 Event time과 Processing time이 같다. 하지만 실제로는 입력 데이터(모바일 환경에서는 네트워크 등의 상황 때문에 데이터 전송이 늦어질 수 있음), 실행 엔진(엔진에 따라 데이터를 처리하는 시점이 다름), 하드웨어(여러 Application이 Hardware를 Share하는 형태이기 때문에 지연이 발생할 수 있음)의 특성 때문에 Event time과 Processing time 사이에 Skew가 발생한다. 출처: O’reilly - The world beyond streaming 101 이상적인 상황에서는 Event가 발생함과 동시에 처리되기 때문에 그래프에 ideal과 같은 곡선이 그려져야 한다. 그러나 여러가지 이유로 인해 데이터의 처리가 늦어지기 때문에 Event time과 Processing time 사이에 갭이 발생하게 되고, 이를 Event time Skew(Processing time lag)이라고 표현한다. Processing time 기준으로 데이터를 처리하게 되면 Event time skew 때문에 부정확한 결과가 만들어질 수 있다. 그러나 Event time 기준으로 데이터를 처리하는 것 또한 문제가 발생할 수 있다. 언제 처리해야 모든 Event가 발생했는지 판단하기 어렵기 때문이다.(ex. 모바일 환경에서 비행기 모드로 진입 후 발송되지 않았던 데이터가 하루 뒤 시스템에 들어오게 된다면?) Data processing patterns Bounded Data 배치 시스템에서 데이터를 처리하는 일반적인 방식. 저장되어 있는 데이터를 읽어 결과물을 출력한다. Unbounded Data: Batch 배치 시스템은 명시적으로 Unbounded Data를 처리할 수 있도록 디자인되어 있지는 않지만, Unbounded Data를 Bound Data로 쪼개어 처리하는 방식으로 Unbounded Data를 처리할 수 있다. Fixed windows 입력 데이터를 고정된 Window로 쪼개어 반복적으로 처리한다. 예를 들어 로그 데이터의 경우 시간 단위의 디렉토리 혹은 파일로 저장하고 특정 시간에 한번에 읽어 처리할 수 있다. 물론 이러한 방식도 정말 늦게 들어오는 데이터(Late data)를 처리한다거나, 시간 단위로 데이터를 저장할 수 없을 경우 등의 문제점이 있을 수 있다. Sessions Session은 일반적으로 사용자의 활동 시간(시작 ~ 종료)를 의미한다. 세션의 길이는 가변적이기 때문에, Fixed window로 처리할 경우 위의 붉은 구간과 같이 잘릴 수 있다. 그렇기 때문에 Window의 크기를 크게 잡거나(아무리 크게 잡아도 잘릴 수 있음) 이전 결과를 참조(처리 로직의 복잡도가 높아질 수 있음)하여 처리하게 된다. Unbounded Data: Streaming 배치 시스템이 Ad-hoc하게 Unbounded Data를 처리하는 것과 달리 스트리밍 시스템은 애초에 Unbounded Data를 처리하도록 설계되었다. 그러나 스트리밍 시스템에서도 Unbounded Data를 처리하는데 아래와 같은 장애물이 있다. 데이터들이 Event time 순서에 맞게 순차적으로 들어오지 않기 때문에, 데이터를 처리하는 파이프라인 내에서 시간 기준의 정렬이 필요하다. Event time skew가 발생하기 때문에 Event가 발생한 시점부터 상수 시간 내에 항상 해당 Event를 볼 수 있다고 단정할 수 없다. 이러한 특성을 가지는 데이터를 다루는 데에 필요한 접근은 Time-agnostic, Approximation, Windowing by processing time, Windowing by event time 으로 분류할 수 있다. Time-agnostic Time-agnostic 처리는 시간과 관계 없는 데이터를 처리하는데에 사용된다. 이러한 데이터를 처리 할 때는 스트리밍 시스템이 단순히 데이터를 전달하는 역할 밖에 하지 않는다. Filtering 가장 기본적인 Time-agnostic 연산 중 하나이다. 하나의 데이터 요소를 데이터의 특성으로 걸러내는 방식이기 때문에, 다른 데이터와 연관이 없다. 결과적으로 데이터가 Unbounded, Unordeded, Event time skew 되더라도 아무런 상관이 없다. Inner joins 두 개의 데이터 스트림이 존재할 때, 하나의 데이터 스트림을 특정 시간 동안 모아놓고(Buffering), 다른 하나의 데이터 스트림이 들어오면 버퍼링 된 데이터와 Join을 수행하는 방식이다. Windowing Windowing은 데이터에 대한 처리를 수행하기 위해 데이터를 유한한 크기로 분할하는 것이다. Windowing에는 Fixed windows, Sliding windows, Sessions와 같은 방법이 존재한다. Fixed windows(aka tumbling windows) Fixed windows는 고정된 길이의 Window로 데이터를 분할하는 방식이다. Sliding windows(aka hopping windows) Sliding windows는 고정된 길이와 고정된 주기로 정의할 수 있다. 주기가 길이보다 짧은 경우 Window가 Overlap 된다. 주기와 길이가 동일한 경우 Fixed windows가 된다. 주기가 길이보다 긴 경우 데이터를 Sampling하는 효과가 발생한다. Sessions Session은 유동적인 Window 형태를 가진다. Time domain 기준으로 Windowing 할 수도 있다. Windowing by processing time 일정한 Processing time 동안 입력 데이터를 버퍼링하여 처리하는 방식이다. 이 방식은 시스템에 입력되어 처리되는 시간(Processing time)만 고려하면 되기 때문에(다른 말로 Event time을 전혀 신경쓰지 않기 때문에), 데이터의 지연이나 시간에 의한 섞임이라는 개념이 존재할 수 없다(는 장점이 있다). 그러나 Event time에 종속적인 분석은 불가능하다.(예를 들어 사용자가 언제, 어떤 순서로 어떤 행위를 수행했는지에 대한 분석 등) Windowing by event time Event time을 반영하여 입력 데이터를 쪼개서 처리하는 방식이다. 데이터가 Input 축에서는 Event time에 관계 없이 Processing time에 아무렇게나 분포되어 있지만, Output 축으로 이동할 때(데이터가 처리된 이후)는 Event time에 맞게 재배열된 후 처리된다. Event time 기준으로 데이터를 처리하게 되면 정확도는 Processing time 기준으로 처리하는 것보다 정확도가 높지만, 다음과 같은 단점을 가지게 된다. Buffering: Windowing by processing time 방식과는 달리 Event의 지연 전송 등을 고려하기 때문에 더 많은 데이터를 버퍼링해야 한다. Completeness: 데이터의 지연 전송 등으로 언제 마지막 데이터가 들어오는지 알 수 없기 때문에, Window의 끝을 정하기가 어렵다. 대부분의 Framework에서는 Heuristic 방식을 사용하여 Window의 끝을 판단한다.","url":"https://leeyh0216.github.io/posts/streaming-101/","@type":"BlogPosting","headline":"Streaming Systems - Streaming 101","dateModified":"2019-06-22T15:00:00+09:00","datePublished":"2019-06-22T15:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/streaming-101/"},"@context":"https://schema.org"}</script><title>Streaming Systems - Streaming 101 | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Streaming Systems - Streaming 101</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Streaming Systems - Streaming 101</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Jun 22, 2019, 3:00 PM +0900" prep="on" > Jun 22, 2019 <i class="unloaded">2019-06-22T15:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2235 words">12 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="streaming-101">Streaming 101</h1><p>스트리밍 데이터 처리는 다음과 같은 장점을 가지고 있다.</p><ul><li>배치 시스템에 비해 낮은 레이턴시를 보장할 수 있는 방법이다.<li>무한한 크기의 데이터를 처리하는 시스템을 통해 거대하고 Unbound 된 데이터를 처리할 수 있다.<li>데이터를 처리 워크로드를 분산시킬 수 있다.</ul><p>스트리밍 시스템은 무한한 데이터를 처리할 수 있도록 디자인된 데이터 처리 엔진이다.</p><p>데이터를 분류하는 기준은 크게 두 가지가 존재하는데, Cardinality와 Constitution이다.</p><p><strong>Cardinality</strong></p><p>데이터의 크기를 의미한다. Cardinality를 기준으로 데이터를 분류하면 Bounded Data와 Unbounded Data로 분류할 수 있다.</p><ul><li>Bounded Data: 유한한 크기를 가진 데이터<li>Unbounded Data: (이론적으로) 무한한 크기를 가진 데이터</ul><p><strong>Constitution</strong></p><p>데이터와 상호작용할 수 있는 방법을 의미한다.</p><ul><li>Table: 특정 시점에서의 데이터를 바라보는 관점이다.<li>Stream: 시간에 걸쳐 변화하는 데이터를 바라보는 관점이다.</ul><h2 id="event-time-vs-processing-time">Event time vs Processing time</h2><p>Unbound Data 처리를 위해서는 Time domain에 대해 이해하여야 한다. Time domain은 두가지가 존재한다.</p><ul><li>Event time: 이벤트가 실제로 발생한 시간<li>Processing time: 시스템에서 이벤트가 관측된 시간</ul><p>이상적으로는 Event가 발생하자마자 시스템에서 즉시 처리되어야 하므로 Event time과 Processing time이 같다.</p><p>하지만 실제로는 입력 데이터(모바일 환경에서는 네트워크 등의 상황 때문에 데이터 전송이 늦어질 수 있음), 실행 엔진(엔진에 따라 데이터를 처리하는 시점이 다름), 하드웨어(여러 Application이 Hardware를 Share하는 형태이기 때문에 지연이 발생할 수 있음)의 특성 때문에 Event time과 Processing time 사이에 Skew가 발생한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/time_domain_mapping.jpg" alt="Time domain mapping" /></p><blockquote><p>출처: <a href="https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101">O’reilly - The world beyond streaming 101</a></p></blockquote><p>이상적인 상황에서는 Event가 발생함과 동시에 처리되기 때문에 그래프에 ideal과 같은 곡선이 그려져야 한다.</p><p>그러나 여러가지 이유로 인해 데이터의 처리가 늦어지기 때문에 Event time과 Processing time 사이에 갭이 발생하게 되고, 이를 Event time Skew(Processing time lag)이라고 표현한다.</p><p>Processing time 기준으로 데이터를 처리하게 되면 Event time skew 때문에 부정확한 결과가 만들어질 수 있다.</p><p>그러나 Event time 기준으로 데이터를 처리하는 것 또한 문제가 발생할 수 있다. 언제 처리해야 모든 Event가 발생했는지 판단하기 어렵기 때문이다.(ex. 모바일 환경에서 비행기 모드로 진입 후 발송되지 않았던 데이터가 하루 뒤 시스템에 들어오게 된다면?)</p><h1 id="data-processing-patterns">Data processing patterns</h1><h2 id="bounded-data">Bounded Data</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/bounded_data_processing.jpg" alt="Bounded data processing" /></p><p>배치 시스템에서 데이터를 처리하는 일반적인 방식. 저장되어 있는 데이터를 읽어 결과물을 출력한다.</p><h2 id="unbounded-data-batch">Unbounded Data: Batch</h2><p>배치 시스템은 명시적으로 Unbounded Data를 처리할 수 있도록 디자인되어 있지는 않지만, Unbounded Data를 Bound Data로 쪼개어 처리하는 방식으로 Unbounded Data를 처리할 수 있다.</p><h3 id="fixed-windows">Fixed windows</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/bounded_data_batch_fixed_windows.png" alt="Bounded Data with batch - Fixed windows" /></p><p>입력 데이터를 고정된 Window로 쪼개어 반복적으로 처리한다. 예를 들어 로그 데이터의 경우 시간 단위의 디렉토리 혹은 파일로 저장하고 특정 시간에 한번에 읽어 처리할 수 있다.</p><p>물론 이러한 방식도 정말 늦게 들어오는 데이터(Late data)를 처리한다거나, 시간 단위로 데이터를 저장할 수 없을 경우 등의 문제점이 있을 수 있다.</p><h3 id="sessions">Sessions</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/bounded_data_batch_sessions.jpg" alt="Bounded Data with batch - Sessions" /> Session은 일반적으로 사용자의 활동 시간(시작 ~ 종료)를 의미한다. 세션의 길이는 가변적이기 때문에, Fixed window로 처리할 경우 위의 붉은 구간과 같이 잘릴 수 있다.</p><p>그렇기 때문에 Window의 크기를 크게 잡거나(아무리 크게 잡아도 잘릴 수 있음) 이전 결과를 참조(처리 로직의 복잡도가 높아질 수 있음)하여 처리하게 된다.</p><h2 id="unbounded-data-streaming">Unbounded Data: Streaming</h2><p>배치 시스템이 Ad-hoc하게 Unbounded Data를 처리하는 것과 달리 스트리밍 시스템은 애초에 Unbounded Data를 처리하도록 설계되었다.</p><p>그러나 스트리밍 시스템에서도 Unbounded Data를 처리하는데 아래와 같은 장애물이 있다.</p><ul><li>데이터들이 Event time 순서에 맞게 순차적으로 들어오지 않기 때문에, 데이터를 처리하는 파이프라인 내에서 시간 기준의 정렬이 필요하다.<li>Event time skew가 발생하기 때문에 Event가 발생한 시점부터 상수 시간 내에 항상 해당 Event를 볼 수 있다고 단정할 수 없다.</ul><p>이러한 특성을 가지는 데이터를 다루는 데에 필요한 접근은 Time-agnostic, Approximation, Windowing by processing time, Windowing by event time 으로 분류할 수 있다.</p><h3 id="time-agnostic">Time-agnostic</h3><p>Time-agnostic 처리는 시간과 관계 없는 데이터를 처리하는데에 사용된다. 이러한 데이터를 처리 할 때는 스트리밍 시스템이 단순히 데이터를 전달하는 역할 밖에 하지 않는다.</p><h4 id="filtering">Filtering</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/filtering_unbounded_data.jpg" alt="Filtering" /></p><p>가장 기본적인 Time-agnostic 연산 중 하나이다. 하나의 데이터 요소를 데이터의 특성으로 걸러내는 방식이기 때문에, 다른 데이터와 연관이 없다. 결과적으로 데이터가 Unbounded, Unordeded, Event time skew 되더라도 아무런 상관이 없다.</p><h4 id="inner-joins">Inner joins</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/inner_join_unbounded_data.jpg" alt="Inner join unbounded data" /></p><p>두 개의 데이터 스트림이 존재할 때, 하나의 데이터 스트림을 특정 시간 동안 모아놓고(Buffering), 다른 하나의 데이터 스트림이 들어오면 버퍼링 된 데이터와 Join을 수행하는 방식이다.</p><h3 id="windowing">Windowing</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/windowing_strategies.jpg" alt="Windowing stratigies" /> Windowing은 데이터에 대한 처리를 수행하기 위해 데이터를 유한한 크기로 분할하는 것이다. Windowing에는 Fixed windows, Sliding windows, Sessions와 같은 방법이 존재한다.</p><h4 id="fixed-windowsaka-tumbling-windows">Fixed windows(aka tumbling windows)</h4><p>Fixed windows는 고정된 길이의 Window로 데이터를 분할하는 방식이다.</p><h4 id="sliding-windowsaka-hopping-windows">Sliding windows(aka hopping windows)</h4><p>Sliding windows는 고정된 길이와 고정된 주기로 정의할 수 있다.</p><ul><li>주기가 길이보다 짧은 경우 Window가 Overlap 된다.<li>주기와 길이가 동일한 경우 Fixed windows가 된다.<li>주기가 길이보다 긴 경우 데이터를 Sampling하는 효과가 발생한다.</ul><h4 id="sessions-1">Sessions</h4><p>Session은 유동적인 Window 형태를 가진다.</p><p>Time domain 기준으로 Windowing 할 수도 있다.</p><h4 id="windowing-by-processing-time">Windowing by processing time</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/windowing_by_processing_time.jpg" alt="Windowing by processing time" /></p><p>일정한 Processing time 동안 입력 데이터를 버퍼링하여 처리하는 방식이다.</p><p>이 방식은 시스템에 입력되어 처리되는 시간(Processing time)만 고려하면 되기 때문에(다른 말로 Event time을 전혀 신경쓰지 않기 때문에), 데이터의 지연이나 시간에 의한 섞임이라는 개념이 존재할 수 없다(는 장점이 있다).</p><p>그러나 Event time에 종속적인 분석은 불가능하다.(예를 들어 사용자가 언제, 어떤 순서로 어떤 행위를 수행했는지에 대한 분석 등)</p><h4 id="windowing-by-event-time">Windowing by event time</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/streaming/windowing_by_event_time.jpg" alt="Windowing by event time" /></p><p>Event time을 반영하여 입력 데이터를 쪼개서 처리하는 방식이다.</p><p>데이터가 Input 축에서는 Event time에 관계 없이 Processing time에 아무렇게나 분포되어 있지만, Output 축으로 이동할 때(데이터가 처리된 이후)는 Event time에 맞게 재배열된 후 처리된다.</p><p>Event time 기준으로 데이터를 처리하게 되면 정확도는 Processing time 기준으로 처리하는 것보다 정확도가 높지만, 다음과 같은 단점을 가지게 된다.</p><ul><li>Buffering: Windowing by processing time 방식과는 달리 Event의 지연 전송 등을 고려하기 때문에 더 많은 데이터를 버퍼링해야 한다.<li>Completeness: 데이터의 지연 전송 등으로 언제 마지막 데이터가 들어오는지 알 수 없기 때문에, Window의 끝을 정하기가 어렵다. 대부분의 Framework에서는 Heuristic 방식을 사용하여 Window의 끝을 판단한다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/streaming/" class="post-tag no-text-decoration" >streaming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Streaming Systems - Streaming 101 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/streaming-101/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Streaming Systems - Streaming 101 - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/streaming-101/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Streaming Systems - Streaming 101 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/streaming-101/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/streaming-102/"><div class="card-body"> <span class="timeago small" > Jun 27, 2019 <i class="unloaded">2019-06-27T22:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Streaming Systems - Streaming 102(1)</h3><div class="text-muted small"><p> Streaming 102 Streaming 101에서 등장한 개념 이외에도 Trigger, Watermark, Accumulation이라는 개념이 등장한다. Trigger Window의 Output을 언제 내보낼지 결정하는 동작을 의미한다. 단순히 한번만 Window의 결과를 출력하지 않고 Window의 결과물이 달라짐에 따라 여러 번 결과를 ...</p></div></div></a></div><div class="card"> <a href="/posts/heap-and-gc/"><div class="card-body"> <span class="timeago small" > Jul 14 <i class="unloaded">2024-07-14T17:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM Heap과 GC를 다른 관점에서 바라보기</h3><div class="text-muted small"><p> 개요 Garbage Collection을 검색해보면 대부분의 글이 특정 GC(CMS, G1, Z 등)의 배경이 되는 이론(ex. Generational Collection Theory)이나, 알고리즘(ex. Mark-Sweep), 튜닝 등에 대한 내용을 다루고 있다. 그리고 해당 이론에 근거하여 Heap 메모리의 구조를 설명하다보니, Heap 영역을...</p></div></div></a></div><div class="card"> <a href="/posts/protobuf_2_5_build/"><div class="card-body"> <span class="timeago small" > Mar 10 <i class="unloaded">2024-03-10T12:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>protobuf 2.5 빌드하기(Apple Silicon)</h3><div class="text-muted small"><p> 이 문제는 Apple Silicon(M1, M2, M3 등)에서만 발생합니다. Ubuntu나 Intel Mac에서는 발생하지 않을 수 있음을 유의하시기 바랍니다. Hadoop 3.2.2 버전을 빌드하려다보니, 아래와 같은 메시지가 발생하며 빌드에 실패하였다. 1 [ERROR] Failed to execute goal org.apache.ha...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-core-1/" class="btn btn-outline-primary" prompt="Older"><p>Spring IoC Container - Container, Bean overview</p></a> <a href="/posts/streaming-102/" class="btn btn-outline-primary" prompt="Newer"><p>Streaming Systems - Streaming 102(1)</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
