<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - Annotation-based container configuration(1)" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Annotation-based container configuration 어노테이션 방식의 설정이 XML 방식의 설정보다 나은가? 어노테이션 방식과 XML 방식은 각각 장/단점이 있기 때문에, 어느 것이 낫다고 말할 수는 없다. 어노테이션 방식의 경우 명료하고 정확한 설정을 할 수 있도록 선언 내부에 많은 컨텍스트를 포함하고 있다는 장점이 있다. 반면 XML 방식의 경우 소스코드의 수정이나 재컴파일 없이도 XML만으로 프로그램의 동작을 제어할 수 있는 장점이 있다. 몇몇 개발자들은 소스 코드 내에 객체 간의 연결을 가져가는 것을 선호하는 반면, 다른 개발자들은 어노테이션이 붙은 클래스는 더이상 POJO가 아니며, 설정이 분산된다고 주장한다. 개인적으로 XML 기반 설정보다는 어토네이션 기반 설정을 선호한다. XML 설정보다 어노테이션 기반 설정이 더 Compile Time에서 오류를 찾아낼 확률이 높다고 생각하기 때문이다. 다만, 위의 주장 중 설정이 분산된다는 부분에는 동의하는 편이다. XML 설정과 다르게 어노테이션 설정은 컴포넌트들을 엮는데(Wiring up) 바이트코드 메타데이터에 의존한다. XML에 Bean 와이어링 정보를 기입하는 대신 컴포넌트 클래스의 생성자, 함수, 필드 등에 어노테이션을 기재하여 와이어링을 수행한다. 어노테이션 Injection은 XML Injection 이전에 수행된다. 따라서 XML 설정이 어노테이션 설정을 덮어쓰게 된다. 어노테이션 설정에서 사용하는 어노테이션 목록 @Required @Required는 Bean의 Setter에 사용된다. Setter의 인자에 해당 Bean이 필수적으로 의존적이라는 것을 나타내며, Setter 인자에 해당하는 Bean을 찾을 수 없을 경우 예외가 발생한다. 이는 빠르고 명시적인 예외를 발생시켜 NullPointerException과 같은 오류가 발생하지 않도록 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Required 어노테이션은 @Autowired와 같이 해당 함수를 호출하여 의존성을 주입해주는 역할을 하지 않는다. 때문에 아래와 같이 MyRepository가 컴포넌트로 등록되어 있고, ComponentScan에 의해 Bean으로 등록되어 있어도 오류가 발생하게 된다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.stereotype.Component; @Component public class MyRepository { } Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;myService&#39; defined in file [C:\Users\leeyh\Documents\projects\SpringStudy\out\production\classes\com\leeyh0216\springstudy\requiredannotation\MyService.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property &#39;myRepository&#39; is required for bean &#39;myService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) ...생략 위와 같은 오류가 발생하지 않도록 하기 위해서는 @Autowired 어노테이션을 같이 붙여주어야 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Autowired 어노테이션에 @Required와 같은 역할을 하는 required 프로퍼티가 존재한다. @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * &lt;p&gt;Defaults to {@code true}. */ boolean required() default true; } 따라서 아래와 같이 @Autowired와 required 프로퍼티만 사용하는 것이 더 좋을 듯 하다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired(required=true) public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } @Autowired @Autowired는 클래스의 필드, 생성자, 메소드에 쓰일 수 있다. 필드에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; } 위와 같이 필드에 @Autowired 어노테이션을 사용할 수 있다. 객체가 초기화 된 이후, ApplicationContext에서 해당 타입(여기서는 DependencyA)의 Bean을 찾아 주입해준다. 다만, 해당 필드는 생성자가 호출된 후 주입된다. 따라서 아래와 같은 코드를 수행할 경우, package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; public MyService(){ System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } package com.leeyh0216.springstudy.autowired; import org.springframework.stereotype.Component; @Component public class DependencyA { public String toString(){ return &quot;This is DependencyA&quot;; } } package com.leeyh0216.springstudy.autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.checkDependency(); } } 아래와 같은 결과 출력된다. DependencyA in constructor: null Dependency A after constructor: This is DependencyA 따라서 Field Injection 방식을 사용할 경우 생성자 코드 내에서는 해당 객체가 초기화되지 않은 상태이므로, 사용해서는 안된다. 생성자에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; @Autowired public MyService(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 생성자에 @Autowired를 사용할 수 있다. 해당 클래스를 Bean으로 만들 때, ApplicationContext가 생성자 인자들에 일치하는 Bean을 주입해주는 방식이다. 생성자가 1개인 경우 별도로 @Autowired를 붙여주지 않아도 된다. 다만 2개 이상의 생성자가 존재하는 경우 사용할 1개의 생성자에만 @Autowired를 붙여주어야 한다. Setter에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; public MyService(){ System.out.println(&quot;MyService&#39;s constructor called&quot;); } @Autowired public void setDependency(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA has setted&quot;); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 Setter에 @Autowired를 붙여주는 경우, ApplicationContext가 Setter의 인자에 일치하는 Bean을 이용하여 해당 함수를 호출하게 된다. 위의 코드를 실행한 결과는 아래와 같다. MyService&#39;s constructor called DependencyA has setted Dependency A after constructor: This is DependencyA Autowiring 되는 타입이 애매한(Ambigious) 경우 임의의 인터페이스 A를 상속하는 B와 C 클래스가 존재하고, D 클래스에서는 A 인터페이스를 Autowiring하는 경우 어떤 상황이 발생할까? 아래와 같이 예제 코드를 작성하였다. package com.leeyh0216.springstudy.ambigiousautowiring; public interface A { } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class B implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class C implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { @Autowired private A a; } 위와 같은 코드를 실행하면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;d&#39;: Unsatisfied dependency expressed through field &#39;a&#39;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.ambigiousautowiring.A&#39; available: expected single matching bean but found 2: b,c 만일 하나의 인터페이스 혹은 클래스를 2개 이상의 클래스가 상속하고, 이를 Autowiring 대상으로 삼는다면 위와 같은 오류가 발생할 수 있으므로, 정확한 클래스를 Autowiring 대상으로 사용하는 것이 좋다. @Order @Order 어노테이션은 동일 타입의 Bean 들을 List나 Set, Array 타입으로 Aggregation 할 때, 정렬 기준을 제공한다. 예를 들어 아래와 같이 A 인터페이스를 구현한 B,C 클래스가 존재하고, 이 클래스들을 Array 타입으로 가져오는 코드를 작성해보자. package com.leeyh0216.springstudy.order; public interface A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class C implements A { } package com.leeyh0216.springstudy.order; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { public D(A[] dependencies){ System.out.println(&quot;Dependenis size: &quot;+ dependencies.length); for(A dependency: dependencies){ System.out.println(&quot;Dependency: &quot; + dependency.getClass().getSimpleName()); } } } 위 어플리케이션이 실행되면 아래와 같이 출력이 발생한다. Dependenis size: 2 Dependency: B Dependency: C 만일 D 클래스의 생성자로 들어오는 dependencies 내의 요소들을 정렬하고 싶다면 어떻게 해야할까? @Order 어노테이션을 사용하면 정렬이 가능하다. B와 C 클래스를 아래와 같이 수정한 후 어플리케이션을 실행해보면 다른 출력내용이 발생하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(2) public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(1) public class C implements A { } Dependenis size: 2 Dependency: C Dependency: B dependencies 인자 내에서 B와 C의 순서가 변경된 것을 알 수 있다. 다만 @Order 어노테이션은 특정 타입의 Bean들을 리스트나 배열 형태의 인자로 받을 때의 순서를 정할 뿐, 객체가 초기화되는 순서를 보장하지는 않는다. 즉, 위와 같이 수정했더라도 꼭 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화된다는 것을 보장할 수는 없다는 의미이다. 만일 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화되어야 하는 경우에는 @DependsOn 어노테이션을 사용해야 한다." /><meta property="og:description" content="Annotation-based container configuration 어노테이션 방식의 설정이 XML 방식의 설정보다 나은가? 어노테이션 방식과 XML 방식은 각각 장/단점이 있기 때문에, 어느 것이 낫다고 말할 수는 없다. 어노테이션 방식의 경우 명료하고 정확한 설정을 할 수 있도록 선언 내부에 많은 컨텍스트를 포함하고 있다는 장점이 있다. 반면 XML 방식의 경우 소스코드의 수정이나 재컴파일 없이도 XML만으로 프로그램의 동작을 제어할 수 있는 장점이 있다. 몇몇 개발자들은 소스 코드 내에 객체 간의 연결을 가져가는 것을 선호하는 반면, 다른 개발자들은 어노테이션이 붙은 클래스는 더이상 POJO가 아니며, 설정이 분산된다고 주장한다. 개인적으로 XML 기반 설정보다는 어토네이션 기반 설정을 선호한다. XML 설정보다 어노테이션 기반 설정이 더 Compile Time에서 오류를 찾아낼 확률이 높다고 생각하기 때문이다. 다만, 위의 주장 중 설정이 분산된다는 부분에는 동의하는 편이다. XML 설정과 다르게 어노테이션 설정은 컴포넌트들을 엮는데(Wiring up) 바이트코드 메타데이터에 의존한다. XML에 Bean 와이어링 정보를 기입하는 대신 컴포넌트 클래스의 생성자, 함수, 필드 등에 어노테이션을 기재하여 와이어링을 수행한다. 어노테이션 Injection은 XML Injection 이전에 수행된다. 따라서 XML 설정이 어노테이션 설정을 덮어쓰게 된다. 어노테이션 설정에서 사용하는 어노테이션 목록 @Required @Required는 Bean의 Setter에 사용된다. Setter의 인자에 해당 Bean이 필수적으로 의존적이라는 것을 나타내며, Setter 인자에 해당하는 Bean을 찾을 수 없을 경우 예외가 발생한다. 이는 빠르고 명시적인 예외를 발생시켜 NullPointerException과 같은 오류가 발생하지 않도록 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Required 어노테이션은 @Autowired와 같이 해당 함수를 호출하여 의존성을 주입해주는 역할을 하지 않는다. 때문에 아래와 같이 MyRepository가 컴포넌트로 등록되어 있고, ComponentScan에 의해 Bean으로 등록되어 있어도 오류가 발생하게 된다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.stereotype.Component; @Component public class MyRepository { } Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;myService&#39; defined in file [C:\Users\leeyh\Documents\projects\SpringStudy\out\production\classes\com\leeyh0216\springstudy\requiredannotation\MyService.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property &#39;myRepository&#39; is required for bean &#39;myService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) ...생략 위와 같은 오류가 발생하지 않도록 하기 위해서는 @Autowired 어노테이션을 같이 붙여주어야 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Autowired 어노테이션에 @Required와 같은 역할을 하는 required 프로퍼티가 존재한다. @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * &lt;p&gt;Defaults to {@code true}. */ boolean required() default true; } 따라서 아래와 같이 @Autowired와 required 프로퍼티만 사용하는 것이 더 좋을 듯 하다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired(required=true) public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } @Autowired @Autowired는 클래스의 필드, 생성자, 메소드에 쓰일 수 있다. 필드에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; } 위와 같이 필드에 @Autowired 어노테이션을 사용할 수 있다. 객체가 초기화 된 이후, ApplicationContext에서 해당 타입(여기서는 DependencyA)의 Bean을 찾아 주입해준다. 다만, 해당 필드는 생성자가 호출된 후 주입된다. 따라서 아래와 같은 코드를 수행할 경우, package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; public MyService(){ System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } package com.leeyh0216.springstudy.autowired; import org.springframework.stereotype.Component; @Component public class DependencyA { public String toString(){ return &quot;This is DependencyA&quot;; } } package com.leeyh0216.springstudy.autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.checkDependency(); } } 아래와 같은 결과 출력된다. DependencyA in constructor: null Dependency A after constructor: This is DependencyA 따라서 Field Injection 방식을 사용할 경우 생성자 코드 내에서는 해당 객체가 초기화되지 않은 상태이므로, 사용해서는 안된다. 생성자에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; @Autowired public MyService(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 생성자에 @Autowired를 사용할 수 있다. 해당 클래스를 Bean으로 만들 때, ApplicationContext가 생성자 인자들에 일치하는 Bean을 주입해주는 방식이다. 생성자가 1개인 경우 별도로 @Autowired를 붙여주지 않아도 된다. 다만 2개 이상의 생성자가 존재하는 경우 사용할 1개의 생성자에만 @Autowired를 붙여주어야 한다. Setter에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; public MyService(){ System.out.println(&quot;MyService&#39;s constructor called&quot;); } @Autowired public void setDependency(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA has setted&quot;); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 Setter에 @Autowired를 붙여주는 경우, ApplicationContext가 Setter의 인자에 일치하는 Bean을 이용하여 해당 함수를 호출하게 된다. 위의 코드를 실행한 결과는 아래와 같다. MyService&#39;s constructor called DependencyA has setted Dependency A after constructor: This is DependencyA Autowiring 되는 타입이 애매한(Ambigious) 경우 임의의 인터페이스 A를 상속하는 B와 C 클래스가 존재하고, D 클래스에서는 A 인터페이스를 Autowiring하는 경우 어떤 상황이 발생할까? 아래와 같이 예제 코드를 작성하였다. package com.leeyh0216.springstudy.ambigiousautowiring; public interface A { } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class B implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class C implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { @Autowired private A a; } 위와 같은 코드를 실행하면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;d&#39;: Unsatisfied dependency expressed through field &#39;a&#39;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.ambigiousautowiring.A&#39; available: expected single matching bean but found 2: b,c 만일 하나의 인터페이스 혹은 클래스를 2개 이상의 클래스가 상속하고, 이를 Autowiring 대상으로 삼는다면 위와 같은 오류가 발생할 수 있으므로, 정확한 클래스를 Autowiring 대상으로 사용하는 것이 좋다. @Order @Order 어노테이션은 동일 타입의 Bean 들을 List나 Set, Array 타입으로 Aggregation 할 때, 정렬 기준을 제공한다. 예를 들어 아래와 같이 A 인터페이스를 구현한 B,C 클래스가 존재하고, 이 클래스들을 Array 타입으로 가져오는 코드를 작성해보자. package com.leeyh0216.springstudy.order; public interface A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class C implements A { } package com.leeyh0216.springstudy.order; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { public D(A[] dependencies){ System.out.println(&quot;Dependenis size: &quot;+ dependencies.length); for(A dependency: dependencies){ System.out.println(&quot;Dependency: &quot; + dependency.getClass().getSimpleName()); } } } 위 어플리케이션이 실행되면 아래와 같이 출력이 발생한다. Dependenis size: 2 Dependency: B Dependency: C 만일 D 클래스의 생성자로 들어오는 dependencies 내의 요소들을 정렬하고 싶다면 어떻게 해야할까? @Order 어노테이션을 사용하면 정렬이 가능하다. B와 C 클래스를 아래와 같이 수정한 후 어플리케이션을 실행해보면 다른 출력내용이 발생하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(2) public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(1) public class C implements A { } Dependenis size: 2 Dependency: C Dependency: B dependencies 인자 내에서 B와 C의 순서가 변경된 것을 알 수 있다. 다만 @Order 어노테이션은 특정 타입의 Bean들을 리스트나 배열 형태의 인자로 받을 때의 순서를 정할 뿐, 객체가 초기화되는 순서를 보장하지는 않는다. 즉, 위와 같이 수정했더라도 꼭 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화된다는 것을 보장할 수는 없다는 의미이다. 만일 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화되어야 하는 경우에는 @DependsOn 어노테이션을 사용해야 한다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/annotation-based-container-configuration/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/annotation-based-container-configuration/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-01-28T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - Annotation-based container configuration(1)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"Annotation-based container configuration 어노테이션 방식의 설정이 XML 방식의 설정보다 나은가? 어노테이션 방식과 XML 방식은 각각 장/단점이 있기 때문에, 어느 것이 낫다고 말할 수는 없다. 어노테이션 방식의 경우 명료하고 정확한 설정을 할 수 있도록 선언 내부에 많은 컨텍스트를 포함하고 있다는 장점이 있다. 반면 XML 방식의 경우 소스코드의 수정이나 재컴파일 없이도 XML만으로 프로그램의 동작을 제어할 수 있는 장점이 있다. 몇몇 개발자들은 소스 코드 내에 객체 간의 연결을 가져가는 것을 선호하는 반면, 다른 개발자들은 어노테이션이 붙은 클래스는 더이상 POJO가 아니며, 설정이 분산된다고 주장한다. 개인적으로 XML 기반 설정보다는 어토네이션 기반 설정을 선호한다. XML 설정보다 어노테이션 기반 설정이 더 Compile Time에서 오류를 찾아낼 확률이 높다고 생각하기 때문이다. 다만, 위의 주장 중 설정이 분산된다는 부분에는 동의하는 편이다. XML 설정과 다르게 어노테이션 설정은 컴포넌트들을 엮는데(Wiring up) 바이트코드 메타데이터에 의존한다. XML에 Bean 와이어링 정보를 기입하는 대신 컴포넌트 클래스의 생성자, 함수, 필드 등에 어노테이션을 기재하여 와이어링을 수행한다. 어노테이션 Injection은 XML Injection 이전에 수행된다. 따라서 XML 설정이 어노테이션 설정을 덮어쓰게 된다. 어노테이션 설정에서 사용하는 어노테이션 목록 @Required @Required는 Bean의 Setter에 사용된다. Setter의 인자에 해당 Bean이 필수적으로 의존적이라는 것을 나타내며, Setter 인자에 해당하는 Bean을 찾을 수 없을 경우 예외가 발생한다. 이는 빠르고 명시적인 예외를 발생시켜 NullPointerException과 같은 오류가 발생하지 않도록 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Required 어노테이션은 @Autowired와 같이 해당 함수를 호출하여 의존성을 주입해주는 역할을 하지 않는다. 때문에 아래와 같이 MyRepository가 컴포넌트로 등록되어 있고, ComponentScan에 의해 Bean으로 등록되어 있어도 오류가 발생하게 된다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.stereotype.Component; @Component public class MyRepository { } Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;myService&#39; defined in file [C:\\Users\\leeyh\\Documents\\projects\\SpringStudy\\out\\production\\classes\\com\\leeyh0216\\springstudy\\requiredannotation\\MyService.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property &#39;myRepository&#39; is required for bean &#39;myService&#39; at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:564) ...생략 위와 같은 오류가 발생하지 않도록 하기 위해서는 @Autowired 어노테이션을 같이 붙여주어야 한다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired @Required public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } 다만 @Autowired 어노테이션에 @Required와 같은 역할을 하는 required 프로퍼티가 존재한다. @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Autowired { /** * Declares whether the annotated dependency is required. * &lt;p&gt;Defaults to {@code true}. */ boolean required() default true; } 따라서 아래와 같이 @Autowired와 required 프로퍼티만 사용하는 것이 더 좋을 듯 하다. package com.leeyh0216.springstudy.requiredannotation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Required; import org.springframework.stereotype.Component; @Component public class MyService{ MyRepository myRepository; @Autowired(required=true) public void setMyRepository(MyRepository myRepository){ this.myRepository = myRepository; } } @Autowired @Autowired는 클래스의 필드, 생성자, 메소드에 쓰일 수 있다. 필드에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; } 위와 같이 필드에 @Autowired 어노테이션을 사용할 수 있다. 객체가 초기화 된 이후, ApplicationContext에서 해당 타입(여기서는 DependencyA)의 Bean을 찾아 주입해준다. 다만, 해당 필드는 생성자가 호출된 후 주입된다. 따라서 아래와 같은 코드를 수행할 경우, package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { @Autowired DependencyA dependency; public MyService(){ System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } package com.leeyh0216.springstudy.autowired; import org.springframework.stereotype.Component; @Component public class DependencyA { public String toString(){ return &quot;This is DependencyA&quot;; } } package com.leeyh0216.springstudy.autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.checkDependency(); } } 아래와 같은 결과 출력된다. DependencyA in constructor: null Dependency A after constructor: This is DependencyA 따라서 Field Injection 방식을 사용할 경우 생성자 코드 내에서는 해당 객체가 초기화되지 않은 상태이므로, 사용해서는 안된다. 생성자에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; @Autowired public MyService(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA in constructor: &quot; + dependency); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 생성자에 @Autowired를 사용할 수 있다. 해당 클래스를 Bean으로 만들 때, ApplicationContext가 생성자 인자들에 일치하는 Bean을 주입해주는 방식이다. 생성자가 1개인 경우 별도로 @Autowired를 붙여주지 않아도 된다. 다만 2개 이상의 생성자가 존재하는 경우 사용할 1개의 생성자에만 @Autowired를 붙여주어야 한다. Setter에 @Autowired를 사용하는 경우 package com.leeyh0216.springstudy.autowired; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { DependencyA dependency; public MyService(){ System.out.println(&quot;MyService&#39;s constructor called&quot;); } @Autowired public void setDependency(DependencyA dependency){ this.dependency = dependency; System.out.println(&quot;DependencyA has setted&quot;); } public void checkDependency(){ System.out.println(&quot;Dependency A after constructor: &quot; + dependency); } } 위와 같이 Setter에 @Autowired를 붙여주는 경우, ApplicationContext가 Setter의 인자에 일치하는 Bean을 이용하여 해당 함수를 호출하게 된다. 위의 코드를 실행한 결과는 아래와 같다. MyService&#39;s constructor called DependencyA has setted Dependency A after constructor: This is DependencyA Autowiring 되는 타입이 애매한(Ambigious) 경우 임의의 인터페이스 A를 상속하는 B와 C 클래스가 존재하고, D 클래스에서는 A 인터페이스를 Autowiring하는 경우 어떤 상황이 발생할까? 아래와 같이 예제 코드를 작성하였다. package com.leeyh0216.springstudy.ambigiousautowiring; public interface A { } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class B implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.stereotype.Component; @Component public class C implements A{ } package com.leeyh0216.springstudy.ambigiousautowiring; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { @Autowired private A a; } 위와 같은 코드를 실행하면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;d&#39;: Unsatisfied dependency expressed through field &#39;a&#39;; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.ambigiousautowiring.A&#39; available: expected single matching bean but found 2: b,c 만일 하나의 인터페이스 혹은 클래스를 2개 이상의 클래스가 상속하고, 이를 Autowiring 대상으로 삼는다면 위와 같은 오류가 발생할 수 있으므로, 정확한 클래스를 Autowiring 대상으로 사용하는 것이 좋다. @Order @Order 어노테이션은 동일 타입의 Bean 들을 List나 Set, Array 타입으로 Aggregation 할 때, 정렬 기준을 제공한다. 예를 들어 아래와 같이 A 인터페이스를 구현한 B,C 클래스가 존재하고, 이 클래스들을 Array 타입으로 가져오는 코드를 작성해보자. package com.leeyh0216.springstudy.order; public interface A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.stereotype.Component; @Component public class C implements A { } package com.leeyh0216.springstudy.order; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class D { public D(A[] dependencies){ System.out.println(&quot;Dependenis size: &quot;+ dependencies.length); for(A dependency: dependencies){ System.out.println(&quot;Dependency: &quot; + dependency.getClass().getSimpleName()); } } } 위 어플리케이션이 실행되면 아래와 같이 출력이 발생한다. Dependenis size: 2 Dependency: B Dependency: C 만일 D 클래스의 생성자로 들어오는 dependencies 내의 요소들을 정렬하고 싶다면 어떻게 해야할까? @Order 어노테이션을 사용하면 정렬이 가능하다. B와 C 클래스를 아래와 같이 수정한 후 어플리케이션을 실행해보면 다른 출력내용이 발생하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(2) public class B implements A { } package com.leeyh0216.springstudy.order; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Component @Order(1) public class C implements A { } Dependenis size: 2 Dependency: C Dependency: B dependencies 인자 내에서 B와 C의 순서가 변경된 것을 알 수 있다. 다만 @Order 어노테이션은 특정 타입의 Bean들을 리스트나 배열 형태의 인자로 받을 때의 순서를 정할 뿐, 객체가 초기화되는 순서를 보장하지는 않는다. 즉, 위와 같이 수정했더라도 꼭 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화된다는 것을 보장할 수는 없다는 의미이다. 만일 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화되어야 하는 경우에는 @DependsOn 어노테이션을 사용해야 한다.","url":"https://leeyh0216.github.io/posts/annotation-based-container-configuration/","@type":"BlogPosting","headline":"Spring Core Technologies - Annotation-based container configuration(1)","dateModified":"2019-01-28T10:00:00+09:00","datePublished":"2019-01-28T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/annotation-based-container-configuration/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - Annotation-based container configuration(1) | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - Annotation-based container configuration(1)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - Annotation-based container configuration(1)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 28, 2019, 10:00 AM +0900" prep="on" > Jan 28, 2019 <i class="unloaded">2019-01-28T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2280 words">12 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="annotation-based-container-configuration">Annotation-based container configuration</h1><h2 id="어노테이션-방식의-설정이-xml-방식의-설정보다-나은가">어노테이션 방식의 설정이 XML 방식의 설정보다 나은가?</h2><p>어노테이션 방식과 XML 방식은 각각 장/단점이 있기 때문에, 어느 것이 낫다고 말할 수는 없다.</p><p>어노테이션 방식의 경우 명료하고 정확한 설정을 할 수 있도록 선언 내부에 많은 컨텍스트를 포함하고 있다는 장점이 있다.</p><p>반면 XML 방식의 경우 소스코드의 수정이나 재컴파일 없이도 XML만으로 프로그램의 동작을 제어할 수 있는 장점이 있다.</p><p>몇몇 개발자들은 소스 코드 내에 객체 간의 연결을 가져가는 것을 선호하는 반면, 다른 개발자들은 어노테이션이 붙은 클래스는 더이상 POJO가 아니며, 설정이 분산된다고 주장한다.</p><blockquote><p>개인적으로 XML 기반 설정보다는 어토네이션 기반 설정을 선호한다. XML 설정보다 어노테이션 기반 설정이 더 Compile Time에서 오류를 찾아낼 확률이 높다고 생각하기 때문이다. 다만, 위의 주장 중 설정이 분산된다는 부분에는 동의하는 편이다.</p></blockquote><p>XML 설정과 다르게 어노테이션 설정은 컴포넌트들을 엮는데(Wiring up) 바이트코드 메타데이터에 의존한다. XML에 Bean 와이어링 정보를 기입하는 대신 컴포넌트 클래스의 생성자, 함수, 필드 등에 어노테이션을 기재하여 와이어링을 수행한다.</p><blockquote><p>어노테이션 Injection은 XML Injection 이전에 수행된다. 따라서 XML 설정이 어노테이션 설정을 덮어쓰게 된다.</p></blockquote><h2 id="어노테이션-설정에서-사용하는-어노테이션-목록">어노테이션 설정에서 사용하는 어노테이션 목록</h2><h3 id="required">@Required</h3><p><code class="language-plaintext highlighter-rouge">@Required</code>는 Bean의 Setter에 사용된다. Setter의 인자에 해당 Bean이 필수적으로 의존적이라는 것을 나타내며, Setter 인자에 해당하는 Bean을 찾을 수 없을 경우 예외가 발생한다. 이는 빠르고 명시적인 예외를 발생시켜 <code class="language-plaintext highlighter-rouge">NullPointerException</code>과 같은 오류가 발생하지 않도록 한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.requiredannotation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Required</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="nd">@Required</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>다만 <code class="language-plaintext highlighter-rouge">@Required</code> 어노테이션은 <code class="language-plaintext highlighter-rouge">@Autowired</code>와 같이 해당 함수를 호출하여 의존성을 주입해주는 역할을 하지 않는다. 때문에 아래와 같이 <code class="language-plaintext highlighter-rouge">MyRepository</code>가 컴포넌트로 등록되어 있고, ComponentScan에 의해 Bean으로 등록되어 있어도 오류가 발생하게 된다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.requiredannotation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRepository</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Exception <span class="k">in </span>thread <span class="s2">"main"</span> org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="s1">'myService'</span> defined <span class="k">in </span>file <span class="o">[</span>C:<span class="se">\U</span>sers<span class="se">\l</span>eeyh<span class="se">\D</span>ocuments<span class="se">\p</span>rojects<span class="se">\S</span>pringStudy<span class="se">\o</span>ut<span class="se">\p</span>roduction<span class="se">\c</span>lasses<span class="se">\c</span>om<span class="se">\l</span>eeyh0216<span class="se">\s</span>pringstudy<span class="se">\r</span>equiredannotation<span class="se">\M</span>yService.class]: Initialization of bean failed<span class="p">;</span> nested exception is org.springframework.beans.factory.BeanInitializationException: Property <span class="s1">'myRepository'</span> is required <span class="k">for </span>bean <span class="s1">'myService'</span>
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean<span class="o">(</span>AbstractAutowireCapableBeanFactory.java:564<span class="o">)</span>
...생략</code></pre></figure><p>위와 같은 오류가 발생하지 않도록 하기 위해서는 <code class="language-plaintext highlighter-rouge">@Autowired</code> 어노테이션을 같이 붙여주어야 한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.requiredannotation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Required</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="nd">@Required</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>다만 <code class="language-plaintext highlighter-rouge">@Autowired</code> 어노테이션에 <code class="language-plaintext highlighter-rouge">@Required</code>와 같은 역할을 하는 <code class="language-plaintext highlighter-rouge">required</code> 프로퍼티가 존재한다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">CONSTRUCTOR</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">PARAMETER</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">,</span> <span class="nc">ElementType</span><span class="o">.</span><span class="na">ANNOTATION_TYPE</span><span class="o">})</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Autowired</span> <span class="o">{</span>

	<span class="cm">/**
	 * Declares whether the annotated dependency is required.
	 * &lt;p&gt;Defaults to {@code true}.
	 */</span>
	<span class="kt">boolean</span> <span class="nf">required</span><span class="o">()</span> <span class="k">default</span> <span class="kc">true</span><span class="o">;</span>

<span class="o">}</span></code></pre></figure><p>따라서 아래와 같이 <code class="language-plaintext highlighter-rouge">@Autowired</code>와 <code class="language-plaintext highlighter-rouge">required</code> 프로퍼티만 사용하는 것이 더 좋을 듯 하다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.requiredannotation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Required</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h3 id="autowired">@Autowired</h3><p><code class="language-plaintext highlighter-rouge">@Autowired</code>는 클래스의 필드, 생성자, 메소드에 쓰일 수 있다.</p><h4 id="필드에-autowired를-사용하는-경우">필드에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 사용하는 경우</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 필드에 <code class="language-plaintext highlighter-rouge">@Autowired</code> 어노테이션을 사용할 수 있다. 객체가 초기화 된 이후, ApplicationContext에서 해당 타입(여기서는 DependencyA)의 Bean을 찾아 주입해준다.</p><p>다만, 해당 필드는 생성자가 호출된 후 주입된다.</p><p>따라서 아래와 같은 코드를 수행할 경우,</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyA in constructor: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkDependency</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dependency A after constructor: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DependencyA</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"This is DependencyA"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">checkDependency</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>아래와 같은 결과 출력된다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">DependencyA <span class="k">in </span>constructor: null
Dependency A after constructor: This is DependencyA</code></pre></figure><p>따라서 Field Injection 방식을 사용할 경우 생성자 코드 내에서는 해당 객체가 초기화되지 않은 상태이므로, 사용해서는 안된다.</p><h4 id="생성자에-autowired를-사용하는-경우">생성자에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 사용하는 경우</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
    
    <span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dependency</span> <span class="o">=</span> <span class="n">dependency</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyA in constructor: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkDependency</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dependency A after constructor: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 생성자에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 사용할 수 있다. 해당 클래스를 Bean으로 만들 때, ApplicationContext가 생성자 인자들에 일치하는 Bean을 주입해주는 방식이다.</p><blockquote><p>생성자가 1개인 경우 별도로 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 붙여주지 않아도 된다. 다만 2개 이상의 생성자가 존재하는 경우 사용할 1개의 생성자에만 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 붙여주어야 한다.</p></blockquote><h4 id="setter에-autowired를-사용하는-경우">Setter에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 사용하는 경우</h4><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService's constructor called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDependency</span><span class="o">(</span><span class="nc">DependencyA</span> <span class="n">dependency</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dependency</span> <span class="o">=</span> <span class="n">dependency</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyA has setted"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkDependency</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dependency A after constructor: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위와 같이 Setter에 <code class="language-plaintext highlighter-rouge">@Autowired</code>를 붙여주는 경우, ApplicationContext가 Setter의 인자에 일치하는 Bean을 이용하여 해당 함수를 호출하게 된다.</p><p>위의 코드를 실행한 결과는 아래와 같다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">MyService<span class="s1">'s constructor called
DependencyA has setted
Dependency A after constructor: This is DependencyA</span></code></pre></figure><h4 id="autowiring-되는-타입이-애매한ambigious-경우">Autowiring 되는 타입이 애매한(Ambigious) 경우</h4><p>임의의 인터페이스 A를 상속하는 B와 C 클래스가 존재하고, D 클래스에서는 A 인터페이스를 Autowiring하는 경우 어떤 상황이 발생할까?</p><p>아래와 같이 예제 코드를 작성하였다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.ambigiousautowiring</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.ambigiousautowiring</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.ambigiousautowiring</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.ambigiousautowiring</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    
<span class="o">}</span></code></pre></figure><p>위와 같은 코드를 실행하면 아래와 같은 오류가 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Exception <span class="k">in </span>thread <span class="s2">"main"</span> org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="s1">'d'</span>: Unsatisfied dependency expressed through field <span class="s1">'a'</span><span class="p">;</span> nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of <span class="nb">type</span> <span class="s1">'com.leeyh0216.springstudy.ambigiousautowiring.A'</span> available: expected single matching bean but found 2: b,c</code></pre></figure><p>만일 하나의 인터페이스 혹은 클래스를 2개 이상의 클래스가 상속하고, 이를 Autowiring 대상으로 삼는다면 위와 같은 오류가 발생할 수 있으므로, 정확한 클래스를 Autowiring 대상으로 사용하는 것이 좋다.</p><h3 id="order">@Order</h3><p><code class="language-plaintext highlighter-rouge">@Order</code> 어노테이션은 동일 타입의 Bean 들을 List나 Set, Array 타입으로 Aggregation 할 때, 정렬 기준을 제공한다. 예를 들어 아래와 같이 A 인터페이스를 구현한 B,C 클래스가 존재하고, 이 클래스들을 Array<a> 타입으로 가져오는 코드를 작성해보자.</a></p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">D</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">D</span><span class="o">(</span><span class="no">A</span><span class="o">[]</span> <span class="n">dependencies</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dependenis size: "</span><span class="o">+</span> <span class="n">dependencies</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="no">A</span> <span class="nl">dependency:</span> <span class="n">dependencies</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dependency: "</span> <span class="o">+</span> <span class="n">dependency</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p>위 어플리케이션이 실행되면 아래와 같이 출력이 발생한다.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Dependenis size: 2
Dependency: B
Dependency: C</code></pre></figure><p>만일 D 클래스의 생성자로 들어오는 <code class="language-plaintext highlighter-rouge">dependencies</code> 내의 요소들을 정렬하고 싶다면 어떻게 해야할까?</p><p><code class="language-plaintext highlighter-rouge">@Order</code> 어노테이션을 사용하면 정렬이 가능하다.</p><p>B와 C 클래스를 아래와 같이 수정한 후 어플리케이션을 실행해보면 다른 출력내용이 발생하는 것을 확인할 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.core.annotation.Order</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.order</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.core.annotation.Order</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-bash" data-lang="bash">Dependenis size: 2
Dependency: C
Dependency: B</code></pre></figure><p><code class="language-plaintext highlighter-rouge">dependencies</code> 인자 내에서 B와 C의 순서가 변경된 것을 알 수 있다.</p><p>다만 <code class="language-plaintext highlighter-rouge">@Order</code> 어노테이션은 특정 타입의 Bean들을 리스트나 배열 형태의 인자로 받을 때의 순서를 정할 뿐, 객체가 초기화되는 순서를 보장하지는 않는다.</p><p>즉, 위와 같이 수정했더라도 꼭 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화된다는 것을 보장할 수는 없다는 의미이다.</p><p>만일 C 클래스의 객체가 B 클래스의 객체보다 먼저 초기화되어야 하는 경우에는 <code class="language-plaintext highlighter-rouge">@DependsOn</code> 어노테이션을 사용해야 한다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - Annotation-based container configuration(1) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/annotation-based-container-configuration/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - Annotation-based container configuration(1) - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/annotation-based-container-configuration/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - Annotation-based container configuration(1) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/annotation-based-container-configuration/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-core-4/"><div class="card-body"> <span class="timeago small" > Dec 23, 2018 <i class="unloaded">2018-12-23T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Core Technologies - The IoC Container(4)</h3><div class="text-muted small"><p> The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/spring-customizing-the-nature-of-a-bean/" class="btn btn-outline-primary" prompt="Older"><p>Spring Core Technologies - Customizing the nature of a bean</p></a> <a href="/posts/spring-with-docker-1/" class="btn btn-outline-primary" prompt="Newer"><p>Spring + MongoDB + Docker 조합 사용 테스트</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
