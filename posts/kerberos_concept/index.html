<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Kerberos 개념" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="이 내용은 Wikipedia - Kerberos를 참고하여 작성하였습니다. Kerberos Kerberos는 보안되지 않은(un-secured) 네트워크에서 안전한 방법(secured manner)으로 노드 간 자격 증명을 수행하는 네트워크 인증 프로토콜이다. 사용자 비밀번호가 Network를 통해 교환되지 않기 때문에 MIMT(Main in the middle attack)을 통해 비밀번호 탈취가 불가능한 구조를 가지고 있는데, 어떻게 이런 특징을 가질 수 있는지 알아보도록 한다. 참여 주체 Kerberos 인증에는 Client, KDC(Key Distribution Center), Server가 참여한다. 일반적인 인증에서는 Client가 접근하고자 하는 서버와 인증을 수행하는 서버가 동일했지만, Kerberos에서는 접근하고자 하는 서버와 인증을 수행하는 서버(KDC)가 분리되어 있다. KDC는 Authentication Server와 Ticket-Granting Server로 이루어져 있다. Authentication Server: 사용자의 ID와 Password를 기반으로 실질적인 인증을 수행한다. Ticket-Granting Server: Client &lt;-&gt; Server 간 자격 증명에 사용되는 Ticket을 발급한다. 인증 프로세스 아래에서 나오는 Kx는 x라는 이름의 키(Key)를 의미한다. 예를 들어 Ktgs는 tgs라는 이름의 Key를 뜻한다. Client &lt;-&gt; Authentication Server 출처: Wikipedia - Kerberos 사용자는 Client Program에 ID, Password를 입력받는다. Client는 사용자의 ID를 KDC의 Authentication Server(AS)에 전달한다. Authentication Server는 사용자의 ID가 존재하는지 확인한다. Authentication Server는 모든 사용자의 정보(ID, Password)를 가지고 있다.(혹은 LDAP와 같은 외부 시스템에 저장된 정보에 접근할 수 있다) 사용자 ID가 존재한다면 자신이 가진 사용자의 비밀번호를 통해 키(Kc)를 만들어낸다. Client에게 전달할 Kc_tgs(Client와 Ticket Grant Server 간 통신 시 암/복호화에 사용할 키)를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg A)는 5 에서 만들어낸 Kc_tgs를 Kc를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg B)는 Kc_tgs와 클라이언트 정보(ID, Address, Validity)를 Ktgs(이 키는 Authentication Server와 Ticket-Granting Server 간에만 공유한다)를 통해 암호화해서 만들어낸다. 클라이언트 입장에서 사용자의 비밀번호는 Authentication Server로부터 전달받은 메시지(Msg A)를 복호화하는데만 사용된다. 만일 비밀번호가 틀린 경우 다음 인증 단계(Ticket-Granting Server)에서 사용할 Kc_tgs를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Authentication Server 입장에서 사용자의 비밀번호는 클라이언트에게 다음 인증 단계에서 사용할 Ticket과 메시지를 암호화하는데만 사용된다. 만일 클라이언트가 잘못된 비밀번호를 가지고 있다면 이 정보를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Msg A는 클라이언트가 사용자의 비밀번호로 복호화 할 수 있는 반면, Msg B는 복호화가 불가능하다. Msg B는 KDC 내부적으로 클라이언트의 무결성을 증명하기 위한 값으로 활용된다. Client &lt;-&gt; Ticket-Granting Server 출처: Wikipedia - Kerberos 클라이언트는 자신의 비밀번호를 통해 Authentication Server로부터 전달받은 Msg A를 복호화해서 Kc_tgs(Ticket-Granting Server에 메시지를 보낼 때 암호화 할 키)를 얻어낸다. 클라이언트는 서버로부터 받았던 Msg B(이번 그림에서는 Msg C로 표현)와 Client ID와 Timestamp를 결합한 Msg D를 Ticket-Granting Server로 전달한다. Ticket Granting Server는 클라이언트로부터 전달받은 Msg C를 Ktgs를 통해 복호화한다. 복호화한 메시지에서 Tc_tgs를 획득한다. Ticket Granting Server는 3 에서 얻어낸 Tc_tgs를 통해 Msg D를 복호화한다. Msg D에서 얻어낸 Client ID와 Msg C의 Client ID를 비교해서 정상적으로 인증된 클라이언트인지 확인한다. 정상적으로 인증되었다면 6단계를 진행한다. 클라이언트와 클라이언트가 접근하고 싶은 서버 간의 통신에 사용되는 Kc_s를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg E)는 6에서 만들어낸 Kc_s와 클라이언트 정보(ID, Address, Validity)를 Ks(이 키는 Ticket-Granting Server와 실제 접속할 서버 사이에만 공유한다)를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg F)는 6에서 만들어낸 Kc_s를 Kc_tgs를 통해 암호화해서 만들어낸다. Msg B(=Msg C)를 탈취하여 임의의 Kc_tgs`를 통해 클라이언트 정보(ID, Timestamp)를 암호화해서 보냈다해도, Ticket Granting Server 에서 Msg B를 Ktgs를 통해 복호화 하여 얻어낸 Kc_tgs는 Kc_tgs`와 일치하지 않기 때문에 인증 과정이 종료된다. Msg E는 추후 클라이언트 &lt;-&gt; 서버 통신 시 Msg B(=Msg C)와 동일한 역할을 수행한다. Client &lt;-&gt; Server 출처: Wikipedia - Kerberos 클라이언트는 Ticket-Granting Server로부터 전달받은 Msg F를 Kc_tgs를 통해 복호화하여 Kc_s(Client가 Server에 메시지를 보낼 때 암호화 할 키)를 획득한다. 클라이언트는 서버로부터 받았던 Msg E와 Client ID와 Timestamp를 결합한 Msg G를 Server로 전달한다. Server는 클라이언트로부터 전달받은 Msg E를 Ks를 통해 복호화한다. 복호화한 메시지에서 Tc_s를 획득한다. Server는 3에서 획득한 T_cs를 통해 Msg G를 복호화한다. Msg G에서 얻어낸 Client ID와 Msg E의 Msg E에서 얻어낸 Client ID를 비교한다. 다음 글에서는 Docker 환경에서 KDC를 구성하고 SSH 서버 접근 시 Kerberos 인증을 통해 로그인하는 과정을 진행합니다." /><meta property="og:description" content="이 내용은 Wikipedia - Kerberos를 참고하여 작성하였습니다. Kerberos Kerberos는 보안되지 않은(un-secured) 네트워크에서 안전한 방법(secured manner)으로 노드 간 자격 증명을 수행하는 네트워크 인증 프로토콜이다. 사용자 비밀번호가 Network를 통해 교환되지 않기 때문에 MIMT(Main in the middle attack)을 통해 비밀번호 탈취가 불가능한 구조를 가지고 있는데, 어떻게 이런 특징을 가질 수 있는지 알아보도록 한다. 참여 주체 Kerberos 인증에는 Client, KDC(Key Distribution Center), Server가 참여한다. 일반적인 인증에서는 Client가 접근하고자 하는 서버와 인증을 수행하는 서버가 동일했지만, Kerberos에서는 접근하고자 하는 서버와 인증을 수행하는 서버(KDC)가 분리되어 있다. KDC는 Authentication Server와 Ticket-Granting Server로 이루어져 있다. Authentication Server: 사용자의 ID와 Password를 기반으로 실질적인 인증을 수행한다. Ticket-Granting Server: Client &lt;-&gt; Server 간 자격 증명에 사용되는 Ticket을 발급한다. 인증 프로세스 아래에서 나오는 Kx는 x라는 이름의 키(Key)를 의미한다. 예를 들어 Ktgs는 tgs라는 이름의 Key를 뜻한다. Client &lt;-&gt; Authentication Server 출처: Wikipedia - Kerberos 사용자는 Client Program에 ID, Password를 입력받는다. Client는 사용자의 ID를 KDC의 Authentication Server(AS)에 전달한다. Authentication Server는 사용자의 ID가 존재하는지 확인한다. Authentication Server는 모든 사용자의 정보(ID, Password)를 가지고 있다.(혹은 LDAP와 같은 외부 시스템에 저장된 정보에 접근할 수 있다) 사용자 ID가 존재한다면 자신이 가진 사용자의 비밀번호를 통해 키(Kc)를 만들어낸다. Client에게 전달할 Kc_tgs(Client와 Ticket Grant Server 간 통신 시 암/복호화에 사용할 키)를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg A)는 5 에서 만들어낸 Kc_tgs를 Kc를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg B)는 Kc_tgs와 클라이언트 정보(ID, Address, Validity)를 Ktgs(이 키는 Authentication Server와 Ticket-Granting Server 간에만 공유한다)를 통해 암호화해서 만들어낸다. 클라이언트 입장에서 사용자의 비밀번호는 Authentication Server로부터 전달받은 메시지(Msg A)를 복호화하는데만 사용된다. 만일 비밀번호가 틀린 경우 다음 인증 단계(Ticket-Granting Server)에서 사용할 Kc_tgs를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Authentication Server 입장에서 사용자의 비밀번호는 클라이언트에게 다음 인증 단계에서 사용할 Ticket과 메시지를 암호화하는데만 사용된다. 만일 클라이언트가 잘못된 비밀번호를 가지고 있다면 이 정보를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Msg A는 클라이언트가 사용자의 비밀번호로 복호화 할 수 있는 반면, Msg B는 복호화가 불가능하다. Msg B는 KDC 내부적으로 클라이언트의 무결성을 증명하기 위한 값으로 활용된다. Client &lt;-&gt; Ticket-Granting Server 출처: Wikipedia - Kerberos 클라이언트는 자신의 비밀번호를 통해 Authentication Server로부터 전달받은 Msg A를 복호화해서 Kc_tgs(Ticket-Granting Server에 메시지를 보낼 때 암호화 할 키)를 얻어낸다. 클라이언트는 서버로부터 받았던 Msg B(이번 그림에서는 Msg C로 표현)와 Client ID와 Timestamp를 결합한 Msg D를 Ticket-Granting Server로 전달한다. Ticket Granting Server는 클라이언트로부터 전달받은 Msg C를 Ktgs를 통해 복호화한다. 복호화한 메시지에서 Tc_tgs를 획득한다. Ticket Granting Server는 3 에서 얻어낸 Tc_tgs를 통해 Msg D를 복호화한다. Msg D에서 얻어낸 Client ID와 Msg C의 Client ID를 비교해서 정상적으로 인증된 클라이언트인지 확인한다. 정상적으로 인증되었다면 6단계를 진행한다. 클라이언트와 클라이언트가 접근하고 싶은 서버 간의 통신에 사용되는 Kc_s를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg E)는 6에서 만들어낸 Kc_s와 클라이언트 정보(ID, Address, Validity)를 Ks(이 키는 Ticket-Granting Server와 실제 접속할 서버 사이에만 공유한다)를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg F)는 6에서 만들어낸 Kc_s를 Kc_tgs를 통해 암호화해서 만들어낸다. Msg B(=Msg C)를 탈취하여 임의의 Kc_tgs`를 통해 클라이언트 정보(ID, Timestamp)를 암호화해서 보냈다해도, Ticket Granting Server 에서 Msg B를 Ktgs를 통해 복호화 하여 얻어낸 Kc_tgs는 Kc_tgs`와 일치하지 않기 때문에 인증 과정이 종료된다. Msg E는 추후 클라이언트 &lt;-&gt; 서버 통신 시 Msg B(=Msg C)와 동일한 역할을 수행한다. Client &lt;-&gt; Server 출처: Wikipedia - Kerberos 클라이언트는 Ticket-Granting Server로부터 전달받은 Msg F를 Kc_tgs를 통해 복호화하여 Kc_s(Client가 Server에 메시지를 보낼 때 암호화 할 키)를 획득한다. 클라이언트는 서버로부터 받았던 Msg E와 Client ID와 Timestamp를 결합한 Msg G를 Server로 전달한다. Server는 클라이언트로부터 전달받은 Msg E를 Ks를 통해 복호화한다. 복호화한 메시지에서 Tc_s를 획득한다. Server는 3에서 획득한 T_cs를 통해 Msg G를 복호화한다. Msg G에서 얻어낸 Client ID와 Msg E의 Msg E에서 얻어낸 Client ID를 비교한다. 다음 글에서는 Docker 환경에서 KDC를 구성하고 SSH 서버 접근 시 Kerberos 인증을 통해 로그인하는 과정을 진행합니다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/kerberos_concept/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/kerberos_concept/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-21T19:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kerberos 개념" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"이 내용은 Wikipedia - Kerberos를 참고하여 작성하였습니다. Kerberos Kerberos는 보안되지 않은(un-secured) 네트워크에서 안전한 방법(secured manner)으로 노드 간 자격 증명을 수행하는 네트워크 인증 프로토콜이다. 사용자 비밀번호가 Network를 통해 교환되지 않기 때문에 MIMT(Main in the middle attack)을 통해 비밀번호 탈취가 불가능한 구조를 가지고 있는데, 어떻게 이런 특징을 가질 수 있는지 알아보도록 한다. 참여 주체 Kerberos 인증에는 Client, KDC(Key Distribution Center), Server가 참여한다. 일반적인 인증에서는 Client가 접근하고자 하는 서버와 인증을 수행하는 서버가 동일했지만, Kerberos에서는 접근하고자 하는 서버와 인증을 수행하는 서버(KDC)가 분리되어 있다. KDC는 Authentication Server와 Ticket-Granting Server로 이루어져 있다. Authentication Server: 사용자의 ID와 Password를 기반으로 실질적인 인증을 수행한다. Ticket-Granting Server: Client &lt;-&gt; Server 간 자격 증명에 사용되는 Ticket을 발급한다. 인증 프로세스 아래에서 나오는 Kx는 x라는 이름의 키(Key)를 의미한다. 예를 들어 Ktgs는 tgs라는 이름의 Key를 뜻한다. Client &lt;-&gt; Authentication Server 출처: Wikipedia - Kerberos 사용자는 Client Program에 ID, Password를 입력받는다. Client는 사용자의 ID를 KDC의 Authentication Server(AS)에 전달한다. Authentication Server는 사용자의 ID가 존재하는지 확인한다. Authentication Server는 모든 사용자의 정보(ID, Password)를 가지고 있다.(혹은 LDAP와 같은 외부 시스템에 저장된 정보에 접근할 수 있다) 사용자 ID가 존재한다면 자신이 가진 사용자의 비밀번호를 통해 키(Kc)를 만들어낸다. Client에게 전달할 Kc_tgs(Client와 Ticket Grant Server 간 통신 시 암/복호화에 사용할 키)를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg A)는 5 에서 만들어낸 Kc_tgs를 Kc를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg B)는 Kc_tgs와 클라이언트 정보(ID, Address, Validity)를 Ktgs(이 키는 Authentication Server와 Ticket-Granting Server 간에만 공유한다)를 통해 암호화해서 만들어낸다. 클라이언트 입장에서 사용자의 비밀번호는 Authentication Server로부터 전달받은 메시지(Msg A)를 복호화하는데만 사용된다. 만일 비밀번호가 틀린 경우 다음 인증 단계(Ticket-Granting Server)에서 사용할 Kc_tgs를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Authentication Server 입장에서 사용자의 비밀번호는 클라이언트에게 다음 인증 단계에서 사용할 Ticket과 메시지를 암호화하는데만 사용된다. 만일 클라이언트가 잘못된 비밀번호를 가지고 있다면 이 정보를 복호화 할 수 없기 때문에 인증 과정이 종료된다. Msg A는 클라이언트가 사용자의 비밀번호로 복호화 할 수 있는 반면, Msg B는 복호화가 불가능하다. Msg B는 KDC 내부적으로 클라이언트의 무결성을 증명하기 위한 값으로 활용된다. Client &lt;-&gt; Ticket-Granting Server 출처: Wikipedia - Kerberos 클라이언트는 자신의 비밀번호를 통해 Authentication Server로부터 전달받은 Msg A를 복호화해서 Kc_tgs(Ticket-Granting Server에 메시지를 보낼 때 암호화 할 키)를 얻어낸다. 클라이언트는 서버로부터 받았던 Msg B(이번 그림에서는 Msg C로 표현)와 Client ID와 Timestamp를 결합한 Msg D를 Ticket-Granting Server로 전달한다. Ticket Granting Server는 클라이언트로부터 전달받은 Msg C를 Ktgs를 통해 복호화한다. 복호화한 메시지에서 Tc_tgs를 획득한다. Ticket Granting Server는 3 에서 얻어낸 Tc_tgs를 통해 Msg D를 복호화한다. Msg D에서 얻어낸 Client ID와 Msg C의 Client ID를 비교해서 정상적으로 인증된 클라이언트인지 확인한다. 정상적으로 인증되었다면 6단계를 진행한다. 클라이언트와 클라이언트가 접근하고 싶은 서버 간의 통신에 사용되는 Kc_s를 생성한다. Client에게 두 가지 메시지를 전달한다. 첫번째 메시지(Msg E)는 6에서 만들어낸 Kc_s와 클라이언트 정보(ID, Address, Validity)를 Ks(이 키는 Ticket-Granting Server와 실제 접속할 서버 사이에만 공유한다)를 통해 암호화해서 만들어낸다. 두번째 메시지(Msg F)는 6에서 만들어낸 Kc_s를 Kc_tgs를 통해 암호화해서 만들어낸다. Msg B(=Msg C)를 탈취하여 임의의 Kc_tgs`를 통해 클라이언트 정보(ID, Timestamp)를 암호화해서 보냈다해도, Ticket Granting Server 에서 Msg B를 Ktgs를 통해 복호화 하여 얻어낸 Kc_tgs는 Kc_tgs`와 일치하지 않기 때문에 인증 과정이 종료된다. Msg E는 추후 클라이언트 &lt;-&gt; 서버 통신 시 Msg B(=Msg C)와 동일한 역할을 수행한다. Client &lt;-&gt; Server 출처: Wikipedia - Kerberos 클라이언트는 Ticket-Granting Server로부터 전달받은 Msg F를 Kc_tgs를 통해 복호화하여 Kc_s(Client가 Server에 메시지를 보낼 때 암호화 할 키)를 획득한다. 클라이언트는 서버로부터 받았던 Msg E와 Client ID와 Timestamp를 결합한 Msg G를 Server로 전달한다. Server는 클라이언트로부터 전달받은 Msg E를 Ks를 통해 복호화한다. 복호화한 메시지에서 Tc_s를 획득한다. Server는 3에서 획득한 T_cs를 통해 Msg G를 복호화한다. Msg G에서 얻어낸 Client ID와 Msg E의 Msg E에서 얻어낸 Client ID를 비교한다. 다음 글에서는 Docker 환경에서 KDC를 구성하고 SSH 서버 접근 시 Kerberos 인증을 통해 로그인하는 과정을 진행합니다.","url":"https://leeyh0216.github.io/posts/kerberos_concept/","@type":"BlogPosting","headline":"Kerberos 개념","dateModified":"2021-03-21T19:00:00+09:00","datePublished":"2021-03-21T19:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/kerberos_concept/"},"@context":"https://schema.org"}</script><title>Kerberos 개념 | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Kerberos 개념</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Kerberos 개념</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Mar 21, 2021, 7:00 PM +0900" prep="on" > Mar 21, 2021 <i class="unloaded">2021-03-21T19:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1610 words">8 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><blockquote><p>이 내용은 <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Wikipedia - Kerberos</a>를 참고하여 작성하였습니다.</p></blockquote><h1 id="kerberos">Kerberos</h1><p>Kerberos는 보안되지 않은(un-secured) 네트워크에서 안전한 방법(secured manner)으로 노드 간 자격 증명을 수행하는 네트워크 인증 프로토콜이다.</p><p>사용자 비밀번호가 Network를 통해 교환되지 않기 때문에 MIMT(Main in the middle attack)을 통해 비밀번호 탈취가 불가능한 구조를 가지고 있는데, 어떻게 이런 특징을 가질 수 있는지 알아보도록 한다.</p><h2 id="참여-주체">참여 주체</h2><p>Kerberos 인증에는 Client, KDC(Key Distribution Center), Server가 참여한다. 일반적인 인증에서는 Client가 접근하고자 하는 서버와 인증을 수행하는 서버가 동일했지만, Kerberos에서는 접근하고자 하는 서버와 인증을 수행하는 서버(KDC)가 분리되어 있다.</p><p>KDC는 Authentication Server와 Ticket-Granting Server로 이루어져 있다.</p><ul><li>Authentication Server: 사용자의 ID와 Password를 기반으로 실질적인 인증을 수행한다.<li>Ticket-Granting Server: Client &lt;-&gt; Server 간 자격 증명에 사용되는 Ticket을 발급한다.</ul><h2 id="인증-프로세스">인증 프로세스</h2><blockquote><p>아래에서 나오는 Kx는 x라는 이름의 키(Key)를 의미한다. 예를 들어 Ktgs는 tgs라는 이름의 Key를 뜻한다.</p></blockquote><h3 id="client---authentication-server">Client &lt;-&gt; Authentication Server</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../assets/kerberos/kerberos1.png" alt="Kerberos Auth1" /></p><blockquote><p>출처: <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Wikipedia - Kerberos</a></p></blockquote><ol><li>사용자는 Client Program에 ID, Password를 입력받는다.<li>Client는 사용자의 ID를 KDC의 Authentication Server(AS)에 전달한다.<li>Authentication Server는 사용자의 ID가 존재하는지 확인한다.<ul><li>Authentication Server는 모든 사용자의 정보(ID, Password)를 가지고 있다.(혹은 LDAP와 같은 외부 시스템에 저장된 정보에 접근할 수 있다)</ul><li>사용자 ID가 존재한다면 자신이 가진 사용자의 비밀번호를 통해 키(Kc)를 만들어낸다.<li>Client에게 전달할 Kc_tgs(Client와 Ticket Grant Server 간 통신 시 암/복호화에 사용할 키)를 생성한다.<li>Client에게 두 가지 메시지를 전달한다.<ul><li>첫번째 메시지(Msg A)는 5 에서 만들어낸 Kc_tgs를 Kc를 통해 암호화해서 만들어낸다.<li>두번째 메시지(Msg B)는 Kc_tgs와 클라이언트 정보(ID, Address, Validity)를 Ktgs(이 키는 Authentication Server와 Ticket-Granting Server 간에만 공유한다)를 통해 암호화해서 만들어낸다.</ul></ol><blockquote><ul><li><p>클라이언트 입장에서 사용자의 비밀번호는 Authentication Server로부터 전달받은 메시지(Msg A)를 복호화하는데만 사용된다. 만일 비밀번호가 틀린 경우 다음 인증 단계(Ticket-Granting Server)에서 사용할 Kc_tgs를 복호화 할 수 없기 때문에 인증 과정이 종료된다.</p><li><p>Authentication Server 입장에서 사용자의 비밀번호는 클라이언트에게 다음 인증 단계에서 사용할 Ticket과 메시지를 암호화하는데만 사용된다. 만일 클라이언트가 잘못된 비밀번호를 가지고 있다면 이 정보를 복호화 할 수 없기 때문에 인증 과정이 종료된다.</p><li><p>Msg A는 클라이언트가 사용자의 비밀번호로 복호화 할 수 있는 반면, Msg B는 복호화가 불가능하다. Msg B는 KDC 내부적으로 클라이언트의 무결성을 증명하기 위한 값으로 활용된다.</p></ul></blockquote><h3 id="client---ticket-granting-server">Client &lt;-&gt; Ticket-Granting Server</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../assets/kerberos/kerberos2.png" alt="Kerberos Auth2" /></p><blockquote><p>출처: <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Wikipedia - Kerberos</a></p></blockquote><ol><li>클라이언트는 자신의 비밀번호를 통해 Authentication Server로부터 전달받은 Msg A를 복호화해서 Kc_tgs(Ticket-Granting Server에 메시지를 보낼 때 암호화 할 키)를 얻어낸다.<li>클라이언트는 서버로부터 받았던 Msg B(이번 그림에서는 Msg C로 표현)와 Client ID와 Timestamp를 결합한 Msg D를 Ticket-Granting Server로 전달한다.<li>Ticket Granting Server는 클라이언트로부터 전달받은 Msg C를 Ktgs를 통해 복호화한다. 복호화한 메시지에서 Tc_tgs를 획득한다.<li>Ticket Granting Server는 3 에서 얻어낸 Tc_tgs를 통해 Msg D를 복호화한다.<li>Msg D에서 얻어낸 Client ID와 Msg C의 Client ID를 비교해서 정상적으로 인증된 클라이언트인지 확인한다. 정상적으로 인증되었다면 6단계를 진행한다.<li>클라이언트와 클라이언트가 접근하고 싶은 서버 간의 통신에 사용되는 Kc_s를 생성한다.<li>Client에게 두 가지 메시지를 전달한다.<ul><li>첫번째 메시지(Msg E)는 6에서 만들어낸 Kc_s와 클라이언트 정보(ID, Address, Validity)를 Ks(이 키는 Ticket-Granting Server와 실제 접속할 서버 사이에만 공유한다)를 통해 암호화해서 만들어낸다.<li>두번째 메시지(Msg F)는 6에서 만들어낸 Kc_s를 Kc_tgs를 통해 암호화해서 만들어낸다.</ul></ol><blockquote><ul><li><p>Msg B(=Msg C)를 탈취하여 임의의 Kc_tgs`를 통해 클라이언트 정보(ID, Timestamp)를 암호화해서 보냈다해도, Ticket Granting Server 에서 Msg B를 Ktgs를 통해 복호화 하여 얻어낸 Kc_tgs는 Kc_tgs`와 일치하지 않기 때문에 인증 과정이 종료된다.</p><li><p>Msg E는 추후 클라이언트 &lt;-&gt; 서버 통신 시 Msg B(=Msg C)와 동일한 역할을 수행한다.</p></ul></blockquote><h3 id="client---server">Client &lt;-&gt; Server</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../assets/kerberos/kerberos3.png" alt="Kerberos Auth3" /></p><blockquote><p>출처: <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Wikipedia - Kerberos</a></p></blockquote><ol><li>클라이언트는 Ticket-Granting Server로부터 전달받은 Msg F를 Kc_tgs를 통해 복호화하여 Kc_s(Client가 Server에 메시지를 보낼 때 암호화 할 키)를 획득한다.<li>클라이언트는 서버로부터 받았던 Msg E와 Client ID와 Timestamp를 결합한 Msg G를 Server로 전달한다.<li>Server는 클라이언트로부터 전달받은 Msg E를 Ks를 통해 복호화한다. 복호화한 메시지에서 Tc_s를 획득한다.<li>Server는 3에서 획득한 T_cs를 통해 Msg G를 복호화한다.<li>Msg G에서 얻어낸 Client ID와 Msg E의 Msg E에서 얻어낸 Client ID를 비교한다.</ol><hr /><p>다음 글에서는 Docker 환경에서 KDC를 구성하고 SSH 서버 접근 시 Kerberos 인증을 통해 로그인하는 과정을 진행합니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kerberos/" class="post-tag no-text-decoration" >kerberos</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Kerberos 개념 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/kerberos_concept/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Kerberos 개념 - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/kerberos_concept/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Kerberos 개념 - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/kerberos_concept/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/heap-and-gc/"><div class="card-body"> <span class="timeago small" > Jul 14 <i class="unloaded">2024-07-14T17:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM Heap과 GC를 다른 관점에서 바라보기</h3><div class="text-muted small"><p> 개요 Garbage Collection을 검색해보면 대부분의 글이 특정 GC(CMS, G1, Z 등)의 배경이 되는 이론(ex. Generational Collection Theory)이나, 알고리즘(ex. Mark-Sweep), 튜닝 등에 대한 내용을 다루고 있다. 그리고 해당 이론에 근거하여 Heap 메모리의 구조를 설명하다보니, Heap 영역을...</p></div></div></a></div><div class="card"> <a href="/posts/protobuf_2_5_build/"><div class="card-body"> <span class="timeago small" > Mar 10 <i class="unloaded">2024-03-10T12:10:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>protobuf 2.5 빌드하기(Apple Silicon)</h3><div class="text-muted small"><p> 이 문제는 Apple Silicon(M1, M2, M3 등)에서만 발생합니다. Ubuntu나 Intel Mac에서는 발생하지 않을 수 있음을 유의하시기 바랍니다. Hadoop 3.2.2 버전을 빌드하려다보니, 아래와 같은 메시지가 발생하며 빌드에 실패하였다. 1 [ERROR] Failed to execute goal org.apache.ha...</p></div></div></a></div><div class="card"> <a href="/posts/cmu_intro_to_database_2/"><div class="card-body"> <span class="timeago small" > Dec 22, 2023 <i class="unloaded">2023-12-22T11:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>데이터 엔지니어를 위한 CMU Intro to Database Systems#2</h3><div class="text-muted small"><p> Lecture #10: Sorting &amp; Aggregation Algorithms 참고자료: Youtube - F2023 #10 - Sorting &amp; Aggregation Algorithms (CMU Intro to Database Systems) Query Plan SQL문을 실행하면, DBMS는 쿼리를 Compile하여 Quer...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/flink_checkpoint_1/" class="btn btn-outline-primary" prompt="Older"><p>Flink Concept - Checkpointing(1)</p></a> <a href="/posts/flink_output/" class="btn btn-outline-primary" prompt="Newer"><p>Flink Concept - Operator 간 데이터 교환</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
