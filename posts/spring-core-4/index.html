<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8829030678254956" crossorigin="anonymous"></script><meta name="pv-proxy-endpoint" content=""><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Spring Core Technologies - The IoC Container(4)" /><meta name="author" content="leeyh0216" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 객체)을 생성자 인자 팩토리 메서드의 인자 Setter 를 통해 정의하여 Container가 해당 객체를 생성할 때, 필요한 의존 객체들을 주입해주는 방식을 말한다. 의존성 주입을 이용하면 코드가 깔끔해지고, 객체와 의존 객체들을 효과적으로 Decoupling 시킬 수 있다. 의존성 주입은 크게 생성자를 통한 의존성 주입과 Setter 기반의 의존성 주입으로 존재한다. 생성자를 통한 의존성 주입 생성자를 통한 의존성 주입은 객체가 의존성을 생성자의 인자에 표현하고, Container가 해당 인자들로 생성자를 호출하는 방식이다. 이 방식은 Static Factory Method를 사용하는 방식과 거의 비슷하다. Constructor Argument Resolution Container는 생성자의 인자 타입을 이용하여 의존성을 주입한다. 생성자 인자들 간의 모호성이 없는 경우는 생성자에 정의된 순서대로 의존성들이 초기화 된 후 주입된다. 아래와 같이 DependencyA DependencyB MyService 3개의 컴포넌트가 존재하고, MyService 객체가 DependencyA와 DependencyB에 의존한다고 생각해보자. DepencencyA.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyA { public DependencyA(){ System.out.println(&quot;DependencyA initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyA&quot;); } } DependencyB.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyB { public DependencyB(){ System.out.println(&quot;DependencyB initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyB&quot;); } } MyService.java 아래의 MyService 객체는 생성자를 통해 DependencyA와 DependencyB를 주입받고 초기화되는 것을 볼 수 있다. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } Application.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printAllDependencies(); } } 위의 코드를 실행해보면 DependencyA initialized DependencyB initialized MyService initialized This is DependencyA This is DependencyB 와 같이 출력되는 것을 확인할 수 있다. 우리는 명시적으로 MyService, DependencyA, DependencyB 객체를 MyService는 의존성으로 DependencyA, DependencyB 가 필요하기 때문에, Container는 DependencyA -&gt; DependencyB -&gt; MyService Bean들을 초기화하게 된다. int, long, double 등의 Primitive Type이나 Integer, Long, Double 등의 Object Type들도 Bean으로 만들 수 있다. 위의 예제를 아래와 같이 변경해보자. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.constructbaseddi&quot;) public class AppConfig { @Bean(&quot;age&quot;) public Integer getAge(){ return Integer.valueOf(27); } } package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB, Integer age){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; System.out.println(&quot;Age: &quot; + age); } public void printAllDependencies(){ depA.printName(); depB.printName(); } 위의 예제를 실행시켜보면 아래와 같이 출력되는 것을 확인할 수 있다. DependencyA initialized DependencyB initialized MyService initialized Age: 27 This is DependencyA This is DependencyB @Configuration 어노테이션이 붙은 AppConfig 클래스에서 age Bean을 초기화시켰기 때문에 MyService 생성자의 age라는 이름의 Integer 타입의 인자에 해당 값이 주입된 것을 확인할 수 있다. Setter를 통한 의존성 주입 Setter를 통한 의존성 주입은 Container 인자가 없는 생성자 혹은 인자가 없는 Static Factory Method를 통해 초기화되는 Bean의 의존성을 Setter를 통해 의존 객체를 주입해주는 방식을 말한다. 아래와 같이 MyService 클래스를 변경해보자. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(){ System.out.println(&quot;MyService initialized&quot;); } @Autowired public void setDependencyA(DependencyA depA){ System.out.println(&quot;DependencyA setted&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 해당 예제를 실행해보면 아래와 같은 결과가 출력되는 것을 볼 수 있다. DependencyA initialized DependencyB initialized MyService initialized DependencyB setted DependencyA setted This is DependencyA This is DependencyB Container는 위와 같이 DependencyA, DependencyB, MyService 객체를 모두 초기화한 후, @Autowired 어노테이션이 붙어 있는 함수를 호출하여 의존성을 주입해주게 된다. 여기서 잠깐! 분명 Spring 문서에는 Container는 인자가 없는 생성자나 인자가 없는 Static Factory Method 를 통해 초기화되는 Bean에 대해서만 Setter를 통한 의존성 주입을 한다. 라고 쓰여 있다. 그러나 아래와 같은 방식으로 Constructer Based D.I 와 Setter Based D.I 를 혼합하여 사용할 수도 있었다. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(@Autowired DependencyA depA){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 생성자를 통한 의존성 주입 or Setter를 통한 의존성 주입 생성자를 통한 의존성 주입은 반드시 필요한 의존성을 주입 받을 때 사용하고 Setter를 통한 의존성 주입은 추가적으로 필요한 의존성을 주입받을 때 사용하면 좋다. 생성자를 통한 의존성 주입의 경우 생성자로 전달되는 인자가 많은 경우 코드 악취를 풍길 수 있다. Setter를 통한 의존성 주입을 @Required 어노테이션과 함께 사용하는 경우(일치하는 Bean이 존재하지 않을 경우 NULL이 들어옴) NPE가 발생할 수 있으므로 해당 의존성을 사용하는 모든 코드에서 Not-Null Check를 해주어야 한다. 써드파티 라이브러리의 경우 Setter를 제공하지 않는 클래스가 존재할 수 있기 때문에 대부분 생성자를 통한 의존성 주입을 사용할 수 밖에 없다." /><meta property="og:description" content="The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 객체)을 생성자 인자 팩토리 메서드의 인자 Setter 를 통해 정의하여 Container가 해당 객체를 생성할 때, 필요한 의존 객체들을 주입해주는 방식을 말한다. 의존성 주입을 이용하면 코드가 깔끔해지고, 객체와 의존 객체들을 효과적으로 Decoupling 시킬 수 있다. 의존성 주입은 크게 생성자를 통한 의존성 주입과 Setter 기반의 의존성 주입으로 존재한다. 생성자를 통한 의존성 주입 생성자를 통한 의존성 주입은 객체가 의존성을 생성자의 인자에 표현하고, Container가 해당 인자들로 생성자를 호출하는 방식이다. 이 방식은 Static Factory Method를 사용하는 방식과 거의 비슷하다. Constructor Argument Resolution Container는 생성자의 인자 타입을 이용하여 의존성을 주입한다. 생성자 인자들 간의 모호성이 없는 경우는 생성자에 정의된 순서대로 의존성들이 초기화 된 후 주입된다. 아래와 같이 DependencyA DependencyB MyService 3개의 컴포넌트가 존재하고, MyService 객체가 DependencyA와 DependencyB에 의존한다고 생각해보자. DepencencyA.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyA { public DependencyA(){ System.out.println(&quot;DependencyA initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyA&quot;); } } DependencyB.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyB { public DependencyB(){ System.out.println(&quot;DependencyB initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyB&quot;); } } MyService.java 아래의 MyService 객체는 생성자를 통해 DependencyA와 DependencyB를 주입받고 초기화되는 것을 볼 수 있다. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } Application.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printAllDependencies(); } } 위의 코드를 실행해보면 DependencyA initialized DependencyB initialized MyService initialized This is DependencyA This is DependencyB 와 같이 출력되는 것을 확인할 수 있다. 우리는 명시적으로 MyService, DependencyA, DependencyB 객체를 MyService는 의존성으로 DependencyA, DependencyB 가 필요하기 때문에, Container는 DependencyA -&gt; DependencyB -&gt; MyService Bean들을 초기화하게 된다. int, long, double 등의 Primitive Type이나 Integer, Long, Double 등의 Object Type들도 Bean으로 만들 수 있다. 위의 예제를 아래와 같이 변경해보자. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.constructbaseddi&quot;) public class AppConfig { @Bean(&quot;age&quot;) public Integer getAge(){ return Integer.valueOf(27); } } package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB, Integer age){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; System.out.println(&quot;Age: &quot; + age); } public void printAllDependencies(){ depA.printName(); depB.printName(); } 위의 예제를 실행시켜보면 아래와 같이 출력되는 것을 확인할 수 있다. DependencyA initialized DependencyB initialized MyService initialized Age: 27 This is DependencyA This is DependencyB @Configuration 어노테이션이 붙은 AppConfig 클래스에서 age Bean을 초기화시켰기 때문에 MyService 생성자의 age라는 이름의 Integer 타입의 인자에 해당 값이 주입된 것을 확인할 수 있다. Setter를 통한 의존성 주입 Setter를 통한 의존성 주입은 Container 인자가 없는 생성자 혹은 인자가 없는 Static Factory Method를 통해 초기화되는 Bean의 의존성을 Setter를 통해 의존 객체를 주입해주는 방식을 말한다. 아래와 같이 MyService 클래스를 변경해보자. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(){ System.out.println(&quot;MyService initialized&quot;); } @Autowired public void setDependencyA(DependencyA depA){ System.out.println(&quot;DependencyA setted&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 해당 예제를 실행해보면 아래와 같은 결과가 출력되는 것을 볼 수 있다. DependencyA initialized DependencyB initialized MyService initialized DependencyB setted DependencyA setted This is DependencyA This is DependencyB Container는 위와 같이 DependencyA, DependencyB, MyService 객체를 모두 초기화한 후, @Autowired 어노테이션이 붙어 있는 함수를 호출하여 의존성을 주입해주게 된다. 여기서 잠깐! 분명 Spring 문서에는 Container는 인자가 없는 생성자나 인자가 없는 Static Factory Method 를 통해 초기화되는 Bean에 대해서만 Setter를 통한 의존성 주입을 한다. 라고 쓰여 있다. 그러나 아래와 같은 방식으로 Constructer Based D.I 와 Setter Based D.I 를 혼합하여 사용할 수도 있었다. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(@Autowired DependencyA depA){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 생성자를 통한 의존성 주입 or Setter를 통한 의존성 주입 생성자를 통한 의존성 주입은 반드시 필요한 의존성을 주입 받을 때 사용하고 Setter를 통한 의존성 주입은 추가적으로 필요한 의존성을 주입받을 때 사용하면 좋다. 생성자를 통한 의존성 주입의 경우 생성자로 전달되는 인자가 많은 경우 코드 악취를 풍길 수 있다. Setter를 통한 의존성 주입을 @Required 어노테이션과 함께 사용하는 경우(일치하는 Bean이 존재하지 않을 경우 NULL이 들어옴) NPE가 발생할 수 있으므로 해당 의존성을 사용하는 모든 코드에서 Not-Null Check를 해주어야 한다. 써드파티 라이브러리의 경우 Setter를 제공하지 않는 클래스가 존재할 수 있기 때문에 대부분 생성자를 통한 의존성 주입을 사용할 수 밖에 없다." /><link rel="canonical" href="https://leeyh0216.github.io/posts/spring-core-4/" /><meta property="og:url" content="https://leeyh0216.github.io/posts/spring-core-4/" /><meta property="og:site_name" content="leeyh0216’s devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-12-23T10:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Core Technologies - The IoC Container(4)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@leeyh0216" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"leeyh0216"},"description":"The IoC Container Dependencies 간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다. Dependency Injection 의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 객체)을 생성자 인자 팩토리 메서드의 인자 Setter 를 통해 정의하여 Container가 해당 객체를 생성할 때, 필요한 의존 객체들을 주입해주는 방식을 말한다. 의존성 주입을 이용하면 코드가 깔끔해지고, 객체와 의존 객체들을 효과적으로 Decoupling 시킬 수 있다. 의존성 주입은 크게 생성자를 통한 의존성 주입과 Setter 기반의 의존성 주입으로 존재한다. 생성자를 통한 의존성 주입 생성자를 통한 의존성 주입은 객체가 의존성을 생성자의 인자에 표현하고, Container가 해당 인자들로 생성자를 호출하는 방식이다. 이 방식은 Static Factory Method를 사용하는 방식과 거의 비슷하다. Constructor Argument Resolution Container는 생성자의 인자 타입을 이용하여 의존성을 주입한다. 생성자 인자들 간의 모호성이 없는 경우는 생성자에 정의된 순서대로 의존성들이 초기화 된 후 주입된다. 아래와 같이 DependencyA DependencyB MyService 3개의 컴포넌트가 존재하고, MyService 객체가 DependencyA와 DependencyB에 의존한다고 생각해보자. DepencencyA.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyA { public DependencyA(){ System.out.println(&quot;DependencyA initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyA&quot;); } } DependencyB.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class DependencyB { public DependencyB(){ System.out.println(&quot;DependencyB initialized&quot;); } public void printName(){ System.out.println(&quot;This is DependencyB&quot;); } } MyService.java 아래의 MyService 객체는 생성자를 통해 DependencyA와 DependencyB를 주입받고 초기화되는 것을 볼 수 있다. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } Application.java package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printAllDependencies(); } } 위의 코드를 실행해보면 DependencyA initialized DependencyB initialized MyService initialized This is DependencyA This is DependencyB 와 같이 출력되는 것을 확인할 수 있다. 우리는 명시적으로 MyService, DependencyA, DependencyB 객체를 MyService는 의존성으로 DependencyA, DependencyB 가 필요하기 때문에, Container는 DependencyA -&gt; DependencyB -&gt; MyService Bean들을 초기화하게 된다. int, long, double 등의 Primitive Type이나 Integer, Long, Double 등의 Object Type들도 Bean으로 만들 수 있다. 위의 예제를 아래와 같이 변경해보자. package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.constructbaseddi&quot;) public class AppConfig { @Bean(&quot;age&quot;) public Integer getAge(){ return Integer.valueOf(27); } } package com.leeyh0216.springstudy.constructbaseddi; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(DependencyA depA, DependencyB depB, Integer age){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; this.depB = depB; System.out.println(&quot;Age: &quot; + age); } public void printAllDependencies(){ depA.printName(); depB.printName(); } 위의 예제를 실행시켜보면 아래와 같이 출력되는 것을 확인할 수 있다. DependencyA initialized DependencyB initialized MyService initialized Age: 27 This is DependencyA This is DependencyB @Configuration 어노테이션이 붙은 AppConfig 클래스에서 age Bean을 초기화시켰기 때문에 MyService 생성자의 age라는 이름의 Integer 타입의 인자에 해당 값이 주입된 것을 확인할 수 있다. Setter를 통한 의존성 주입 Setter를 통한 의존성 주입은 Container 인자가 없는 생성자 혹은 인자가 없는 Static Factory Method를 통해 초기화되는 Bean의 의존성을 Setter를 통해 의존 객체를 주입해주는 방식을 말한다. 아래와 같이 MyService 클래스를 변경해보자. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(){ System.out.println(&quot;MyService initialized&quot;); } @Autowired public void setDependencyA(DependencyA depA){ System.out.println(&quot;DependencyA setted&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 해당 예제를 실행해보면 아래와 같은 결과가 출력되는 것을 볼 수 있다. DependencyA initialized DependencyB initialized MyService initialized DependencyB setted DependencyA setted This is DependencyA This is DependencyB Container는 위와 같이 DependencyA, DependencyB, MyService 객체를 모두 초기화한 후, @Autowired 어노테이션이 붙어 있는 함수를 호출하여 의존성을 주입해주게 된다. 여기서 잠깐! 분명 Spring 문서에는 Container는 인자가 없는 생성자나 인자가 없는 Static Factory Method 를 통해 초기화되는 Bean에 대해서만 Setter를 통한 의존성 주입을 한다. 라고 쓰여 있다. 그러나 아래와 같은 방식으로 Constructer Based D.I 와 Setter Based D.I 를 혼합하여 사용할 수도 있었다. package com.leeyh0216.springstudy.setterbaseddi; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyService { private DependencyA depA; private DependencyB depB; public MyService(@Autowired DependencyA depA){ System.out.println(&quot;MyService initialized&quot;); this.depA = depA; } @Autowired public void setDependencyB(DependencyB depB){ System.out.println(&quot;DependencyB setted&quot;); this.depB = depB; } public void printAllDependencies(){ depA.printName(); depB.printName(); } } 생성자를 통한 의존성 주입 or Setter를 통한 의존성 주입 생성자를 통한 의존성 주입은 반드시 필요한 의존성을 주입 받을 때 사용하고 Setter를 통한 의존성 주입은 추가적으로 필요한 의존성을 주입받을 때 사용하면 좋다. 생성자를 통한 의존성 주입의 경우 생성자로 전달되는 인자가 많은 경우 코드 악취를 풍길 수 있다. Setter를 통한 의존성 주입을 @Required 어노테이션과 함께 사용하는 경우(일치하는 Bean이 존재하지 않을 경우 NULL이 들어옴) NPE가 발생할 수 있으므로 해당 의존성을 사용하는 모든 코드에서 Not-Null Check를 해주어야 한다. 써드파티 라이브러리의 경우 Setter를 제공하지 않는 클래스가 존재할 수 있기 때문에 대부분 생성자를 통한 의존성 주입을 사용할 수 밖에 없다.","url":"https://leeyh0216.github.io/posts/spring-core-4/","@type":"BlogPosting","headline":"Spring Core Technologies - The IoC Container(4)","dateModified":"2018-12-23T10:00:00+09:00","datePublished":"2018-12-23T10:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://leeyh0216.github.io/posts/spring-core-4/"},"@context":"https://schema.org"}</script><title>Spring Core Technologies - The IoC Container(4) | leeyh0216's devlog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/npm/countup.js@1.9.3/dist/countUp.min.js"></script> <script async src="/assets/js/dist/pvreport.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-129061352-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-129061352-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">leeyh0216's devlog</a></div><div class="site-subtitle font-italic">개발/일상 블로그</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/leeyh0216" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/%EC%9A%A9%ED%99%98-%EC%9D%B4-84222a119/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['leeyh0216','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Spring Core Technologies - The IoC Container(4)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Core Technologies - The IoC Container(4)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> leeyh0216 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Dec 23, 2018, 10:00 AM +0900" prep="on" > Dec 23, 2018 <i class="unloaded">2018-12-23T10:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1524 words">8 min</span> <span id="pv" class="pageviews"><i class="fas fa-spinner fa-spin fa-fw"></i></span></div></div><div class="post-content"><h1 id="the-ioc-container">The IoC Container</h1><h2 id="dependencies">Dependencies</h2><p>간단한 어플리케이션부터 기업형 어플리케이션까지 하나의 객체로만 동작하는 프로그램은 없다. 적어도 몇개의 객체들이 서로 상호작용하며 어플리케이션을 구성하고 있다.</p><h3 id="dependency-injection">Dependency Injection</h3><p>의존성 주입(Dependency Injection, D.I)은 객체들이 자신의 의존성(의존 객체)을</p><ul><li>생성자 인자<li>팩토리 메서드의 인자<li>Setter</ul><p>를 통해 정의하여 Container가 해당 객체를 생성할 때, 필요한 의존 객체들을 주입해주는 방식을 말한다.</p><p>의존성 주입을 이용하면 코드가 깔끔해지고, 객체와 의존 객체들을 효과적으로 Decoupling 시킬 수 있다.</p><p>의존성 주입은 크게 <strong>생성자를 통한 의존성 주입</strong>과 <strong>Setter 기반의 의존성 주입</strong>으로 존재한다.</p><h4 id="생성자를-통한-의존성-주입">생성자를 통한 의존성 주입</h4><p>생성자를 통한 의존성 주입은 객체가 의존성을 생성자의 인자에 표현하고, Container가 해당 인자들로 생성자를 호출하는 방식이다. 이 방식은 Static Factory Method를 사용하는 방식과 거의 비슷하다.</p><h5 id="constructor-argument-resolution">Constructor Argument Resolution</h5><p>Container는 생성자의 인자 타입을 이용하여 의존성을 주입한다. 생성자 인자들 간의 모호성이 없는 경우는 생성자에 정의된 순서대로 의존성들이 초기화 된 후 주입된다.</p><p>아래와 같이</p><ul><li>DependencyA<li>DependencyB<li>MyService</ul><p>3개의 컴포넌트가 존재하고, <code class="language-plaintext highlighter-rouge">MyService</code> 객체가 <code class="language-plaintext highlighter-rouge">DependencyA</code>와 <code class="language-plaintext highlighter-rouge">DependencyB</code>에 의존한다고 생각해보자.</p><p><strong>DepencencyA.java</strong></p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DependencyA</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">DependencyA</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyA initialized"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is DependencyA"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure><p><strong>DependencyB.java</strong></p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DependencyB</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">DependencyB</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyB initialized"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is DependencyB"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p><strong>MyService.java</strong></p><p>아래의 <code class="language-plaintext highlighter-rouge">MyService</code> 객체는 생성자를 통해 <code class="language-plaintext highlighter-rouge">DependencyA</code>와 <code class="language-plaintext highlighter-rouge">DependencyB</code>를 주입받고 초기화되는 것을 볼 수 있다.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">,</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService initialized"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depA</span> <span class="o">=</span> <span class="n">depA</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depB</span> <span class="o">=</span> <span class="n">depB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAllDependencies</span><span class="o">(){</span>
        <span class="n">depA</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
        <span class="n">depB</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p><strong>Application.java</strong></p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printAllDependencies</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>위의 코드를 실행해보면</p><figure class="highlight"><pre><code class="language-text" data-lang="text">DependencyA initialized
DependencyB initialized
MyService initialized
This is DependencyA
This is DependencyB</code></pre></figure><p>와 같이 출력되는 것을 확인할 수 있다.</p><p>우리는 명시적으로 <code class="language-plaintext highlighter-rouge">MyService</code>, <code class="language-plaintext highlighter-rouge">DependencyA</code>, <code class="language-plaintext highlighter-rouge">DependencyB</code> 객체를 MyService는 의존성으로 DependencyA, DependencyB 가 필요하기 때문에, Container는 DependencyA -&gt; DependencyB -&gt; MyService Bean들을 초기화하게 된다.</p><p><code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">double</code> 등의 Primitive Type이나 <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Long</code>, <code class="language-plaintext highlighter-rouge">Double</code> 등의 Object Type들도 Bean으로 만들 수 있다.</p><p>위의 예제를 아래와 같이 변경해보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.constructbaseddi"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"age"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getAge</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">27</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.constructbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">,</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService initialized"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depA</span> <span class="o">=</span> <span class="n">depA</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depB</span> <span class="o">=</span> <span class="n">depB</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAllDependencies</span><span class="o">(){</span>
        <span class="n">depA</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
        <span class="n">depB</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
    <span class="o">}</span></code></pre></figure><p>위의 예제를 실행시켜보면 아래와 같이 출력되는 것을 확인할 수 있다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">DependencyA initialized
DependencyB initialized
MyService initialized
Age: 27
This is DependencyA
This is DependencyB</code></pre></figure><p><code class="language-plaintext highlighter-rouge">@Configuration</code> 어노테이션이 붙은 AppConfig 클래스에서 age Bean을 초기화시켰기 때문에 <code class="language-plaintext highlighter-rouge">MyService</code> 생성자의 age라는 이름의 Integer 타입의 인자에 해당 값이 주입된 것을 확인할 수 있다.</p><h4 id="setter를-통한-의존성-주입">Setter를 통한 의존성 주입</h4><p>Setter를 통한 의존성 주입은 Container 인자가 없는 생성자 혹은 인자가 없는 Static Factory Method를 통해 초기화되는 Bean의 의존성을 Setter를 통해 의존 객체를 주입해주는 방식을 말한다.</p><p>아래와 같이 <code class="language-plaintext highlighter-rouge">MyService</code> 클래스를 변경해보자.</p><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.setterbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService initialized"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDependencyA</span><span class="o">(</span><span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyA setted"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depA</span> <span class="o">=</span> <span class="n">depA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDependencyB</span><span class="o">(</span><span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyB setted"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depB</span> <span class="o">=</span> <span class="n">depB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAllDependencies</span><span class="o">(){</span>
        <span class="n">depA</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
        <span class="n">depB</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>해당 예제를 실행해보면 아래와 같은 결과가 출력되는 것을 볼 수 있다.</p><figure class="highlight"><pre><code class="language-text" data-lang="text">DependencyA initialized
DependencyB initialized
MyService initialized
DependencyB setted
DependencyA setted
This is DependencyA
This is DependencyB</code></pre></figure><p>Container는 위와 같이 DependencyA, DependencyB, MyService 객체를 모두 초기화한 후, <code class="language-plaintext highlighter-rouge">@Autowired</code> 어노테이션이 붙어 있는 함수를 호출하여 의존성을 주입해주게 된다.</p><blockquote><p>여기서 잠깐! 분명 Spring 문서에는</p><blockquote><p>Container는 인자가 없는 생성자나 인자가 없는 Static Factory Method 를 통해 초기화되는 Bean에 대해서만 Setter를 통한 의존성 주입을 한다. 라고 쓰여 있다. 그러나 아래와 같은 방식으로 Constructer Based D.I 와 Setter Based D.I 를 혼합하여 사용할 수도 있었다.</p></blockquote></blockquote><figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.leeyh0216.springstudy.setterbaseddi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="nd">@Autowired</span> <span class="nc">DependencyA</span> <span class="n">depA</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService initialized"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depA</span> <span class="o">=</span> <span class="n">depA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDependencyB</span><span class="o">(</span><span class="nc">DependencyB</span> <span class="n">depB</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DependencyB setted"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depB</span> <span class="o">=</span> <span class="n">depB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAllDependencies</span><span class="o">(){</span>
        <span class="n">depA</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
        <span class="n">depB</span><span class="o">.</span><span class="na">printName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure><h4 id="생성자를-통한-의존성-주입-or-setter를-통한-의존성-주입">생성자를 통한 의존성 주입 or Setter를 통한 의존성 주입</h4><p>생성자를 통한 의존성 주입은 반드시 필요한 의존성을 주입 받을 때 사용하고 Setter를 통한 의존성 주입은 추가적으로 필요한 의존성을 주입받을 때 사용하면 좋다.</p><ul><li><p>생성자를 통한 의존성 주입의 경우 생성자로 전달되는 인자가 많은 경우 코드 악취를 풍길 수 있다.</p><li><p>Setter를 통한 의존성 주입을 <code class="language-plaintext highlighter-rouge">@Required</code> 어노테이션과 함께 사용하는 경우(일치하는 Bean이 존재하지 않을 경우 NULL이 들어옴) NPE가 발생할 수 있으므로 해당 의존성을 사용하는 모든 코드에서 Not-Null Check를 해주어야 한다.</p><li><p>써드파티 라이브러리의 경우 Setter를 제공하지 않는 클래스가 존재할 수 있기 때문에 대부분 생성자를 통한 의존성 주입을 사용할 수 밖에 없다.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring Core Technologies - The IoC Container(4) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-4/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring Core Technologies - The IoC Container(4) - leeyh0216's devlog&u=https://leeyh0216.github.io/posts/spring-core-4/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Spring Core Technologies - The IoC Container(4) - leeyh0216's devlog&url=https://leeyh0216.github.io/posts/spring-core-4/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache-spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache-druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/spring-cloud-zuul/"><div class="card-body"> <span class="timeago small" > Nov 10, 2018 <i class="unloaded">2018-11-10T15:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring Cloud - Zuul(1)</h3><div class="text-muted small"><p> 개요 2017년 후반부터 2018년 초까지 팀 내 서비스들을 마이크로서비스 아키텍쳐 형태로 개발하는 프로젝트를 진행하였다. 사내에서 L7 Switch를 제공하고 있었지만, 서비스가 추가될 때마다 요청하기도 번거롭고 Software Level Gateway에서만 할 수 있는 작업들도 여럿 있었다. 당시에 Gateway 후보로 Spring Cloud...</p></div></div></a></div><div class="card"> <a href="/posts/ioc_and_di_pattern/"><div class="card-body"> <span class="timeago small" > Dec 19, 2018 <i class="unloaded">2018-12-19T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Inversion of Control Containers and the Dependency Injection pattern</h3><div class="text-muted small"><p> 이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 ...</p></div></div></a></div><div class="card"> <a href="/posts/spring-rabbitmq-1/"><div class="card-body"> <span class="timeago small" > Dec 30, 2018 <i class="unloaded">2018-12-30T10:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Spring with RabbitMQ(1)</h3><div class="text-muted small"><p> Spring with RabbitMQ Pre Requirements RabbitMQ 3.6 RabbitMQ 설치(Docker) RabbitMQ를 물리 서버에 설치하기 위해서는 Erlang 설치를 선행한 후 RabbitMQ를 설치해야 하지만 테스트 용도이기 때문에 Docker로 설치 진행한다. Docker Hub의 RabbitMQ 페이지...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ioc_and_di_pattern/" class="btn btn-outline-primary" prompt="Older"><p>Inversion of Control Containers and the Dependency Injection pattern</p></a> <a href="/posts/spring-rabbitmq-1/" class="btn btn-outline-primary" prompt="Newer"><p>Spring with RabbitMQ(1)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">leeyh0216</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/leetcode/">leetcode</a> <a class="post-tag" href="/tags/apache-spark/">apache spark</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/apache-druid/">apache druid</a> <a class="post-tag" href="/tags/string/">string</a> <a class="post-tag" href="/tags/study/">study</a> <a class="post-tag" href="/tags/docker/">docker</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://leeyh0216.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
